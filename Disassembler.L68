00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/5/2016 12:00:29 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Kyle Farmer
00000000                             4  * Date       : 5/11/2016
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000                             7  start_input DS.B       20   * address used to store user input for start address
00000014                             8  start_flag  DS.B       1    * used to determine if the start address has been entered
00000015                             9  EA_FLAG     DS.B       80   * set if an error in the instruction caused A4 to move beyond next instruction
00000065                            10  lines_flag  DS.B       10   * number of lines until the halt display needs to be called
0000006F                            11  end_input   DS.B       20   * address used to store user input for end address
00000083                            12  printCode   DS.B       40   * starting address to print each line of code
000000AB                            13  restart_in  DS.B       30   * get the user input for restart
000000C9                            14  
000000C9  =00000000                 15  minStart    EQU        $00000000
000000C9  =00FFFFE0                 16  maxEnd      EQU        $00FFFFE0
000000C9  =0000000D                 17  CR          EQU        $0D
000000C9  =0000000A                 18  LF          EQU        $0A
000000C9                            19  
00001000                            20      ORG    $1000
00001000                            21      
00001000                            22  START  
00001000  4C9A 0006                 23              MOVEM.W (A2)+,D1-D2
00001004  4C9A 000E                 24              MOVEM.W (A2)+,D1-D3
00001008  4C9A 0202                 25              MOVEM.W (A2)+,D1/A1
0000100C  11FC 0000 0065            26              MOVE.B  #$0,lines_flag  * initialize lines to 0
00001012  11FC 0000 0014            27              MOVE.B  #$0,start_flag  *initialize start flag to 0
00001018  11FC 0000 0015            28              MOVE.B  #$0,EA_FLAG     * initialize ea flag to 0        
0000101E                            29  * gather user input for starting address *
0000101E  43F9 000011E6             30  GET_LOWER   LEA     startAddr,A1
00001024  700E                      31              MOVE.L  #14,D0
00001026  4E4F                      32              TRAP    #15
00001028  43F8 0000                 33              LEA     start_input,A1
0000102C  7002                      34              MOVE.L  #2,D0
0000102E  4E4F                      35              TRAP    #15
00001030  4244                      36              CLR     D4
00001032  4EB9 00001066             37              JSR     CHECK_INPUT
00001038  4EB9 00001122             38              JSR     CHK_BOUNDS
0000103E  2844                      39              MOVE.L  D4,A4
00001040                            40  * gather user input for upper address            
00001040  43F9 0000121F             41  GET_UPPER   LEA     endAddr,A1
00001046  700E                      42              MOVE.L  #14,D0
00001048  4E4F                      43              TRAP    #15
0000104A  43F8 006F                 44              LEA     end_input,A1
0000104E  7002                      45              MOVE.L  #2,D0
00001050  4E4F                      46              TRAP    #15
00001052  4244                      47              CLR     D4
00001054  4EB9 00001066             48              JSR     CHECK_INPUT
0000105A  4EB9 00001122             49              JSR     CHK_BOUNDS
00001060  2A44                      50              MOVE.L  D4,A5
00001062  6000 0448                 51              BRA     MAIN
00001066                            52              
00001066                            53  ****************************************************************
00001066                            54  * CHECK_INPUT:                                               *
00001066                            55  * Checks input for the entered string and convert ascii to hex *
00001066                            56  * and determines if the address entered was valid              *
00001066                            57  ****************************************************************
00001066                            58  
00001066                            59  CHECK_INPUT
00001066  183C 0000                 60              MOVE.B  #$0,D4   * D4 will be register to hold resultant address
0000106A  B23C 0000                 61              CMP.B   #$0,D1
0000106E  6700 0064                 62              BEQ     noInput  * check for no address entered
00001072  0C41 0008                 63              CMPI    #$8,D1  
00001076  6E00 0076                 64              BGT     boundsErr  * check for too many chars entered
0000107A                            65         
0000107A  1419                      66  readNext    MOVE.B  (A1)+,D2    
0000107C  0C02 0000                 67              CMPI.B   #$0,D2       * check for NULL, indicating finished
00001080  6700 0050                 68              BEQ     readDone
00001084                            69              * check upper and lower ASCII bounds: 0-f
00001084  0C02 0030                 70              CMPI.B   #$30,D2     * entered an ASCII less than 0
00001088  6D00 007E                 71              BLT     charError
0000108C  0C02 0066                 72              CMPI.B   #$66,D2     * entered an ASCII greater than 'f'
00001090  6E00 0076                 73              BGT     charError
00001094                            74              * within bounds so check for valid inputs
00001094  0C02 0039                 75              CMPI.B   #$39,D2     
00001098  6E00 000C                 76              BGT     upHex       * entered an ASCII greater than 0-9
0000109C                            77              
0000109C                            78              * value is between 0-9, convert to decimal
0000109C  0402 0030                 79              SUBI.B  #$30,D2     * subtract $30 to get its dec representation
000010A0  E98C                      80              LSL.L   #4,D4       * shift resultant left 4 bits
000010A2  D802                      81              ADD.B   D2,D4       * add the next 4 bits to resultant
000010A4  60D4                      82              BRA     readNext
000010A6                            83              
000010A6                            84              * value is larger than decimal number, but within range
000010A6  0C02 0046                 85  upHex       CMPI.B  #$46,D2     * cmp value to 'F'
000010AA  6E00 0014                 86              BGT     loHex       * value is larger than uppercase hex
000010AE  B43C 0040                 87              CMP.B   #$40,D2     * cmp value to 'A'
000010B2  6D00 0054                 88              BLT     charError       * value is an unsupported character
000010B6                            89              
000010B6                            90              * value is not below A or above F, convert to hex and add to D6
000010B6  0402 0037                 91              SUBI.B  #$37,D2
000010BA  E98C                      92              LSL.L   #4,D4       * shift left 4 bits
000010BC  D802                      93              ADD.B   D2,D4       * add the next 4 bits
000010BE  60BA                      94              BRA     readNext
000010C0                            95              
000010C0                            96  loHex       * value is within bounds, but greater than 0-9 & A-F
000010C0  0C02 0061                 97              CMPI.B  #$61,D2     * cmp value to '`', 1 place below 'a'
000010C4  6D00 0042                 98              BLT     charError       * branch to error if this occurred 
000010C8                            99              * value is valid and is between a-f
000010C8  0402 0057                100              SUBI.B  #$57,D2
000010CC  E98C                     101              LSL.L   #4,D4
000010CE  D802                     102              ADD.B   D2,D4
000010D0  60A8                     103              BRA     readNext
000010D2                           104  
000010D2  4E75                     105  readDone    RTS
000010D4                           106  
000010D4  43F9 00001264            107  noInput     LEA     no_Input,A1     * load error message
000010DA  700E                     108              MOVE.L  #14,D0
000010DC  4E4F                     109              TRAP    #15
000010DE  1C38 0014                110              MOVE.B  start_flag,D6   * load start flag to D6
000010E2  BC3C 0000                111              CMP.B   #$0,D6          * check if the start addr has been entered correctly
000010E6  6D00 FF36                112              BLT     GET_LOWER       * get lower addr if not
000010EA  6000 FF54                113              BRA     GET_UPPER       * get upper
000010EE                           114              
000010EE  43F9 000012D1            115  boundsErr   LEA     addrBoundErr,A1 * load error message
000010F4  700E                     116              MOVE.L  #14,D0
000010F6  4E4F                     117              TRAP    #15
000010F8  1C38 0014                118              MOVE.B  start_flag,D6
000010FC  BC3C 0000                119              CMP.B   #$0,D6
00001100  6D00 FF1C                120              BLT     GET_LOWER
00001104  6000 FF3A                121              BRA     GET_UPPER
00001108                           122              
00001108  43F9 0000128F            123  charError   LEA     badChar,A1      * load error message
0000110E  700E                     124              MOVE.L  #14,D0
00001110  4E4F                     125              TRAP    #15
00001112  1C38 0014                126              MOVE.B  start_flag,D6
00001116  BC3C 0000                127              CMP.B   #$0,D6
0000111A                           128  
0000111A  6D00 FF02                129              BLT     GET_LOWER
0000111E  6000 FF20                130              BRA     GET_UPPER 
00001122                           131              
00001122                           132  * CHECK_BOUNDS
00001122                           133  
00001122  4246                     134  CHK_BOUNDS  CLR     D6              * clear D6
00001124  3C04                     135              MOVE.W  D4,D6           * move user input address to D6
00001126  0206 0001                136              ANDI.B  #$1,D6          * bit check if it is odd
0000112A  0C06 0001                137              CMPI.B  #$1,D6
0000112E  6700 004A                138              BEQ     OddError        * odd, break and print error message
00001132  1C38 0014                139              MOVE.B  start_flag,D6   * move byte start flag to D6
00001136  0C06 0000                140              CMPI.B  #$0,D6          * if starting address, check lower bounds
0000113A  6700 0006                141              BEQ     lowerBound
0000113E  6000 001E                142              BRA     upperBound      * else check upper bounds
00001142                           143  
00001142  0C84 00000000            144  lowerBound  CMPI.L  #minStart,D4    * is the lower bound less than the start address bound?
00001148  6D00 004A                145              BLT     lowError
0000114C  0C84 00FFFFE0            146              CMPI.L  #maxEnd,D4      * is the lower bound greater than the end address bound?
00001152  6E00 006A                147              BGT     hiError
00001156  11FC 0001 0014           148              MOVE.B  #$1,start_flag  * move 1 to starting flag, indicating the starting 
0000115C                           149                                      * address has been successfully entered
0000115C  4E75                     150              RTS 
0000115E                           151  
0000115E                           152  
0000115E  0C84 00000000            153  upperBound  CMPI.L  #minStart,D4    * end address is smaller than starting bounds
00001164  6D00 002E                154              BLT     lowError
00001168  0C84 00FFFFE0            155              CMPI.L  #maxEnd,D4      * ending address goes beyond bounds
0000116E  6E00 004E                156              BGT     hiError
00001172  B88C                     157              CMP.L   A4,D4           * compare start address to end address
00001174  6D00 0062                158              BLT     endError        * branch to error if they are the same or end is lower
00001178  4E75                     159              RTS 
0000117A                           160  
0000117A                           161              
0000117A  43F9 00001320            162  OddError    LEA     oddErr,A1   * load error message
00001180  700E                     163              MOVE.L  #14,D0
00001182  4E4F                     164              TRAP    #15
00001184  1C38 0014                165              MOVE.B  start_flag,D6   * check if the starting address is valid
00001188  BC3C 0000                166              CMP.B   #$0,D6          * if flag has not been set to 1, return to starting address
0000118C  6700 FE90                167              BEQ     GET_LOWER       
00001190  6000 FEAE                168              BRA     GET_UPPER 
00001194                           169              
00001194  E384                     170  lowError    ASL.L   #1,D4    * this covers the case of FFFFFFFE without this, 
00001196                           171              * it will interpret FFFFFFFE as smaller than 00000000 and print low error
00001196  6500 0026                172              BCS     hiError
0000119A  0C84 01000000            173              CMPI.L  #$1000000,D4 * covers the case of D4>00ffffe0
000011A0  6C00 001C                174              BGE     hiError         
000011A4  43F9 000013AC            175              LEA     loErr,A1    * load error message
000011AA  700E                     176              MOVE.L  #14,D0
000011AC  4E4F                     177              TRAP    #15
000011AE  1C38 0014                178              MOVE.B  start_flag,D6   * check if the starting address is valid
000011B2  BC3C 0000                179              CMP.B   #$0,D6
000011B6  6700 FE66                180              BEQ     GET_LOWER       
000011BA  6000 FE84                181              BRA     GET_UPPER 
000011BE                           182      
000011BE  43F9 000013F2            183  hiError     LEA     hiErr,A1        * load high error message
000011C4  700E                     184              MOVE.L  #14,D0
000011C6  4E4F                     185              TRAP    #15
000011C8  1C38 0014                186              MOVE.B  start_flag,D6   * check if the starting address is valid
000011CC  BC3C 0000                187              CMP.B   #$0,D6
000011D0  6700 FE4C                188              BEQ     GET_LOWER       
000011D4  6000 FE6A                189              BRA     GET_UPPER 
000011D8                           190  
000011D8  43F9 00001361            191  endError    LEA     endErr,A1       * load starting larger than ending address error
000011DE  700E                     192              MOVE.L  #14,D0
000011E0  4E4F                     193              TRAP    #15
000011E2  6000 FE5C                194              BRA     GET_UPPER       * branch back to getting ending address
000011E6                           195              
000011E6= 45 6E 74 65 72 20 ...    196  startAddr   DC.B    'Enter a starting address from $00000000 to $00FFFFE0: ',CR,LF,0
0000121F= 45 6E 74 65 72 20 ...    197  endAddr     DC.B    'Enter an ending address greater or equal to the starting address: ',CR,LF,0
00001264= 0D 0A 4E 6F 20 69 ...    198  no_Input    DC.B    CR,LF,'No input, please enter a valid address',CR,LF,0
0000128F= 0D 0A 42 61 64 20 ...    199  badChar     DC.B    CR,LF,'Bad character entered in address, please re-enter the address',CR,LF,0
000012D1= 0D 0A 54 68 65 20 ...    200  addrBoundErr DC.B CR,LF,'The address entered contained too many characters, please re-enter address',CR,LF,0
00001320= 0D 0A 54 68 65 20 ...    201  oddErr      DC.B    CR,LF,'The address entered was odd, please re-enter a valid address',CR,LF,0 
00001361= 0D 0A 45 6E 64 69 ...    202  endErr      DC.B    CR,LF,'Ending address is lower than starting address, please re-enter address',CR,LF,0
000013AC= 0D 0A 41 64 64 72 ...    203  loErr       DC.B    CR,LF,'Address is smaller than specified bounds, please re-enter address',CR,LF,0
000013F2= 0D 0A 41 64 64 72 ...    204  hiErr       DC.B    CR,LF,'Address is larger than the specified bounds, please re-enter address',CR,LF,0
0000143B= 50 72 65 73 73 20 ...    205  halt        DC.B    'Press Enter to continue',0 
00001453= 57 6F 75 6C 64 20 ...    206  repeat     DC.B    'Would you like to load another program? (Y/N): ',0
00001483= 0D 0A 54 68 61 6E ...    207  ending      DC.B    CR,LF,'Thank you for using this disassembler',0
000014AB                           208  
000014AC  45F8 0083                209  MAIN        LEA     printCode,A2
000014B0                           210              
000014B0                           211  MAINLOOP    * IF start >= end, disassemble done
000014B0  B9CD                     212              CMPA.L   A5,A4
000014B2  6E00 36BC                213              BGT     DONE
000014B6                           214              * if screen full, halt display and continue
000014B6  1038 0065                215              MOVE.B  lines_flag,D0
000014BA  0C40 001E                216              CMPI.W  #30,D0      * 30 lines reached?
000014BE  6700 002A                217              BEQ     haltDisplay * halt display
000014C2                           218              * reset EA_FLAG
000014C2  11FC 0000 0015           219  _Cont       MOVE.B  #$0,EA_FLAG
000014C8  4285                     220              CLR.L   D5
000014CA  4207                     221              CLR.B   D7
000014CC  4EB9 000014FC            222              JSR GetPC    * get PC
000014D2                           223  
000014D2  4EB9 00001654            224              JSR GetInstr * get instruction
000014D8                           225   
000014D8  4EB9 00001646            226              JSR printLine * print the line
000014DE                           227              
000014DE  1038 0065                228              MOVE.B  lines_flag,D0   * increment the number of lines
000014E2  5240                     229              ADDQ    #1,D0
000014E4  11C0 0065                230              MOVE.B  D0,lines_flag
000014E8  60C6                     231              BRA     MAINLOOP  * branch back to beginning of loop
000014EA                           232              
000014EA                           233  haltDisplay
000014EA  43F8 143B                234              LEA     halt,A1
000014EE  700E                     235              MOVE.L  #14,D0
000014F0  4E4F                     236              TRAP    #15
000014F2  43F8 0000                237              LEA     start_input,A1
000014F6  7002                     238              MOVE.L  #2,D0
000014F8  4E4F                     239              TRAP    #15
000014FA                           240              
000014FA  60C6                     241              BRA _Cont
000014FC                           242              
000014FC                           243  ******************************************************************
000014FC                           244  * GetPC
000014FC                           245  ******************************************************************            
000014FC  45F8 0083                246  GetPC       LEA     printCode,A2
00001500  4DF9 00004A6E            247              LEA     numTable,A6
00001506  4286                     248              CLR.L   D6
00001508  4282                     249              CLR.L   D2
0000150A  260C                     250              MOVE.L  A4,D3      * move address into data r3
0000150C                           251              * given since no address can be bigger than 00ffffe0
0000150C  14FC 0030                252              MOVE.B  #'0',(A2)+ * add two zeros to the string
00001510  14FC 0030                253              MOVE.B  #'0',(A2)+
00001514  E98B                     254              LSL.L   #4,D3      * shift leading zeros out
00001516                           255              
00001516  E98B                     256  GetPClp     LSL.L   #4,D3   * shift 4 bits out   
00001518  0C02 0006                257              CMPI.B  #6,D2   * if the loop has gone thru 6 times,
0000151C  6700 0014                258              BEQ     GetPCDn * finish 
00001520  4EB9 00001534            259              JSR     BITTEST * get leading 4 bits hex representation
00001526  CCFC 0008                260              MULU.W  #8,D6   * mult by 8 for jump offset
0000152A  4EB6 6000                261              JSR     (A6,D6) * jump to the table to add to string
0000152E  5242                     262              ADDQ    #1,D2   * increment loop counter
00001530  60E4                     263              BRA     GetPClp
00001532  4E75                     264  GetPCDn     RTS
00001534                           265  
00001534                           266  **************************************************************
00001534                           267  * BITTEST-
00001534                           268  * Bit Test check for the leading 4 bits in D3. If a bit is 
00001534                           269  * marked, it is added to the resultant number held in D6.
00001534                           270  **************************************************************   
00001534  4286                     271  BITTEST     CLR.L   D6
00001536  0803 001F                272              BTST.L  #$1F,D3
0000153A  6614                     273              BNE.S   add1000
0000153C  0803 001E                274  eTst        BTST.L  #$1E,D3
00001540  6612                     275              BNE.S   add0100
00001542  0803 001D                276  dTst        BTST.L  #$1D,D3
00001546  6610                     277              BNE.S   add0010
00001548  0803 001C                278  cTst        BTST.L  #$1C,D3
0000154C  660E                     279              BNE.S   add0001
0000154E  4E75                     280              RTS
00001550                           281                   
00001550  5006                     282  add1000     ADDI.B  #%1000,D6
00001552  60E8                     283              BRA     eTst
00001554                           284              
00001554  5806                     285  add0100     ADDI.B  #%0100,D6
00001556  60EA                     286              BRA     dTst
00001558                           287  
00001558  5406                     288  add0010     ADDI.B  #%0010,D6
0000155A  60EC                     289              BRA     cTst
0000155C                           290  
0000155C  5206                     291  add0001     ADDI.B  #%0001,D6
0000155E  4E75                     292              RTS  
00001560                           293  
00001560                           294  **************************************************************
00001560                           295  * BitTst3- a variation of BITTEST -> used primarily for EA
00001560                           296  * Bit Test check for the leading 3 bits in D3. If a bit is 
00001560                           297  * marked, it is added to the resultant number held in D6.
00001560                           298  **************************************************************             
00001560                           299              
00001560  4286                     300  BitTst3     CLR.L   D6
00001562  0803 001F                301              BTST.L  #$1F,D3
00001566  660E                     302              BNE.S   add100
00001568  0803 001E                303  Bit1        BTST.L  #$1E,D3
0000156C  660C                     304              BNE.S   add010
0000156E  0803 001D                305  Bit0        BTST.L  #$1D,D3
00001572  660A                     306              BNE.S   add001
00001574  4E75                     307              RTS
00001576                           308                   
00001576  5806                     309  add100      ADDI.B  #%100,D6
00001578  60EE                     310              BRA     Bit1
0000157A                           311              
0000157A  5406                     312  add010      ADDI.B  #%010,D6
0000157C  60F0                     313              BRA     Bit0
0000157E                           314  
0000157E  5206                     315  add001      ADDI.B  #%001,D6
00001580  4E75                     316              RTS
00001582                           317  
00001582                           318  **************************************************************
00001582                           319  * BitTst2- a variation of BITTEST 
00001582                           320  * Bit Test check for the leading 2 bits in D3. If a bit is 
00001582                           321  * marked, it is added to the resultant number held in D6.
00001582                           322  ************************************************************** 
00001582                           323              
00001582  4286                     324  BitTst2     CLR.L   D6
00001584  0803 001F                325              BTST.L  #$1F,D3
00001588  6608                     326              BNE.S   add10
0000158A  0803 001E                327  Bt1         BTST.L  #$1E,D3
0000158E  6606                     328              BNE.S   add01
00001590  4E75                     329              RTS
00001592                           330              
00001592  5406                     331  add10       ADDI.B  #%10,D6
00001594  60F4                     332              BRA Bt1
00001596                           333              
00001596  5206                     334  add01       ADDI.B  #%01,D6
00001598  4E75                     335              RTS
0000159A                           336              
0000159A                           337  *******************************************************************************
0000159A                           338  * getSize - 
0000159A                           339  * Subroutine used to get the size bits of a given instruction
0000159A                           340  *******************************************************************************
0000159A                           341  getSize   
0000159A  2604                     342              MOVE.L  D4,D3       * reset D3
0000159C  4843                     343              SWAP    D3          * push D3 to front
0000159E  E18B                     344              LSL.L   #8,D3       * move front 8 bits out
000015A0  4EB8 1582                345              JSR     BitTst2     * test two size bits, hold result in d6
000015A4  2604                     346              MOVE.L  D4,D3       * Reset d3
000015A6  4843                     347              SWAP    D3          * push d3 to front
000015A8  4E75                     348              RTS                 * return
000015AA                           349              
000015AA                           350  **********************************************************************
000015AA                           351  * PrintByte, PrintWord, PrintLong -  
000015AA                           352  * print functions for immediate/absolute numbers categorized by size
000015AA                           353  **********************************************************************            
000015AA                           354  printByte   
000015AA  4242                     355              CLR     D2          * clear d2 for counter
000015AC  4DF9 00004A6E            356              LEA     numTable,A6 
000015B2  2A0C                     357              MOVE.L  A4,D5       * save current address in case of error
000015B4  361C                     358              MOVE.W  (A4)+,D3    * get the immediate word data
000015B6  4843                     359              SWAP    D3          * swap to front
000015B8  E18B                     360              LSL.L   #8,D3       * shift out leading 8 bits, dealing with 1 byte
000015BA  11FC 0001 0015           361              MOVE.B  #1,EA_FLAG  * set ea flag
000015C0                           362              
000015C0                           363  printBLoop  
000015C0  0C02 0002                364              CMPI.B  #2,D2       * loop through twice,
000015C4  6700 0070                365              BEQ     printDn     * print done
000015C8  4EB8 1534                366              JSR     BITTEST     * get leading 4 bits
000015CC  CCFC 0008                367              MULU    #8,D6       * multiply by 8 for jump offset 
000015D0  4EB6 6000                368              JSR     (A6,D6)     * get number from table and add to A2 string
000015D4  E98B                     369              LSL.L   #4,D3       * shift out the 4 bits were done with
000015D6  5242                     370              ADDQ    #1,D2       * increment loop counter
000015D8  60E6                     371              BRA     printBLoop
000015DA                           372              
000015DA                           373  
000015DA                           374  printWord
000015DA  4242                     375              CLR     D2      * clear d2 for counter
000015DC  4DF9 00004A6E            376              LEA     numTable,A6
000015E2  2A0C                     377              MOVE.L  A4,D5       * save current address in case of error
000015E4  361C                     378              MOVE.W  (A4)+,D3    * get the immediate word data
000015E6  4843                     379              SWAP    D3          * swap to front
000015E8  11FC 0001 0015           380              MOVE.B  #1,EA_FLAG  * set ea flag
000015EE                           381              
000015EE                           382  printWLoop  
000015EE  0C02 0004                383              CMPI.B  #4,D2       * loop through 4 times,
000015F2  6700 0042                384              BEQ     printDn     * print done
000015F6  4EB8 1534                385              JSR     BITTEST     * get leading 4 bits
000015FA  CCFC 0008                386              MULU    #8,D6       * multiply by 8 for jump offset
000015FE  4EB6 6000                387              JSR     (A6,D6)     * get number from table and add to A2 string
00001602  E98B                     388              LSL.L   #4,D3       * shift out 4 biths were done with
00001604  5242                     389              ADDQ    #1,D2       * increment loop counter
00001606  60E6                     390              BRA     printWLoop  * branch back to loop
00001608                           391  
00001608                           392  printLong
00001608  4242                     393              CLR     D2      * clear d2 for counter
0000160A  4DF9 00004A6E            394              LEA     numTable,A6
00001610  2A0C                     395              MOVE.L  A4,D5       * save current address in case of error
00001612  5485                     396              ADDI.L  #$2,D5      * increment D5 to the next instruction
00001614  261C                     397              MOVE.L  (A4)+,D3    * get the immediate long data into D3
00001616                           398              * no swapping necessary, already longword
00001616  11FC 0001 0015           399              MOVE.B  #1,EA_FLAG  * set ea flag
0000161C                           400              
0000161C                           401  printLLoop
0000161C  0C02 0008                402              CMPI.B  #8,D2       * loop through 8 times,
00001620  6700 0014                403              BEQ     printDn     * finish
00001624  4EB8 1534                404              JSR     BITTEST     * get leading 4 bits
00001628  CCFC 0008                405              MULU    #8,D6       * multiply number by 8 for jump offset
0000162C  4EB6 6000                406              JSR     (A6,D6)     * get number from table and add to A2 string
00001630  E98B                     407              LSL.L   #4,D3       * shift out 4 bits already used
00001632  5242                     408              ADDQ    #1,D2       * increment loop counter
00001634  60E6                     409              BRA     printLLoop  * branch back to loop beginning
00001636                           410  
00001636  4E75                     411  printDn     RTS
00001638                           412  
00001638                           413  *************************************************************
00001638                           414  * getMode
00001638                           415  *************************************************************
00001638  2604                     416  getMode     MOVE.L  D4,D3       * reset D3
0000163A  4843                     417              SWAP    D3
0000163C  E18B                     418              LSL.L   #8,D3       * shift out leading 10 bits to check 3-5
0000163E  E58B                     419              LSL.L   #2,D3
00001640  4EB8 1560                420              JSR     BitTst3     * test 3 bits, hold result in D6
00001644  4E75                     421              RTS                 * return
00001646                           422              
00001646                           423  **************************************************************
00001646                           424  * printLine
00001646                           425  **************************************************************
00001646                           426  printLine       
00001646  14BC 0000                427                  MOVE.B  #$00,(A2)   * add null terminator to string
0000164A  43F8 0083                428                  LEA     printCode,A1
0000164E  700D                     429                  MOVEQ   #13,D0
00001650  4E4F                     430                  TRAP    #15
00001652                           431                  
00001652  4E75                     432                  RTS
00001654                           433              
00001654                           434  
00001654                           435  **********************************************
00001654                           436  * Get Instruction         
00001654                           437  **********************************************
00001654                           438  
00001654                           439  GetInstr    * print spaces before instruction
00001654  14FC 0020                440              MOVE.B  #' ',(A2)+
00001658  14FC 0020                441              MOVE.B  #' ',(A2)+
0000165C  14FC 0020                442              MOVE.B  #' ',(A2)+
00001660  14FC 0020                443              MOVE.B  #' ',(A2)+
00001664  264A                     444              MOVEA.L     A2,A3   * save current string location
00001666                           445              * clr current D3 contents
00001666  4283                     446              CLR.L   D3
00001668  361C                     447              MOVE.W (A4)+,D3 * move instruction word into d3
0000166A  2803                     448              MOVE.L  D3,D4   * save D3
0000166C  4843                     449              SWAP    D3      * swap d3 to upper 16 bits for BITTEST
0000166E                           450              * bit test check for the op code
0000166E  4EB8 1534                451              JSR     BITTEST
00001672  4843                     452              SWAP    D3      * swap d3 back for comparisons in op codes
00001674                           453              * begin comparisons with different op codes
00001674  0C06 0000                454              CMPI.B  #%0000,D6   * ADDI,ANDI,CMPI,ORI
00001678  6700 006E                455              BEQ     op0000
0000167C  0C06 0001                456              CMPI.B  #%0001,D6   * MOVE.B
00001680  6700 06AA                457              BEQ     op0001
00001684  0C06 0002                458              CMPI.B  #%0010,D6   * MOVE.L/MOVEA.L
00001688  6700 0726                459              BEQ     op0010
0000168C  0C06 0003                460              CMPI.B  #%0011,D6   * MOVE.W/MOVEA.W
00001690  6700 0800                461              BEQ     op0011
00001694  0C06 0004                462              CMPI.B  #%0100,D6   * MOVEM/LEA/CLR/JSR/RTS/NOP
00001698  6700 09B4                463              BEQ     op0100
0000169C  0C06 0005                464              CMPI.B  #%0101,D6   * ADDQ/SUBQ
000016A0  6700 11D2                465              BEQ     op0101
000016A4  0C06 0006                466              CMPI.B  #%0110,D6   * Bcc (BRA,BCC,BLT,BGE)
000016A8  6700 1566                467              BEQ     op0110
000016AC  0C06 0007                468              CMPI.B  #%0111,D6   * MOVEQ
000016B0  6700 17FE                469              BEQ     op0111
000016B4  0C06 0008                470              CMPI.B  #%1000,D6   * DIVU/DIVS/OR
000016B8  6700 184C                471              BEQ     op1000
000016BC  0C06 0009                472              CMPI.B  #%1001,D6   * SUB
000016C0  6700 1CA0                473              BEQ     op1001
000016C4  0C06 000B                474              CMPI.B  #%1011,D6   * CMP
000016C8  6700 2018                475              BEQ     op1011
000016CC  0C06 000C                476              CMPI.B  #%1100,D6   * MULS/MULU/AND
000016D0  6700 21DC                477              BEQ     op1100
000016D4  0C06 000D                478              CMPI.B  #%1101,D6   * ADD/ADDA
000016D8  6700 25E0                479              BEQ     op1101
000016DC  0C06 000E                480              CMPI.B  #%1110,D6   * LSL/LSR/ASL/ASR/ROL/ROR
000016E0  6700 2A44                481              BEQ     op1110
000016E4                           482              * if no op code found, print op error/not supported
000016E4                           483              
000016E4  6000 3178                484              BRA     OPERROR
000016E8                           485  
000016E8                           486  * ADDI, ANDI, CMPI, ORI, SUBI ------------------------------------
000016E8                           487  op0000
000016E8  4843                     488              SWAP    D3
000016EA  E98B                     489              LSL.L   #4,D3   * shift out opcode
000016EC  4EB8 1534                490              JSR     BITTEST * test next four bits
000016F0  0C06 0000                491              CMPI.B  #%0000,D6
000016F4  6700 0026                492              BEQ     _OrI    * go to ORI
000016F8  0C06 0002                493              CMPI.B  #%0010,D6
000016FC  6700 0156                494              BEQ     _AndI   * go to ANDI
00001700  0C06 0004                495              CMPI.B  #%0100,D6
00001704  6700 027E                496              BEQ     _SubI   * go to SUBI
00001708  0C06 0006                497              CMPI.B  #%0110,D6
0000170C  6700 03AE                498              BEQ     _AddI   * go to ADDI
00001710  0C06 000C                499              CMPI.B  #%1100,D6
00001714  6700 04DE                500              BEQ     _CmpI   * go to CMPI
00001718                           501              
00001718                           502              * if none of these, unsupported/error
00001718  6000 3144                503              BRA     OPERROR
0000171C                           504              
0000171C                           505  * ORI --------------------------------------------------------------------------------
0000171C                           506  
0000171C  E98B                     507  _OrI        LSL.L   #4,D3   * shift next 4 bits to check for size
0000171E  4EB8 1582                508              JSR     BitTst2 * check the size bits
00001722  EB8B                     509              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
00001724  0C06 0000                510              CMPI.B  #%00,D6 * branch to appropriate size label
00001728  6700 0016                511              BEQ     _OrIb   * ORI.B
0000172C  0C06 0001                512              CMPI.B  #%01,D6
00001730  6700 006A                513              BEQ     _OrIw   * ORI.W
00001734  0C06 0002                514              CMPI.B  #%10,D6
00001738  6700 00BE                515              BEQ     _OrIl   * ORI.L
0000173C                           516              * something unexpected
0000173C  6000 3120                517              BRA     OPERROR
00001740                           518  * ORI.B ---------------------            
00001740                           519  _OrIb
00001740                           520              
00001740  14FC 004F                521              MOVE.B  #'O',(A2)+
00001744  14FC 0052                522              MOVE.B  #'R',(A2)+
00001748  14FC 0049                523              MOVE.B  #'I',(A2)+
0000174C  14FC 002E                524              MOVE.B  #'.',(A2)+ 
00001750  14FC 0042                525              MOVE.B  #'B',(A2)+ 
00001754  14FC 0020                526              MOVE.B  #' ',(A2)+ 
00001758  14FC 0020                527              MOVE.B  #' ',(A2)+ 
0000175C  14FC 0020                528              MOVE.B  #' ',(A2)+ 
00001760  14FC 0020                529              MOVE.B  #' ',(A2)+ 
00001764  14FC 0020                530              MOVE.B  #' ',(A2)+
00001768  14FC 0023                531              MOVE.B  #'#',(A2)+
0000176C  14FC 0024                532              MOVE.B  #'$',(A2)+
00001770  4EB8 15AA                533              JSR     printByte
00001774  14FC 002C                534              MOVE.B  #',',(A2)+
00001778                           535              
00001778  4EB8 1638                536              JSR     getMode
0000177C  BC3C 0001                537              CMP.B   #%001,D6    * compare with Ar
00001780  6700 30DC                538              BEQ     OPERROR     * error
00001784                           539              
00001784  4DF9 000048CE            540              LEA     eaTable,A6
0000178A  CCFC 0008                541              MULU    #8,D6
0000178E  4EB6 6000                542              JSR     (A6,D6)
00001792                           543              * check for error in EA
00001792  0C07 0004                544              CMPI.B  #4,D7
00001796  6700 30C6                545              BEQ     OPERROR
0000179A                           546              
0000179A                           547              
0000179A  4E75                     548              RTS            
0000179C                           549  * ORI.W ----------------------
0000179C                           550  _OrIw       
0000179C                           551             
0000179C  14FC 004F                552              MOVE.B  #'O',(A2)+
000017A0  14FC 0052                553              MOVE.B  #'R',(A2)+
000017A4  14FC 0049                554              MOVE.B  #'I',(A2)+
000017A8  14FC 002E                555              MOVE.B  #'.',(A2)+ 
000017AC  14FC 0057                556              MOVE.B  #'W',(A2)+ 
000017B0  14FC 0020                557              MOVE.B  #' ',(A2)+ 
000017B4  14FC 0020                558              MOVE.B  #' ',(A2)+ 
000017B8  14FC 0020                559              MOVE.B  #' ',(A2)+ 
000017BC  14FC 0020                560              MOVE.B  #' ',(A2)+ 
000017C0  14FC 0020                561              MOVE.B  #' ',(A2)+
000017C4  14FC 0023                562              MOVE.B  #'#',(A2)+
000017C8  14FC 0024                563              MOVE.B  #'$',(A2)+
000017CC  4EB8 15DA                564              JSR     printWord
000017D0  14FC 002C                565              MOVE.B  #',',(A2)+
000017D4                           566              
000017D4  4EB8 1638                567              JSR     getMode
000017D8  BC3C 0001                568              CMP.B   #%001,D6    * compare with Ar
000017DC  6700 3080                569              BEQ     OPERROR     * error
000017E0  4DF9 000048CE            570              LEA     eaTable,A6   * load ea table
000017E6  CCFC 0008                571              MULU    #8,D6       * multiply for offset
000017EA  4EB6 6000                572              JSR     (A6,D6)     * jump to offset
000017EE                           573              * check for error in EA
000017EE  0C07 0004                574              CMPI.B  #4,D7
000017F2  6700 306A                575              BEQ     OPERROR
000017F6                           576               
000017F6  4E75                     577              RTS  
000017F8                           578  * ORI.L ----------------------
000017F8                           579  _OrIl       
000017F8  14FC 004F                580              MOVE.B  #'O',(A2)+
000017FC  14FC 0052                581              MOVE.B  #'R',(A2)+
00001800  14FC 0049                582              MOVE.B  #'I',(A2)+
00001804  14FC 002E                583              MOVE.B  #'.',(A2)+ 
00001808  14FC 004C                584              MOVE.B  #'L',(A2)+ 
0000180C  14FC 0020                585              MOVE.B  #' ',(A2)+ 
00001810  14FC 0020                586              MOVE.B  #' ',(A2)+ 
00001814  14FC 0020                587              MOVE.B  #' ',(A2)+ 
00001818  14FC 0020                588              MOVE.B  #' ',(A2)+ 
0000181C  14FC 0020                589              MOVE.B  #' ',(A2)+
00001820  14FC 0023                590              MOVE.B  #'#',(A2)+
00001824  14FC 0024                591              MOVE.B  #'$',(A2)+
00001828  4EB8 1608                592              JSR     printLong
0000182C  14FC 002C                593              MOVE.B  #',',(A2)+
00001830                           594              
00001830  4EB8 1638                595              JSR     getMode
00001834  BC3C 0001                596              CMP.B   #%001,D6    * compare with Ar
00001838  6700 3024                597              BEQ     OPERROR     * error
0000183C  4DF9 000048CE            598              LEA     eaTable,A6   
00001842  CCFC 0008                599              MULU    #8,D6
00001846  4EB6 6000                600              JSR     (A6,D6)
0000184A                           601              * check for error in EA
0000184A  0C07 0004                602              CMPI.B  #4,D7
0000184E  6700 300E                603              BEQ     OPERROR
00001852                           604              
00001852  4E75                     605              RTS  
00001854                           606              
00001854                           607  * ANDI ------------------------------------------------------------------------------
00001854  E98B                     608  _AndI       LSL.L   #4,D3
00001856  4EB8 1582                609              JSR     BitTst2
0000185A  EB8B                     610              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
0000185C  0C06 0000                611              CMPI.B  #%00,D6 * branch to appropriate size label
00001860  6700 0016                612              BEQ     _AndIb   * ANDI.B
00001864  0C06 0001                613              CMPI.B  #%01,D6
00001868  6700 0062                614              BEQ     _AndIw  * ANDI.W
0000186C  0C06 0002                615              CMPI.B  #%10,D6
00001870  6700 00B6                616              BEQ     _AndIl   * ANDI.L
00001874                           617              * something unexpected
00001874  6000 2FE8                618              BRA     OPERROR
00001878                           619              
00001878                           620  * ANDI.B ---------------------
00001878                           621  _AndIb      
00001878  14FC 0041                622              MOVE.B  #'A',(A2)+
0000187C  14FC 004E                623              MOVE.B  #'N',(A2)+
00001880  14FC 0044                624              MOVE.B  #'D',(A2)+
00001884  14FC 0049                625              MOVE.B  #'I',(A2)+ 
00001888  14FC 002E                626              MOVE.B  #'.',(A2)+ 
0000188C  14FC 0042                627              MOVE.B  #'B',(A2)+ 
00001890  14FC 0020                628              MOVE.B  #' ',(A2)+ 
00001894  14FC 0020                629              MOVE.B  #' ',(A2)+ 
00001898  14FC 0020                630              MOVE.B  #' ',(A2)+ 
0000189C  14FC 0020                631              MOVE.B  #' ',(A2)+
000018A0  14FC 0023                632              MOVE.B  #'#',(A2)+
000018A4  14FC 0024                633              MOVE.B  #'$',(A2)+
000018A8  4EB8 15AA                634              JSR     printByte
000018AC  14FC 002C                635              MOVE.B  #',',(A2)+
000018B0  4EB8 1638                636              JSR     getMode
000018B4  BC3C 0001                637              CMP.B   #%001,D6    * compare with Ar
000018B8  6700 2FA4                638              BEQ     OPERROR     * error
000018BC                           639              
000018BC  4DF9 000048CE            640              LEA     eaTable,A6
000018C2  CCFC 0008                641              MULU    #8,D6
000018C6  4EB6 6000                642              JSR     (A6,D6)
000018CA                           643              
000018CA  4E75                     644              RTS 
000018CC                           645  
000018CC                           646  * ANDI.W ---------------------
000018CC                           647  _AndIw      
000018CC  14FC 0041                648              MOVE.B  #'A',(A2)+
000018D0  14FC 004E                649              MOVE.B  #'N',(A2)+
000018D4  14FC 0044                650              MOVE.B  #'D',(A2)+
000018D8  14FC 0049                651              MOVE.B  #'I',(A2)+ 
000018DC  14FC 002E                652              MOVE.B  #'.',(A2)+ 
000018E0  14FC 0057                653              MOVE.B  #'W',(A2)+ 
000018E4  14FC 0020                654              MOVE.B  #' ',(A2)+ 
000018E8  14FC 0020                655              MOVE.B  #' ',(A2)+ 
000018EC  14FC 0020                656              MOVE.B  #' ',(A2)+ 
000018F0  14FC 0020                657              MOVE.B  #' ',(A2)+
000018F4  14FC 0023                658              MOVE.B  #'#',(A2)+
000018F8  14FC 0024                659              MOVE.B  #'$',(A2)+
000018FC  4EB8 15DA                660              JSR     printWord
00001900  14FC 002C                661              MOVE.B  #',',(A2)+
00001904  4EB8 1638                662              JSR     getMode
00001908  BC3C 0001                663              CMP.B   #%001,D6    * compare with Ar
0000190C  6700 2F50                664              BEQ     OPERROR     * error
00001910                           665              
00001910  4DF9 000048CE            666              LEA     eaTable,A6
00001916  CCFC 0008                667              MULU    #8,D6
0000191A  4EB6 6000                668              JSR     (A6,D6)
0000191E                           669              * check for error in EA
0000191E  0C07 0004                670              CMPI.B  #4,D7
00001922  6700 2F3A                671              BEQ     OPERROR
00001926                           672  
00001926  4E75                     673              RTS 
00001928                           674  * ANDI.L ---------------------
00001928                           675  _AndIl      
00001928  14FC 0041                676              MOVE.B  #'A',(A2)+
0000192C  14FC 004E                677              MOVE.B  #'N',(A2)+
00001930  14FC 0044                678              MOVE.B  #'D',(A2)+
00001934  14FC 0049                679              MOVE.B  #'I',(A2)+ 
00001938  14FC 002E                680              MOVE.B  #'.',(A2)+ 
0000193C  14FC 004C                681              MOVE.B  #'L',(A2)+ 
00001940  14FC 0020                682              MOVE.B  #' ',(A2)+ 
00001944  14FC 0020                683              MOVE.B  #' ',(A2)+ 
00001948  14FC 0020                684              MOVE.B  #' ',(A2)+ 
0000194C  14FC 0020                685              MOVE.B  #' ',(A2)+
00001950  14FC 0023                686              MOVE.B  #'#',(A2)+
00001954  14FC 0024                687              MOVE.B  #'$',(A2)+
00001958  4EB8 1608                688              JSR     printLong
0000195C  14FC 002C                689              MOVE.B  #',',(A2)+
00001960  4EB8 1638                690              JSR     getMode
00001964  BC3C 0001                691              CMP.B   #%001,D6    * compare with Ar
00001968  6700 2EF4                692              BEQ     OPERROR     * error
0000196C                           693              
0000196C  4DF9 000048CE            694              LEA     eaTable,A6
00001972  CCFC 0008                695              MULU    #8,D6
00001976  4EB6 6000                696              JSR     (A6,D6)
0000197A                           697              * check for error in EA
0000197A  0C07 0004                698              CMPI.B  #4,D7
0000197E  6700 2EDE                699              BEQ     OPERROR
00001982                           700  
00001982  4E75                     701              RTS 
00001984                           702  
00001984                           703  * SUBI ------------------------------------------------------------------------------
00001984  E98B                     704  _SubI       LSL.L   #4,D3
00001986  4EB8 1582                705              JSR     BitTst2
0000198A  EB8B                     706              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
0000198C  0C06 0000                707              CMPI.B  #%00,D6 * branch to appropriate size label
00001990  6700 0016                708              BEQ     _SubIb   * SUBI.B
00001994  0C06 0001                709              CMPI.B  #%01,D6
00001998  6700 006A                710              BEQ     _SubIw   * SUBI.W
0000199C  0C06 0002                711              CMPI.B  #%10,D6
000019A0  6700 00BE                712              BEQ     _SubIl   * SUBI.L
000019A4                           713              * something unexpected
000019A4  6000 2EB8                714              BRA     OPERROR
000019A8                           715  
000019A8                           716  * SUBI.B ---------------------            
000019A8                           717  _SubIb      
000019A8  14FC 0053                718              MOVE.B  #'S',(A2)+
000019AC  14FC 0055                719              MOVE.B  #'U',(A2)+
000019B0  14FC 0042                720              MOVE.B  #'B',(A2)+
000019B4  14FC 0049                721              MOVE.B  #'I',(A2)+ 
000019B8  14FC 002E                722              MOVE.B  #'.',(A2)+ 
000019BC  14FC 0042                723              MOVE.B  #'B',(A2)+ 
000019C0  14FC 0020                724              MOVE.B  #' ',(A2)+ 
000019C4  14FC 0020                725              MOVE.B  #' ',(A2)+ 
000019C8  14FC 0020                726              MOVE.B  #' ',(A2)+ 
000019CC  14FC 0020                727              MOVE.B  #' ',(A2)+
000019D0  14FC 0023                728              MOVE.B  #'#',(A2)+
000019D4  14FC 0024                729              MOVE.B  #'$',(A2)+
000019D8  4EB8 15AA                730              JSR     printByte
000019DC  14FC 002C                731              MOVE.B  #',',(A2)+
000019E0  4EB8 1638                732              JSR     getMode
000019E4  BC3C 0001                733              CMP.B   #%001,D6    * compare with Ar
000019E8  6700 2E74                734              BEQ     OPERROR     * error
000019EC                           735              
000019EC  4DF9 000048CE            736              LEA     eaTable,A6
000019F2  CCFC 0008                737              MULU    #8,D6
000019F6  4EB6 6000                738              JSR     (A6,D6)
000019FA                           739              * check for error in EA
000019FA  0C07 0004                740              CMPI.B  #4,D7
000019FE  6700 2E5E                741              BEQ     OPERROR
00001A02                           742  
00001A02  4E75                     743              RTS 
00001A04                           744  * SUBI.W ---------------------
00001A04                           745  _SubIw      
00001A04  14FC 0053                746              MOVE.B  #'S',(A2)+
00001A08  14FC 0055                747              MOVE.B  #'U',(A2)+
00001A0C  14FC 0042                748              MOVE.B  #'B',(A2)+
00001A10  14FC 0049                749              MOVE.B  #'I',(A2)+ 
00001A14  14FC 002E                750              MOVE.B  #'.',(A2)+ 
00001A18  14FC 0057                751              MOVE.B  #'W',(A2)+ 
00001A1C  14FC 0020                752              MOVE.B  #' ',(A2)+ 
00001A20  14FC 0020                753              MOVE.B  #' ',(A2)+ 
00001A24  14FC 0020                754              MOVE.B  #' ',(A2)+ 
00001A28  14FC 0020                755              MOVE.B  #' ',(A2)+
00001A2C  14FC 0023                756              MOVE.B  #'#',(A2)+
00001A30  14FC 0024                757              MOVE.B  #'$',(A2)+
00001A34  4EB8 15DA                758              JSR     printWord
00001A38  14FC 002C                759              MOVE.B  #',',(A2)+
00001A3C  4EB8 1638                760              JSR     getMode
00001A40  BC3C 0001                761              CMP.B   #%001,D6    * compare with Ar
00001A44  6700 2E18                762              BEQ     OPERROR     * error
00001A48                           763              
00001A48  4DF9 000048CE            764              LEA     eaTable,A6
00001A4E  CCFC 0008                765              MULU    #8,D6
00001A52  4EB6 6000                766              JSR     (A6,D6)
00001A56                           767              * check for error in EA
00001A56  0C07 0004                768              CMPI.B  #4,D7
00001A5A  6700 2E02                769              BEQ     OPERROR
00001A5E                           770  
00001A5E  4E75                     771              RTS 
00001A60                           772  
00001A60                           773  * SUBI.L ---------------------
00001A60                           774  _SubIl      
00001A60  14FC 0053                775              MOVE.B  #'S',(A2)+
00001A64  14FC 0055                776              MOVE.B  #'U',(A2)+
00001A68  14FC 0042                777              MOVE.B  #'B',(A2)+
00001A6C  14FC 0049                778              MOVE.B  #'I',(A2)+ 
00001A70  14FC 002E                779              MOVE.B  #'.',(A2)+ 
00001A74  14FC 004C                780              MOVE.B  #'L',(A2)+ 
00001A78  14FC 0020                781              MOVE.B  #' ',(A2)+ 
00001A7C  14FC 0020                782              MOVE.B  #' ',(A2)+ 
00001A80  14FC 0020                783              MOVE.B  #' ',(A2)+ 
00001A84  14FC 0020                784              MOVE.B  #' ',(A2)+
00001A88  14FC 0023                785              MOVE.B  #'#',(A2)+
00001A8C  14FC 0024                786              MOVE.B  #'$',(A2)+
00001A90  4EB8 1608                787              JSR     printLong
00001A94  14FC 002C                788              MOVE.B  #',',(A2)+
00001A98  4EB8 1638                789              JSR     getMode
00001A9C  BC3C 0001                790              CMP.B   #%001,D6    * compare with Ar
00001AA0  6700 2DBC                791              BEQ     OPERROR     * error
00001AA4                           792              
00001AA4  4DF9 000048CE            793              LEA     eaTable,A6
00001AAA  CCFC 0008                794              MULU    #8,D6
00001AAE  4EB6 6000                795              JSR     (A6,D6)
00001AB2                           796              * check for error in EA
00001AB2  0C07 0004                797              CMPI.B  #4,D7
00001AB6  6700 2DA6                798              BEQ     OPERROR
00001ABA                           799  
00001ABA  4E75                     800              RTS 
00001ABC                           801  
00001ABC                           802  * ADDI ------------------------------------------------------------------------------
00001ABC  E98B                     803  _AddI       LSL.L   #4,D3
00001ABE  4EB8 1582                804              JSR     BitTst2
00001AC2  EB8B                     805              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
00001AC4  0C06 0000                806              CMPI.B  #%00,D6 * branch to appropriate size label
00001AC8  6700 0016                807              BEQ     _AddIb   * ADDI.B
00001ACC  0C06 0001                808              CMPI.B  #%01,D6
00001AD0  6700 006A                809              BEQ     _AddIw   * ADDI.W
00001AD4  0C06 0002                810              CMPI.B  #%10,D6
00001AD8  6700 00BE                811              BEQ     _AddIl   * ADDI.L
00001ADC                           812              * something unexpected
00001ADC  6000 2D80                813              BRA     OPERROR
00001AE0                           814              
00001AE0                           815  * ADDI.B ---------------------            
00001AE0                           816  _AddIb      
00001AE0  14FC 0041                817              MOVE.B  #'A',(A2)+
00001AE4  14FC 0044                818              MOVE.B  #'D',(A2)+
00001AE8  14FC 0044                819              MOVE.B  #'D',(A2)+
00001AEC  14FC 0049                820              MOVE.B  #'I',(A2)+ 
00001AF0  14FC 002E                821              MOVE.B  #'.',(A2)+ 
00001AF4  14FC 0042                822              MOVE.B  #'B',(A2)+ 
00001AF8  14FC 0020                823              MOVE.B  #' ',(A2)+ 
00001AFC  14FC 0020                824              MOVE.B  #' ',(A2)+ 
00001B00  14FC 0020                825              MOVE.B  #' ',(A2)+ 
00001B04  14FC 0020                826              MOVE.B  #' ',(A2)+
00001B08  14FC 0023                827              MOVE.B  #'#',(A2)+
00001B0C  14FC 0024                828              MOVE.B  #'$',(A2)+
00001B10  4EB8 15AA                829              JSR     printByte
00001B14  14FC 002C                830              MOVE.B  #',',(A2)+
00001B18  4EB8 1638                831              JSR     getMode
00001B1C  BC3C 0001                832              CMP.B   #%001,D6    * compare with Ar
00001B20  6700 2D3C                833              BEQ     OPERROR     * error
00001B24                           834              
00001B24  4DF9 000048CE            835              LEA     eaTable,A6
00001B2A  CCFC 0008                836              MULU    #8,D6
00001B2E  4EB6 6000                837              JSR     (A6,D6)
00001B32                           838              * check for error in EA
00001B32  0C07 0004                839              CMPI.B  #4,D7
00001B36  6700 2D26                840              BEQ     OPERROR
00001B3A                           841  
00001B3A  4E75                     842              RTS 
00001B3C                           843  
00001B3C                           844  * ADDI.W ---------------------
00001B3C                           845  _AddIw      
00001B3C  14FC 0041                846              MOVE.B  #'A',(A2)+
00001B40  14FC 0044                847              MOVE.B  #'D',(A2)+
00001B44  14FC 0044                848              MOVE.B  #'D',(A2)+
00001B48  14FC 0049                849              MOVE.B  #'I',(A2)+ 
00001B4C  14FC 002E                850              MOVE.B  #'.',(A2)+ 
00001B50  14FC 0057                851              MOVE.B  #'W',(A2)+ 
00001B54  14FC 0020                852              MOVE.B  #' ',(A2)+ 
00001B58  14FC 0020                853              MOVE.B  #' ',(A2)+ 
00001B5C  14FC 0020                854              MOVE.B  #' ',(A2)+ 
00001B60  14FC 0020                855              MOVE.B  #' ',(A2)+
00001B64  14FC 0023                856              MOVE.B  #'#',(A2)+
00001B68  14FC 0024                857              MOVE.B  #'$',(A2)+
00001B6C  4EB8 15DA                858              JSR     printWord
00001B70  14FC 002C                859              MOVE.B  #',',(A2)+
00001B74  4EB8 1638                860              JSR     getMode
00001B78  BC3C 0001                861              CMP.B   #%001,D6    * compare with Ar
00001B7C  6700 2CE0                862              BEQ     OPERROR     * error
00001B80                           863              
00001B80  4DF9 000048CE            864              LEA     eaTable,A6
00001B86  CCFC 0008                865              MULU    #8,D6
00001B8A  4EB6 6000                866              JSR     (A6,D6)
00001B8E                           867              * check for error in EA
00001B8E  0C07 0004                868              CMPI.B  #4,D7
00001B92  6700 2CCA                869              BEQ     OPERROR
00001B96                           870  
00001B96  4E75                     871              RTS 
00001B98                           872  * ADDI.L ---------------------
00001B98                           873  _AddIl      
00001B98  14FC 0041                874              MOVE.B  #'A',(A2)+
00001B9C  14FC 0044                875              MOVE.B  #'D',(A2)+
00001BA0  14FC 0044                876              MOVE.B  #'D',(A2)+
00001BA4  14FC 0049                877              MOVE.B  #'I',(A2)+ 
00001BA8  14FC 002E                878              MOVE.B  #'.',(A2)+ 
00001BAC  14FC 004C                879              MOVE.B  #'L',(A2)+ 
00001BB0  14FC 0020                880              MOVE.B  #' ',(A2)+ 
00001BB4  14FC 0020                881              MOVE.B  #' ',(A2)+ 
00001BB8  14FC 0020                882              MOVE.B  #' ',(A2)+ 
00001BBC  14FC 0020                883              MOVE.B  #' ',(A2)+
00001BC0  14FC 0023                884              MOVE.B  #'#',(A2)+
00001BC4  14FC 0024                885              MOVE.B  #'$',(A2)+
00001BC8  4EB8 1608                886              JSR     printLong
00001BCC  14FC 002C                887              MOVE.B  #',',(A2)+
00001BD0  4EB8 1638                888              JSR     getMode
00001BD4  BC3C 0001                889              CMP.B   #%001,D6    * compare with Ar
00001BD8  6700 2C84                890              BEQ     OPERROR     * error
00001BDC                           891              
00001BDC  4DF9 000048CE            892              LEA     eaTable,A6
00001BE2  CCFC 0008                893              MULU    #8,D6
00001BE6  4EB6 6000                894              JSR     (A6,D6)
00001BEA                           895              * check for error in EA
00001BEA  0C07 0004                896              CMPI.B  #4,D7
00001BEE  6700 2C6E                897              BEQ     OPERROR
00001BF2                           898  
00001BF2  4E75                     899              RTS 
00001BF4                           900  
00001BF4                           901  * CMPI ------------------------------------------------------------------------------
00001BF4  E98B                     902  _CmpI       LSL.L   #4,D3
00001BF6  4EB8 1582                903              JSR     BitTst2
00001BFA  EB8B                     904              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
00001BFC  0C06 0000                905              CMPI.B  #%00,D6 * branch to appropriate size label
00001C00  6700 0016                906              BEQ     _CmpIb   * CMPI.B
00001C04  0C06 0001                907              CMPI.B  #%01,D6
00001C08  6700 006A                908              BEQ     _CmpIw   * CMPI.W
00001C0C  0C06 0002                909              CMPI.B  #%10,D6
00001C10  6700 00BE                910              BEQ     _CmpIl   * CMPI.L
00001C14                           911              * something unexpected
00001C14  6000 2C48                912              BRA     OPERROR
00001C18                           913              
00001C18                           914  * CMPI.B --------------------            
00001C18                           915  _CmpIb      
00001C18  14FC 0043                916              MOVE.B  #'C',(A2)+
00001C1C  14FC 004D                917              MOVE.B  #'M',(A2)+
00001C20  14FC 0050                918              MOVE.B  #'P',(A2)+
00001C24  14FC 0049                919              MOVE.B  #'I',(A2)+ 
00001C28  14FC 002E                920              MOVE.B  #'.',(A2)+ 
00001C2C  14FC 0042                921              MOVE.B  #'B',(A2)+ 
00001C30  14FC 0020                922              MOVE.B  #' ',(A2)+ 
00001C34  14FC 0020                923              MOVE.B  #' ',(A2)+ 
00001C38  14FC 0020                924              MOVE.B  #' ',(A2)+ 
00001C3C  14FC 0020                925              MOVE.B  #' ',(A2)+
00001C40  14FC 0023                926              MOVE.B  #'#',(A2)+
00001C44  14FC 0024                927              MOVE.B  #'$',(A2)+
00001C48  4EB8 15AA                928              JSR     printByte
00001C4C  14FC 002C                929              MOVE.B  #',',(A2)+
00001C50  4EB8 1638                930              JSR     getMode
00001C54  BC3C 0001                931              CMP.B   #%001,D6    * compare with Ar
00001C58  6700 2C04                932              BEQ     OPERROR     * error
00001C5C                           933              
00001C5C  4DF9 000048CE            934              LEA     eaTable,A6
00001C62  CCFC 0008                935              MULU    #8,D6
00001C66  4EB6 6000                936              JSR     (A6,D6)
00001C6A                           937              * check for error in EA
00001C6A  0C07 0004                938              CMPI.B  #4,D7
00001C6E  6700 2BEE                939              BEQ     OPERROR
00001C72                           940  
00001C72  4E75                     941              RTS 
00001C74                           942  * CMPI.W ---------------------
00001C74                           943  _CmpIw      
00001C74  14FC 0043                944              MOVE.B  #'C',(A2)+
00001C78  14FC 004D                945              MOVE.B  #'M',(A2)+
00001C7C  14FC 0050                946              MOVE.B  #'P',(A2)+
00001C80  14FC 0049                947              MOVE.B  #'I',(A2)+ 
00001C84  14FC 002E                948              MOVE.B  #'.',(A2)+ 
00001C88  14FC 0042                949              MOVE.B  #'B',(A2)+ 
00001C8C  14FC 0020                950              MOVE.B  #' ',(A2)+ 
00001C90  14FC 0020                951              MOVE.B  #' ',(A2)+ 
00001C94  14FC 0020                952              MOVE.B  #' ',(A2)+ 
00001C98  14FC 0020                953              MOVE.B  #' ',(A2)+
00001C9C  14FC 0023                954              MOVE.B  #'#',(A2)+
00001CA0  14FC 0024                955              MOVE.B  #'$',(A2)+
00001CA4  4EB8 15DA                956              JSR     printWord
00001CA8  14FC 002C                957              MOVE.B  #',',(A2)+
00001CAC  4EB8 1638                958              JSR     getMode
00001CB0  BC3C 0001                959              CMP.B   #%001,D6    * compare with Ar
00001CB4  6700 2BA8                960              BEQ     OPERROR     * error
00001CB8                           961              
00001CB8  4DF9 000048CE            962              LEA     eaTable,A6
00001CBE  CCFC 0008                963              MULU    #8,D6
00001CC2  4EB6 6000                964              JSR     (A6,D6)
00001CC6                           965              * check for error in EA
00001CC6  0C07 0004                966              CMPI.B  #4,D7
00001CCA  6700 2B92                967              BEQ     OPERROR
00001CCE                           968  
00001CCE  4E75                     969              RTS 
00001CD0                           970  * CMPI.L ---------------------
00001CD0                           971  _CmpIl      
00001CD0  14FC 0043                972              MOVE.B  #'C',(A2)+
00001CD4  14FC 004D                973              MOVE.B  #'M',(A2)+
00001CD8  14FC 0050                974              MOVE.B  #'P',(A2)+
00001CDC  14FC 0049                975              MOVE.B  #'I',(A2)+ 
00001CE0  14FC 002E                976              MOVE.B  #'.',(A2)+ 
00001CE4  14FC 0042                977              MOVE.B  #'B',(A2)+ 
00001CE8  14FC 0020                978              MOVE.B  #' ',(A2)+ 
00001CEC  14FC 0020                979              MOVE.B  #' ',(A2)+ 
00001CF0  14FC 0020                980              MOVE.B  #' ',(A2)+ 
00001CF4  14FC 0020                981              MOVE.B  #' ',(A2)+
00001CF8  14FC 0023                982              MOVE.B  #'#',(A2)+
00001CFC  14FC 0024                983              MOVE.B  #'$',(A2)+
00001D00  4EB8 1608                984              JSR     printLong
00001D04  14FC 002C                985              MOVE.B  #',',(A2)+
00001D08  4EB8 1638                986              JSR     getMode
00001D0C  BC3C 0001                987              CMP.B   #%001,D6    * compare with Ar
00001D10  6700 2B4C                988              BEQ     OPERROR     * error
00001D14                           989              
00001D14  4DF9 000048CE            990              LEA     eaTable,A6
00001D1A  CCFC 0008                991              MULU    #8,D6
00001D1E  4EB6 6000                992              JSR     (A6,D6)
00001D22                           993              * check for error in EA
00001D22  0C07 0004                994              CMPI.B  #4,D7
00001D26  6700 2B36                995              BEQ     OPERROR
00001D2A                           996  
00001D2A  4E75                     997              RTS 
00001D2C                           998              
00001D2C                           999              
00001D2C                          1000              
00001D2C                          1001  * MOVE.B -------------------------------------------------
00001D2C                          1002  op0001          
00001D2C                          1003     
00001D2C  1E3C 0001               1004              MOVE.B  #1,D7       * move 1 into d7 to indicate byte
00001D30  264A                    1005              MOVEA.L A2,A3       * copy current address of A2 string to A3
00001D32                          1006              * store MOVE.B into the A2 string
00001D32  14FC 004D               1007              MOVE.B  #'M',(A2)+
00001D36  14FC 004F               1008              MOVE.B  #'O',(A2)+
00001D3A  14FC 0056               1009              MOVE.B  #'V',(A2)+
00001D3E  14FC 0045               1010              MOVE.B  #'E',(A2)+ 
00001D42  14FC 002E               1011              MOVE.B  #'.',(A2)+ 
00001D46  14FC 0042               1012              MOVE.B  #'B',(A2)+ 
00001D4A  14FC 0020               1013              MOVE.B  #' ',(A2)+ 
00001D4E  14FC 0020               1014              MOVE.B  #' ',(A2)+ 
00001D52  14FC 0020               1015              MOVE.B  #' ',(A2)+ 
00001D56  14FC 0020               1016              MOVE.B  #' ',(A2)+
00001D5A                          1017              
00001D5A                          1018              * get EA for source
00001D5A  4EB8 1638               1019              JSR     getMode
00001D5E  4DF9 000048CE           1020              LEA     eaTable,A6
00001D64  CCFC 0008               1021              MULU    #8,D6
00001D68  4EB6 6000               1022              JSR     (A6,D6)
00001D6C                          1023              * check for error in EA
00001D6C  0C07 0004               1024              CMPI.B  #4,D7
00001D70  6700 2AEC               1025              BEQ     OPERROR
00001D74                          1026              
00001D74  14FC 002C               1027              MOVE.B  #',',(A2)+
00001D78                          1028              
00001D78                          1029              * look at destination
00001D78  2604                    1030              MOVE.L  D4,D3   * reset D3
00001D7A  4843                    1031              SWAP    D3
00001D7C  EF8B                    1032              LSL.L   #7,D3   * shift 7 leading bits out
00001D7E  4EB8 1560               1033              JSR     BitTst3 * test destination mode
00001D82  0C06 0000               1034              CMPI.B  #%000,D6
00001D86  6700 01EC               1035              BEQ     moveDn          * move to data register
00001D8A  0C06 0002               1036              CMPI.B  #%010,D6
00001D8E  6700 0220               1037              BEQ     moveInd         * move to indirect address
00001D92  0C06 0003               1038              CMPI.B  #%011,D6
00001D96  6700 023E               1039              BEQ     movePost        * move to indirect address with post increment
00001D9A  0C06 0004               1040              CMPI.B  #%100,D6
00001D9E  6700 0260               1041              BEQ     movePre         * move to indirect address with pre decrement
00001DA2  0C06 0007               1042              CMPI.B  #%111,D6
00001DA6  6700 0282               1043              BEQ     moveAbs         * move to absolute address
00001DAA                          1044  
00001DAA  6000 2AB2               1045              BRA     OPERROR 
00001DAE                          1046              
00001DAE  4E75                    1047              RTS
00001DB0                          1048  
00001DB0                          1049              
00001DB0                          1050  * MOVE.L/MOVEA.L ----------------------------------------
00001DB0                          1051  op0010   
00001DB0  4843                    1052              SWAP    D3          * swap D3 bits to top for bit checking subroutine
00001DB2  EF8B                    1053              LSL.L   #7,D3       * shift out op code and dest register
00001DB4  1E3C 0003               1054              MOVE.B  #3,D7       * move 3 into d7 to indicate long
00001DB8  4EB8 1560               1055              JSR     BitTst3     
00001DBC  0C06 0001               1056              CMPI.B  #%001,D6    * if dest mode is address reg, branch to MOVEA
00001DC0  6700 0082               1057              BEQ     _MoveAl     * go to MOVEA.L
00001DC4                          1058              
00001DC4  264A                    1059              MOVEA.L A2,A3       * copy current address of A2 string to A3
00001DC6                          1060              * store MOVE.B into the A2 string
00001DC6  14FC 004D               1061              MOVE.B  #'M',(A2)+
00001DCA  14FC 004F               1062              MOVE.B  #'O',(A2)+
00001DCE  14FC 0056               1063              MOVE.B  #'V',(A2)+
00001DD2  14FC 0045               1064              MOVE.B  #'E',(A2)+ 
00001DD6  14FC 002E               1065              MOVE.B  #'.',(A2)+ 
00001DDA  14FC 004C               1066              MOVE.B  #'L',(A2)+ 
00001DDE  14FC 0020               1067              MOVE.B  #' ',(A2)+ 
00001DE2  14FC 0020               1068              MOVE.B  #' ',(A2)+ 
00001DE6  14FC 0020               1069              MOVE.B  #' ',(A2)+ 
00001DEA  14FC 0020               1070              MOVE.B  #' ',(A2)+
00001DEE                          1071              
00001DEE                          1072              * get EA for source
00001DEE  4EB8 1638               1073              JSR     getMode
00001DF2  4DF9 000048CE           1074              LEA     eaTable,A6
00001DF8  CCFC 0008               1075              MULU    #8,D6
00001DFC  4EB6 6000               1076              JSR     (A6,D6)
00001E00                          1077              * check for error in EA
00001E00  0C07 0004               1078              CMPI.B  #4,D7
00001E04  6700 2A58               1079              BEQ     OPERROR
00001E08                          1080              
00001E08  14FC 002C               1081              MOVE.B  #',',(A2)+
00001E0C                          1082              * look at destination
00001E0C  2604                    1083              MOVE.L  D4,D3   * reset D3
00001E0E  4843                    1084              SWAP    D3
00001E10  EF8B                    1085              LSL.L   #7,D3   * shift 7 leading bits out
00001E12  4EB8 1560               1086              JSR     BitTst3 * test destination mode
00001E16  0C06 0000               1087              CMPI.B  #%000,D6
00001E1A  6700 0158               1088              BEQ     moveDn          * move to data register
00001E1E  0C06 0002               1089              CMPI.B  #%010,D6
00001E22  6700 018C               1090              BEQ     moveInd         * move to indirect address
00001E26  0C06 0003               1091              CMPI.B  #%011,D6
00001E2A  6700 01AA               1092              BEQ     movePost        * move to indirect address with post increment
00001E2E  0C06 0004               1093              CMPI.B  #%100,D6
00001E32  6700 01CC               1094              BEQ     movePre         * move to indirect address with pre decrement
00001E36  0C06 0007               1095              CMPI.B  #%111,D6
00001E3A  6700 01EE               1096              BEQ     moveAbs         * move to absolute address
00001E3E                          1097  
00001E3E  6000 2A1E               1098              BRA     OPERROR 
00001E42                          1099              
00001E42  4E75                    1100              RTS
00001E44                          1101              
00001E44  264A                    1102  _MoveAl     MOVEA.L A2,A3       * copy current address of A2 string to A3
00001E46                          1103              * store MOVE.B into the A2 string
00001E46  14FC 004D               1104              MOVE.B  #'M',(A2)+
00001E4A  14FC 004F               1105              MOVE.B  #'O',(A2)+
00001E4E  14FC 0056               1106              MOVE.B  #'V',(A2)+
00001E52  14FC 0045               1107              MOVE.B  #'E',(A2)+ 
00001E56  14FC 0041               1108              MOVE.B  #'A',(A2)+ 
00001E5A  14FC 002E               1109              MOVE.B  #'.',(A2)+ 
00001E5E  14FC 004C               1110              MOVE.B  #'L',(A2)+ 
00001E62  14FC 0020               1111              MOVE.B  #' ',(A2)+ 
00001E66  14FC 0020               1112              MOVE.B  #' ',(A2)+ 
00001E6A  14FC 0020               1113              MOVE.B  #' ',(A2)+
00001E6E                          1114              
00001E6E                          1115  
00001E6E                          1116              * get EA for source
00001E6E  4EB8 1638               1117              JSR     getMode
00001E72  4DF9 000048CE           1118              LEA     eaTable,A6
00001E78  CCFC 0008               1119              MULU    #8,D6
00001E7C  4EB6 6000               1120              JSR     (A6,D6)
00001E80                          1121              * check for error in EA
00001E80  0C07 0004               1122              CMPI.B  #4,D7
00001E84  6700 29D8               1123              BEQ     OPERROR
00001E88                          1124              
00001E88  14FC 002C               1125              MOVE.B  #',',(A2)+
00001E8C                          1126              * get destination register
00001E8C  6000 0104               1127              BRA     moveAddr
00001E90                          1128              
00001E90  4E75                    1129              RTS
00001E92                          1130  
00001E92                          1131  * MOVE.W/MOVEA.W ----------------------------------------
00001E92                          1132  
00001E92                          1133  op0011
00001E92                          1134              
00001E92  4843                    1135              SWAP    D3
00001E94  EF8B                    1136              LSL.L   #7,D3       * shift out op code and dest register
00001E96  1E3C 0002               1137              MOVE.B  #2,D7       * move 2 into d7 to indicate word
00001E9A  4EB8 1560               1138              JSR     BitTst3     
00001E9E  0C06 0001               1139              CMPI.B  #%001,D6    * if dest mode is address, branch to MOVEA
00001EA2  6700 0082               1140              BEQ     _MoveAw     * go to MOVEA.W
00001EA6  264A                    1141              MOVEA.L A2,A3       * copy current address of A2 string to A3
00001EA8                          1142              * store MOVE.B into the A2 string
00001EA8  14FC 004D               1143              MOVE.B  #'M',(A2)+
00001EAC  14FC 004F               1144              MOVE.B  #'O',(A2)+
00001EB0  14FC 0056               1145              MOVE.B  #'V',(A2)+
00001EB4  14FC 0045               1146              MOVE.B  #'E',(A2)+ 
00001EB8  14FC 002E               1147              MOVE.B  #'.',(A2)+ 
00001EBC  14FC 0057               1148              MOVE.B  #'W',(A2)+ 
00001EC0  14FC 0020               1149              MOVE.B  #' ',(A2)+ 
00001EC4  14FC 0020               1150              MOVE.B  #' ',(A2)+ 
00001EC8  14FC 0020               1151              MOVE.B  #' ',(A2)+ 
00001ECC  14FC 0020               1152              MOVE.B  #' ',(A2)+
00001ED0                          1153              
00001ED0                          1154              * get EA for source
00001ED0  4EB8 1638               1155              JSR     getMode
00001ED4  4DF9 000048CE           1156              LEA     eaTable,A6
00001EDA  CCFC 0008               1157              MULU    #8,D6
00001EDE  4EB6 6000               1158              JSR     (A6,D6)
00001EE2                          1159              * check for error in EA
00001EE2  0C07 0004               1160              CMPI.B  #4,D7
00001EE6  6700 2976               1161              BEQ     OPERROR
00001EEA                          1162              
00001EEA  14FC 002C               1163              MOVE.B  #',',(A2)+
00001EEE                          1164              * look at destination
00001EEE  2604                    1165              MOVE.L  D4,D3   * reset D3
00001EF0  4843                    1166              SWAP    D3
00001EF2  EF8B                    1167              LSL.L   #7,D3   * shift 7 leading bits out
00001EF4  4EB8 1560               1168              JSR     BitTst3 * test destination mode
00001EF8  0C06 0000               1169              CMPI.B  #%000,D6
00001EFC  6700 0076               1170              BEQ     moveDn          * move to data register
00001F00  0C06 0002               1171              CMPI.B  #%010,D6
00001F04  6700 00AA               1172              BEQ     moveInd         * move to indirect address
00001F08  0C06 0003               1173              CMPI.B  #%011,D6
00001F0C  6700 00C8               1174              BEQ     movePost        * move to indirect address with post increment
00001F10  0C06 0004               1175              CMPI.B  #%100,D6
00001F14  6700 00EA               1176              BEQ     movePre         * move to indirect address with pre decrement
00001F18  0C06 0007               1177              CMPI.B  #%111,D6
00001F1C  6700 010C               1178              BEQ     moveAbs         * move to absolute address
00001F20                          1179  
00001F20  6000 293C               1180              BRA     OPERROR 
00001F24                          1181  
00001F24  4E75                    1182              RTS
00001F26                          1183              
00001F26  264A                    1184  _MoveAw     MOVEA.L A2,A3       * copy current address of A2 string to A3
00001F28  14FC 004D               1185              MOVE.B  #'M',(A2)+
00001F2C  14FC 004F               1186              MOVE.B  #'O',(A2)+
00001F30  14FC 0056               1187              MOVE.B  #'V',(A2)+
00001F34  14FC 0045               1188              MOVE.B  #'E',(A2)+ 
00001F38  14FC 0041               1189              MOVE.B  #'A',(A2)+ 
00001F3C  14FC 002E               1190              MOVE.B  #'.',(A2)+ 
00001F40  14FC 0057               1191              MOVE.B  #'W',(A2)+ 
00001F44  14FC 0020               1192              MOVE.B  #' ',(A2)+ 
00001F48  14FC 0020               1193              MOVE.B  #' ',(A2)+ 
00001F4C  14FC 0020               1194              MOVE.B  #' ',(A2)+
00001F50                          1195              
00001F50                          1196              * get EA for source
00001F50  4EB8 1638               1197              JSR     getMode
00001F54  4DF9 000048CE           1198              LEA     eaTable,A6
00001F5A  CCFC 0008               1199              MULU    #8,D6
00001F5E  4EB6 6000               1200              JSR     (A6,D6)
00001F62                          1201              * check for error in EA
00001F62  0C07 0004               1202              CMPI.B  #4,D7
00001F66  6700 28F6               1203              BEQ     OPERROR
00001F6A  14FC 002C               1204              MOVE.B  #',',(A2)+
00001F6E  6000 0022               1205              BRA     moveAddr
00001F72                          1206  
00001F72  4E75                    1207              RTS
00001F74                          1208  
00001F74                          1209  *********************************************************************************
00001F74                          1210  * MOVE destination functions
00001F74                          1211  *********************************************************************************
00001F74                          1212  
00001F74                          1213  * Move to data register ----------------
00001F74                          1214  moveDn
00001F74  14FC 0044               1215              MOVE.B  #'D',(A2)+      * print D
00001F78                          1216                  
00001F78  2604                    1217              MOVE.L  D4,D3           * reset D3
00001F7A  4843                    1218              SWAP    D3              * swap to front
00001F7C  E98B                    1219              LSL.L   #4,D3           * shift out opcode
00001F7E  4EB8 1560               1220              JSR     BitTst3         * get register number
00001F82                          1221              
00001F82  4DF9 00004A6E           1222              LEA     numTable,A6     * load num table
00001F88  CCFC 0008               1223              MULU    #8,D6           * offset for table
00001F8C  4EB6 6000               1224              JSR     (A6,D6)         * print the data
00001F90                          1225              
00001F90  4E75                    1226              RTS
00001F92                          1227              
00001F92                          1228  * Move to address register -------------
00001F92                          1229  moveAddr
00001F92  14FC 0041               1230              MOVE.B  #'A',(A2)+      * print A
00001F96                          1231              
00001F96  2604                    1232              MOVE.L  D4,D3           * reset D3
00001F98  4843                    1233              SWAP    D3              * swap to front
00001F9A  E98B                    1234              LSL.L   #4,D3           * shift out opcode
00001F9C  4EB8 1560               1235              JSR     BitTst3         * get register number
00001FA0                          1236              
00001FA0  4DF9 00004A6E           1237              LEA     numTable,A6     * load num table
00001FA6  CCFC 0008               1238              MULU    #8,D6           * offset for table
00001FAA  4EB6 6000               1239              JSR     (A6,D6)         * add data to A2 string
00001FAE                          1240              
00001FAE  4E75                    1241              RTS
00001FB0                          1242              
00001FB0                          1243  * Move to address register indirect ----
00001FB0                          1244  moveInd     
00001FB0  14FC 0028               1245              MOVE.B  #'(',(A2)+  * print (A
00001FB4  14FC 0041               1246              MOVE.B  #'A',(A2)+
00001FB8                          1247              
00001FB8  2604                    1248              MOVE.L  D4,D3       * reset D3
00001FBA  4843                    1249              SWAP    D3          * swap to front
00001FBC  E98B                    1250              LSL.L   #4,D3       * shift out opcode
00001FBE  4EB8 1560               1251              JSR     BitTst3     * get register number
00001FC2                          1252              
00001FC2  4DF9 00004A6E           1253              LEA     numTable,A6 * load num table
00001FC8  CCFC 0008               1254              MULU    #8,D6       * offset for table
00001FCC  4EB6 6000               1255              JSR     (A6,D6)     * print data
00001FD0                          1256              
00001FD0  14FC 0029               1257              MOVE.B  #')',(A2)+  * finish with )
00001FD4                          1258              
00001FD4  4E75                    1259              RTS
00001FD6                          1260              
00001FD6                          1261  * Move to address post increment -------
00001FD6                          1262  movePost    
00001FD6  14FC 0028               1263              MOVE.B  #'(',(A2)+
00001FDA  14FC 0041               1264              MOVE.B  #'A',(A2)+
00001FDE                          1265              
00001FDE  2604                    1266              MOVE.L  D4,D3
00001FE0  4843                    1267              SWAP    D3
00001FE2  E98B                    1268              LSL.L   #4,D3
00001FE4  4EB8 1560               1269              JSR     BitTst3
00001FE8                          1270              
00001FE8  4DF9 00004A6E           1271              LEA     numTable,A6
00001FEE  CCFC 0008               1272              MULU    #8,D6
00001FF2  4EB6 6000               1273              JSR     (A6,D6)
00001FF6                          1274              
00001FF6  14FC 0029               1275              MOVE.B  #')',(A2)+
00001FFA  14FC 002B               1276              MOVE.B  #'+',(A2)+
00001FFE                          1277              
00001FFE  4E75                    1278              RTS
00002000                          1279  
00002000                          1280  * Move to address pre decrement --------
00002000                          1281  movePre
00002000  14FC 002D               1282              MOVE.B  #'-',(A2)+
00002004  14FC 0028               1283              MOVE.B  #'(',(A2)+
00002008  14FC 0041               1284              MOVE.B  #'A',(A2)+
0000200C                          1285              
0000200C  2604                    1286              MOVE.L  D4,D3
0000200E  4843                    1287              SWAP    D3
00002010  E98B                    1288              LSL.L   #4,D3
00002012  4EB8 1560               1289              JSR     BitTst3
00002016                          1290              
00002016  4DF9 00004A6E           1291              LEA     numTable,A6
0000201C  CCFC 0008               1292              MULU    #8,D6
00002020  4EB6 6000               1293              JSR     (A6,D6)
00002024                          1294              
00002024  14FC 0029               1295              MOVE.B  #')',(A2)+
00002028                          1296              
00002028  4E75                    1297              RTS
0000202A                          1298  * Move to absolute address -------------
0000202A                          1299  moveAbs     
0000202A  14FC 0024               1300              MOVE.B  #'$',(A2)+  * add $ to A2 string
0000202E  2604                    1301              MOVE.L  D4,D3
00002030  4843                    1302              SWAP    D3
00002032  E98B                    1303              LSL.L   #4,D3   * shift out opcode
00002034  4EB8 1560               1304              JSR     BitTst3 * check next three bits
00002038                          1305              
00002038  0C06 0000               1306              CMPI.B  #%000,D6
0000203C  6700 F59C               1307              BEQ     printWord
00002040  0C06 0001               1308              CMPI.B  #%001,D6
00002044  6700 F5C2               1309              BEQ     printLong
00002048                          1310  
00002048  4EB9 0000485E           1311              JSR     OPERROR       
0000204E                          1312              
0000204E                          1313   * MOVEM, LEA, CLR, JSR, RTS, NOP ------------------------------------------------------
0000204E                          1314  op0100 
0000204E  B67C 4EB9               1315              CMP.W   #$4EB9,D3   * compare to JSR code
00002052  6700 0048               1316              BEQ     jumpSR
00002056  B67C 4E75               1317              CMP.W   #$4E75,D3   * compare to RTS code
0000205A  6700 00AA               1318              BEQ     returnSR
0000205E  B67C 4E71               1319              CMP.W   #$4E71,D3   * compare to NOP code
00002062  6700 00B0               1320              BEQ     noOp
00002066  4843                    1321              SWAP    D3          * swap D3 to check for bits
00002068  EF8B                    1322              LSL.L   #7,D3       * shift 7 bits out to check for lea/movem instruction
0000206A                          1323              *LEA has the form |opcode|An|111|...
0000206A  4EB8 1560               1324              JSR     BitTst3
0000206E  BC3C 0007               1325              CMP.B   #%111,D6    * if the next 3 bits match 111,
00002072  6700 00AE               1326              BEQ     _lea        * branch to lea
00002076                          1327              
00002076  2604                    1328              MOVE.L  D4,D3   * reset D3
00002078  4843                    1329              SWAP    D3
0000207A  E98B                    1330              LSL.L   #4,D3   * shift out op code
0000207C  4EB8 1534               1331              JSR     BITTEST
00002080                          1332              *MOVEM has form |opcode|1D0|01S|.. where S = size
00002080  BC3C 0008               1333              CMP.B   #%1000,D6    * if next 4 bits match 1000, it is a MOVEM
00002084  6700 013E               1334              BEQ     _MoveM
00002088  BC3C 000C               1335              CMP.B   #%1100,D6    * if next 4 bits match 1100, it is a MOVEM
0000208C  6700 0136               1336              BEQ     _MoveM
00002090                          1337              
00002090  BC3C 0002               1338              CMP.B   #%0010,D6 * if 0010, it is a clear instruction,
00002094  6700 0680               1339              BEQ     _clr      * since lea/movem/jsr/rts have been handled
00002098                          1340              
00002098  6000 27C4               1341              BRA     OPERROR
0000209C                          1342              * if it isnt any of these == error/not supported           
0000209C                          1343  
0000209C                          1344  * JSR ------------------------------------------------------------------------------
0000209C                          1345  jumpSR
0000209C  264A                    1346              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000209E  1E3C 0003               1347              MOVE.B  #3,D7       * indicate long word instruction
000020A2  14FC 004A               1348              MOVE.B  #'J',(A2)+
000020A6  14FC 0053               1349              MOVE.B  #'S',(A2)+
000020AA  14FC 0052               1350              MOVE.B  #'R',(A2)+
000020AE  14FC 0020               1351              MOVE.B  #' ',(A2)+
000020B2  14FC 0020               1352              MOVE.B  #' ',(A2)+
000020B6  14FC 0020               1353              MOVE.B  #' ',(A2)+
000020BA  14FC 0020               1354              MOVE.B  #' ',(A2)+
000020BE  14FC 0020               1355              MOVE.B  #' ',(A2)+
000020C2  14FC 0020               1356              MOVE.B  #' ',(A2)+
000020C6  14FC 0020               1357              MOVE.B  #' ',(A2)+
000020CA                          1358              
000020CA  4EB8 1638               1359              JSR     getMode
000020CE  0C06 0006               1360              CMPI.B  #%110,D6    * addressing with index which isnt supported
000020D2  6700 278A               1361              BEQ     OPERROR
000020D6                          1362              
000020D6  E74E                    1363              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000020D8  1A06                    1364              MOVE.B  D6,D5       * hold destination mode bits in d5
000020DA  E78B                    1365              LSL.L   #3,D3       * shift destination mode bits out
000020DC  4EB8 1560               1366              JSR     BitTst3     * test the destination register bits
000020E0  DA46                    1367              ADD.W   D6,D5       * add these to the mode bits
000020E2  0C05 003C               1368              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000020E6  6700 2776               1369              BEQ     OPERROR     * immediate data, there is not allowed for dest, error
000020EA                          1370              
000020EA                          1371              * no errors
000020EA  4EB8 1638               1372              JSR     getMode
000020EE  4DF9 000048CE           1373              LEA     eaTable,A6
000020F4  CCFC 0008               1374              MULU    #8,D6
000020F8  4EB6 6000               1375              JSR     (A6,D6)
000020FC                          1376              * check for error in EA
000020FC  0C07 0004               1377              CMPI.B  #4,D7
00002100  6700 275C               1378              BEQ     OPERROR
00002104                          1379              
00002104  4E75                    1380              RTS
00002106                          1381  
00002106                          1382  * RTS ------------------------------------------------------------------------------            
00002106  14FC 0052               1383  returnSR    MOVE.B  #'R',(A2)+
0000210A  14FC 0054               1384              MOVE.B  #'T',(A2)+
0000210E  14FC 0053               1385              MOVE.B  #'S',(A2)+
00002112  4E75                    1386              RTS
00002114                          1387              
00002114                          1388  * NOP ------------------------------------------------------------------------------
00002114  14FC 004E               1389  noOp        MOVE.B  #'N',(A2)+
00002118  14FC 004F               1390              MOVE.B  #'O',(A2)+
0000211C  14FC 0050               1391              MOVE.B  #'P',(A2)+
00002120  4E75                    1392              RTS            
00002122                          1393              
00002122                          1394  * LEA ------------------------------------------------------------------------------
00002122                          1395  _lea
00002122  264A                    1396              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002124  1E3C 0003               1397              MOVE.B  #3,D7       * indicate longword instruction
00002128  14FC 004C               1398              MOVE.B  #'L',(A2)+
0000212C  14FC 0045               1399              MOVE.B  #'E',(A2)+
00002130  14FC 0041               1400              MOVE.B  #'A',(A2)+
00002134  14FC 0020               1401              MOVE.B  #' ',(A2)+
00002138  14FC 0020               1402              MOVE.B  #' ',(A2)+
0000213C  14FC 0020               1403              MOVE.B  #' ',(A2)+
00002140  14FC 0020               1404              MOVE.B  #' ',(A2)+
00002144  14FC 0020               1405              MOVE.B  #' ',(A2)+
00002148  14FC 0020               1406              MOVE.B  #' ',(A2)+
0000214C  14FC 0020               1407              MOVE.B  #' ',(A2)+
00002150                          1408              *get EA mode
00002150  4EB8 1638               1409              JSR     getMode
00002154                          1410              * modes not allowed: Dn, An, (An)+, -(An), #<data>
00002154  0C06 0000               1411              CMPI.B  #%000,D6
00002158  6700 2704               1412              BEQ     OPERROR     * Dn
0000215C  0C06 0001               1413              CMPI.B  #%001,D6
00002160  6700 26FC               1414              BEQ     OPERROR     * An
00002164  0C06 0003               1415              CMPI.B  #%011,D6
00002168  6700 26F4               1416              BEQ     OPERROR     * (An)+
0000216C  0C06 0004               1417              CMPI.B  #%100,D6
00002170  6700 26EC               1418              BEQ     OPERROR     * -(An)
00002174                          1419              
00002174  E74E                    1420              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002176  1A06                    1421              MOVE.B  D6,D5       * hold destination mode bits in d5
00002178  E78B                    1422              LSL.L   #3,D3       * shift destination mode bits out
0000217A  4EB8 1560               1423              JSR     BitTst3     * test the destination register bits
0000217E  DA46                    1424              ADD.W   D6,D5       * add these to the mode bits
00002180  0C05 003C               1425              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002184  6700 26D8               1426              BEQ     OPERROR     * immediate data, there is not allowed for dest, error
00002188                          1427              
00002188                          1428              * no errors
00002188  4EB8 1638               1429              JSR     getMode
0000218C  4DF9 000048CE           1430              LEA     eaTable,A6
00002192  CCFC 0008               1431              MULU    #8,D6
00002196  4EB6 6000               1432              JSR     (A6,D6)
0000219A                          1433              * check for error in EA
0000219A  0C07 0004               1434              CMPI.B  #4,D7
0000219E  6700 26BE               1435              BEQ     OPERROR
000021A2                          1436              
000021A2  14FC 002C               1437              MOVE.B  #',',(A2)+
000021A6  14FC 0041               1438              MOVE.B  #'A',(A2)+
000021AA  2604                    1439              MOVE.L  D4,D3       * reset D3
000021AC  4843                    1440              SWAP    D3          * set D3 to front
000021AE  E98B                    1441              LSL.L   #4,D3       * shift out opcode
000021B0  4EB8 1560               1442              JSR     BitTst3     * check 3 bits for register number
000021B4                          1443              
000021B4  CCFC 0008               1444              MULU    #8,D6       * offset
000021B8  4DF9 00004A6E           1445              LEA     numTable,A6 * load num table
000021BE  4EB6 6000               1446              JSR     (A6,D6)     * get the number from table and print
000021C2                          1447                         
000021C2  4E75                    1448              RTS
000021C4                          1449  * MOVEM ------------------------------------------------------------------------------
000021C4                          1450  _MoveM     
000021C4  4EB8 1560               1451              JSR     BitTst3     * check bits 9-11 for mode of MOVEM
000021C8  2604                    1452              MOVE.L  D4,D3       * reset D3
000021CA  0C06 0004               1453              CMPI.B  #%100,D6    * 100 indicates reg to mem
000021CE  6700 000A               1454              BEQ     _MoveMDn
000021D2  0C06 0006               1455              CMPI.B  #%110,D6    * 110 indicates mem to reg
000021D6  6700 00C6               1456              BEQ     _MoveMAn
000021DA                          1457  
000021DA                          1458  _MoveMDn
000021DA                          1459              * test the size bit of MOVEM
000021DA  0803 0006               1460              BTST.L  #$06,D3
000021DE  6600 0060               1461              BNE     _MoveMDnL  * default to word size
000021E2                          1462  * MOVEM.W --------------------
000021E2  14FC 004D               1463              MOVE.B  #'M',(A2)+
000021E6  14FC 004F               1464              MOVE.B  #'O',(A2)+
000021EA  14FC 0056               1465              MOVE.B  #'V',(A2)+
000021EE  14FC 0045               1466              MOVE.B  #'E',(A2)+
000021F2  14FC 004D               1467              MOVE.B  #'M',(A2)+
000021F6  14FC 002E               1468              MOVE.B  #'.',(A2)+
000021FA  14FC 0057               1469              MOVE.B  #'W',(A2)+
000021FE  14FC 0020               1470              MOVE.B  #' ',(A2)+
00002202  14FC 0020               1471              MOVE.B  #' ',(A2)+
00002206  14FC 0020               1472              MOVE.B  #' ',(A2)+
0000220A                          1473              
0000220A  4EB9 0000253A           1474              JSR     PreDec  * print register list
00002210                          1475                         
00002210  14FC 002C               1476              MOVE.B  #',',(A2)+
00002214                          1477              
00002214  4EB8 1638               1478              JSR     getMode
00002218  0C06 0001               1479              CMPI.B  #%001,D6
0000221C  6F00 2640               1480              BLE     OPERROR     * Dn and An illegal
00002220  0C06 0003               1481              CMPI.B  #%011,D6
00002224  6700 2638               1482              BEQ     OPERROR     * (An)+ illegal with this mode
00002228                          1483              
00002228  4DF9 000048CE           1484              LEA     eaTable,A6
0000222E  CCFC 0008               1485              MULU    #8,D6
00002232  4EB6 6000               1486              JSR     (A6,D6)
00002236                          1487              * check for error in EA
00002236  0C07 0004               1488              CMPI.B  #4,D7
0000223A  6700 2622               1489              BEQ     OPERROR
0000223E                          1490           
0000223E  4E75                    1491              RTS
00002240                          1492  
00002240                          1493  * MOVEM.L --------------------
00002240                          1494  _MoveMDnL   * it is long type
00002240  14FC 004D               1495              MOVE.B  #'M',(A2)+
00002244  14FC 004F               1496              MOVE.B  #'O',(A2)+
00002248  14FC 0056               1497              MOVE.B  #'V',(A2)+
0000224C  14FC 0045               1498              MOVE.B  #'E',(A2)+
00002250  14FC 004D               1499              MOVE.B  #'M',(A2)+
00002254  14FC 002E               1500              MOVE.B  #'.',(A2)+
00002258  14FC 004C               1501              MOVE.B  #'L',(A2)+
0000225C  14FC 0020               1502              MOVE.B  #' ',(A2)+
00002260  14FC 0020               1503              MOVE.B  #' ',(A2)+
00002264  14FC 0020               1504              MOVE.B  #' ',(A2)+
00002268                          1505             
00002268  4EB9 0000253A           1506              JSR     PreDec   * print register list 
0000226E                          1507              
0000226E  14FC 002C               1508              MOVE.B  #',',(A2)+
00002272                          1509              
00002272  4EB8 1638               1510              JSR     getMode
00002276  0C06 0001               1511              CMPI.B  #%001,D6
0000227A  6F00 25E2               1512              BLE     OPERROR     * Dn and An illegal
0000227E  0C06 0003               1513              CMPI.B  #%011,D6
00002282  6700 25DA               1514              BEQ     OPERROR     * (An)+ illegal with this mode
00002286  4DF9 000048CE           1515              LEA     eaTable,A6
0000228C  CCFC 0008               1516              MULU    #8,D6
00002290  4EB6 6000               1517              JSR     (A6,D6)
00002294                          1518              * check for error in EA
00002294  0C07 0004               1519              CMPI.B  #4,D7
00002298  6700 25C4               1520              BEQ     OPERROR        
0000229C  4E75                    1521              RTS 
0000229E                          1522  
0000229E                          1523  _MoveMAn    * test the size bit of MOVEM
0000229E  0803 0006               1524              BTST.L  #$06,D3
000022A2  6600 0060               1525              BNE     _MoveMAnL
000022A6                          1526              * default to word size
000022A6                          1527  * MOVEM.W --------------------
000022A6  14FC 004D               1528              MOVE.B  #'M',(A2)+
000022AA  14FC 004F               1529              MOVE.B  #'O',(A2)+
000022AE  14FC 0056               1530              MOVE.B  #'V',(A2)+
000022B2  14FC 0045               1531              MOVE.B  #'E',(A2)+
000022B6  14FC 004D               1532              MOVE.B  #'M',(A2)+
000022BA  14FC 002E               1533              MOVE.B  #'.',(A2)+
000022BE  14FC 0057               1534              MOVE.B  #'W',(A2)+
000022C2  14FC 0020               1535              MOVE.B  #' ',(A2)+
000022C6  14FC 0020               1536              MOVE.B  #' ',(A2)+
000022CA  14FC 0020               1537              MOVE.B  #' ',(A2)+
000022CE                          1538              
000022CE  4EB9 00002362           1539              JSR     PostInc     * print list
000022D4                          1540              
000022D4  14FC 002C               1541              MOVE.B  #',',(A2)+
000022D8                          1542              
000022D8  4EB8 1638               1543              JSR     getMode
000022DC  0C06 0001               1544              CMPI.B  #%001,D6
000022E0  6F00 257C               1545              BLE     OPERROR     * Dn and An illegal
000022E4  0C06 0004               1546              CMPI.B  #%100,D6
000022E8  6700 2574               1547              BEQ     OPERROR     * -(An) illegal with this mode
000022EC                          1548              
000022EC  4DF9 000048CE           1549              LEA     eaTable,A6
000022F2  CCFC 0008               1550              MULU    #8,D6
000022F6  4EB6 6000               1551              JSR     (A6,D6)
000022FA                          1552              * check for error in EA
000022FA  0C07 0004               1553              CMPI.B  #4,D7
000022FE  6700 255E               1554              BEQ     OPERROR
00002302                          1555              
00002302  4E75                    1556              RTS
00002304                          1557              
00002304                          1558  * MOVEM.L --------------------            
00002304                          1559  _MoveMAnL   
00002304  14FC 004D               1560              MOVE.B  #'M',(A2)+
00002308  14FC 004F               1561              MOVE.B  #'O',(A2)+
0000230C  14FC 0056               1562              MOVE.B  #'V',(A2)+
00002310  14FC 0045               1563              MOVE.B  #'E',(A2)+
00002314  14FC 004D               1564              MOVE.B  #'M',(A2)+
00002318  14FC 002E               1565              MOVE.B  #'.',(A2)+
0000231C  14FC 004C               1566              MOVE.B  #'L',(A2)+
00002320  14FC 0020               1567              MOVE.B  #' ',(A2)+
00002324  14FC 0020               1568              MOVE.B  #' ',(A2)+
00002328  14FC 0020               1569              MOVE.B  #' ',(A2)+
0000232C                          1570              
0000232C  4EB9 00002362           1571              JSR     PostInc   * print list
00002332                          1572              
00002332  14FC 002C               1573              MOVE.B  #',',(A2)+
00002336  4EB8 1638               1574              JSR     getMode
0000233A  0C06 0001               1575              CMPI.B  #%001,D6
0000233E  6F00 251E               1576              BLE     OPERROR     * Dn and An illegal
00002342  0C06 0004               1577              CMPI.B  #%100,D6
00002346  6700 2516               1578              BEQ     OPERROR     * -(An) illegal with this mode
0000234A                          1579              
0000234A  4DF9 000048CE           1580              LEA     eaTable,A6
00002350  CCFC 0008               1581              MULU    #8,D6
00002354  4EB6 6000               1582              JSR     (A6,D6)
00002358                          1583              * check for error in EA
00002358  0C07 0004               1584              CMPI.B  #4,D7
0000235C  6700 2500               1585              BEQ     OPERROR
00002360                          1586              
00002360  4E75                    1587              RTS
00002362                          1588              
00002362                          1589  PostInc
00002362  3614                    1590              MOVE.W  (A4),D3     * move the next word into D3
00002364                          1591              
00002364  0803 0000               1592              BTST.L  #$00,D3     * D0
00002368  6600 007C               1593              BNE     _d0
0000236C                          1594              
0000236C  0803 0001               1595  Pi_d1       BTST.L  #$01,D3     * D1
00002370  6600 0084               1596              BNE     _d1
00002374  0803 0002               1597  Pi_d2       BTST.L  #$02,D3     * D2
00002378  6600 0092               1598              BNE     _d2
0000237C  0803 0003               1599  Pi_d3       BTST.L  #$03,D3     * D3
00002380  6600 00A0               1600              BNE     _d3
00002384  0803 0004               1601  Pi_d4       BTST.L  #$04,D3     * D4
00002388  6600 00AE               1602              BNE     _d4
0000238C  0803 0005               1603  Pi_d5       BTST.L  #$05,D3     * D5
00002390  6600 00BC               1604              BNE     _d5
00002394  0803 0006               1605  Pi_d6       BTST.L  #$06,D3     * D6
00002398  6600 00CA               1606              BNE     _d6
0000239C  0803 0007               1607  Pi_d7       BTST.L  #$07,D3     * D7
000023A0  6600 00D8               1608              BNE     _d7
000023A4  0803 0008               1609  Pi_a0       BTST.L  #$08,D3     * A0
000023A8  6600 00E6               1610              BNE     _a0
000023AC  0803 0009               1611  Pi_a1       BTST.L  #$09,D3     * A1
000023B0  6600 00F4               1612              BNE     _a1
000023B4  0803 000A               1613  Pi_a2       BTST.L  #$0A,D3     * A2
000023B8  6600 0102               1614              BNE     _a2
000023BC  0803 000B               1615  Pi_a3       BTST.L  #$0B,D3     * A3
000023C0  6600 0110               1616              BNE     _a3
000023C4  0803 000C               1617  Pi_a4       BTST.L  #$0C,D3     * A4
000023C8  6600 011E               1618              BNE     _a4
000023CC  0803 000D               1619  Pi_a5       BTST.L  #$0D,D3     * A5
000023D0  6600 012C               1620              BNE     _a5
000023D4  0803 000E               1621  Pi_a6       BTST.L  #$0E,D3     * A6
000023D8  6600 013A               1622              BNE     _a6
000023DC  0803 000F               1623  Pi_a7       BTST.L  #$0F,D3     * A7
000023E0  6600 0148               1624              BNE     _a7
000023E4                          1625  
000023E4  4E75                    1626              RTS
000023E6                          1627              
000023E6  14FC 0044               1628  _d0         MOVE.B  #'D',(A2)+
000023EA  14FC 0030               1629              MOVE.B  #'0',(A2)+
000023EE  103C 0001               1630              MOVE.B  #1,D0        * move flag for first register
000023F2  6000 FF78               1631              BRA     Pi_d1
000023F6                          1632  
000023F6  4EB9 00002708           1633  _d1         JSR     printSlash
000023FC  14FC 0044               1634              MOVE.B  #'D',(A2)+
00002400  14FC 0031               1635              MOVE.B  #'1',(A2)+
00002404  103C 0001               1636              MOVE.B  #1,D0        * move flag for first register
00002408  6000 FF6A               1637              BRA     Pi_d2
0000240C                          1638  
0000240C  4EB9 00002708           1639  _d2         JSR     printSlash
00002412  14FC 0044               1640              MOVE.B  #'D',(A2)+
00002416  14FC 0032               1641              MOVE.B  #'2',(A2)+
0000241A  103C 0001               1642              MOVE.B  #1,D0        * move flag for first register
0000241E  6000 FF5C               1643              BRA     Pi_d3
00002422                          1644  
00002422  4EB9 00002708           1645  _d3         JSR     printSlash
00002428  14FC 0044               1646              MOVE.B  #'D',(A2)+
0000242C  14FC 0033               1647              MOVE.B  #'3',(A2)+
00002430  103C 0001               1648              MOVE.B  #1,D0        * move flag for first register
00002434  6000 FF4E               1649              BRA     Pi_d4
00002438                          1650  
00002438  4EB9 00002708           1651  _d4         JSR     printSlash
0000243E  14FC 0044               1652              MOVE.B  #'D',(A2)+
00002442  14FC 0034               1653              MOVE.B  #'4',(A2)+
00002446  103C 0001               1654              MOVE.B  #1,D0        * move flag for first register
0000244A  6000 FF40               1655              BRA     Pi_d5
0000244E                          1656  
0000244E  4EB9 00002708           1657  _d5         JSR     printSlash
00002454  14FC 0044               1658              MOVE.B  #'D',(A2)+
00002458  14FC 0035               1659              MOVE.B  #'5',(A2)+
0000245C  103C 0001               1660              MOVE.B  #1,D0        * move flag for first register
00002460  6000 FF32               1661              BRA     Pi_d6
00002464                          1662  
00002464  4EB9 00002708           1663  _d6         JSR     printSlash
0000246A  14FC 0044               1664              MOVE.B  #'D',(A2)+
0000246E  14FC 0036               1665              MOVE.B  #'6',(A2)+
00002472  103C 0001               1666              MOVE.B  #1,D0        * move flag for first register
00002476  6000 FF24               1667              BRA     Pi_d7
0000247A                          1668  
0000247A  4EB9 00002708           1669  _d7         JSR     printSlash
00002480  14FC 0044               1670              MOVE.B  #'D',(A2)+
00002484  14FC 0037               1671              MOVE.B  #'7',(A2)+
00002488  103C 0001               1672              MOVE.B  #1,D0        * move flag for first register
0000248C  6000 FF16               1673              BRA     Pi_a0
00002490                          1674  
00002490  4EB9 00002708           1675  _a0         JSR     printSlash
00002496  14FC 0041               1676              MOVE.B  #'A',(A2)+
0000249A  14FC 0030               1677              MOVE.B  #'0',(A2)+
0000249E  103C 0001               1678              MOVE.B  #1,D0        * move flag for first register
000024A2  6000 FF08               1679              BRA     Pi_a1
000024A6                          1680  
000024A6  4EB9 00002708           1681  _a1         JSR     printSlash
000024AC  14FC 0041               1682              MOVE.B  #'A',(A2)+
000024B0  14FC 0031               1683              MOVE.B  #'1',(A2)+
000024B4  103C 0001               1684              MOVE.B  #1,D0        * move flag for first register
000024B8  6000 FEFA               1685              BRA     Pi_a2
000024BC                          1686  
000024BC  4EB9 00002708           1687  _a2         JSR     printSlash
000024C2  14FC 0041               1688              MOVE.B  #'A',(A2)+
000024C6  14FC 0032               1689              MOVE.B  #'2',(A2)+
000024CA  103C 0001               1690              MOVE.B  #1,D0        * move flag for first register
000024CE  6000 FEEC               1691              BRA     Pi_a3
000024D2                          1692  
000024D2  4EB9 00002708           1693  _a3         JSR     printSlash
000024D8  14FC 0041               1694              MOVE.B  #'A',(A2)+
000024DC  14FC 0033               1695              MOVE.B  #'3',(A2)+
000024E0  103C 0001               1696              MOVE.B  #1,D0        * move flag for first register
000024E4  6000 FEDE               1697              BRA     Pi_a4
000024E8                          1698  
000024E8  4EB9 00002708           1699  _a4         JSR     printSlash
000024EE  14FC 0041               1700              MOVE.B  #'A',(A2)+
000024F2  14FC 0034               1701              MOVE.B  #'4',(A2)+
000024F6  103C 0001               1702              MOVE.B  #1,D0        * move flag for first register
000024FA  6000 FED0               1703              BRA     Pi_a5
000024FE                          1704  
000024FE  4EB9 00002708           1705  _a5         JSR     printSlash
00002504  14FC 0041               1706              MOVE.B  #'A',(A2)+
00002508  14FC 0035               1707              MOVE.B  #'5',(A2)+
0000250C  103C 0001               1708              MOVE.B  #1,D0        * move flag for first register
00002510  6000 FEC2               1709              BRA     Pi_a6
00002514                          1710  
00002514  4EB9 00002708           1711  _a6         JSR     printSlash
0000251A  14FC 0041               1712              MOVE.B  #'A',(A2)+
0000251E  14FC 0036               1713              MOVE.B  #'6',(A2)+
00002522  103C 0001               1714              MOVE.B  #1,D0        * move flag for first register
00002526  6000 FEB4               1715              BRA     Pi_a7
0000252A                          1716  
0000252A  4EB9 00002708           1717  _a7         JSR     printSlash
00002530  14FC 0041               1718              MOVE.B  #'A',(A2)+
00002534  14FC 0037               1719              MOVE.B  #'7',(A2)+
00002538  4E75                    1720              RTS
0000253A                          1721              
0000253A                          1722              
0000253A                          1723  PreDec
0000253A  3614                    1724              MOVE.W  (A4),D3     * move the next word into D3
0000253C                          1725              
0000253C  0803 0000               1726              BTST.L  #$00,D3     * A0
00002540  6600 0118               1727              BNE     _PDa0
00002544                          1728              
00002544  0803 0001               1729  Pd_a1       BTST.L  #$01,D3     * A1
00002548  6600 0126               1730              BNE     _PDa1
0000254C  0803 0002               1731  Pd_a2       BTST.L  #$02,D3     * A2
00002550  6600 0134               1732              BNE     _PDa2
00002554  0803 0003               1733  Pd_a3       BTST.L  #$03,D3     * A3
00002558  6600 0142               1734              BNE     _PDa3
0000255C  0803 0004               1735  Pd_a4       BTST.L  #$04,D3     * A4
00002560  6600 0150               1736              BNE     _PDa4
00002564  0803 0005               1737  Pd_a5       BTST.L  #$05,D3     * A5
00002568  6600 015E               1738              BNE     _PDa5
0000256C  0803 0006               1739  Pd_a6       BTST.L  #$06,D3     * A6
00002570  6600 016C               1740              BNE     _PDa6
00002574  0803 0007               1741  Pd_a7       BTST.L  #$07,D3     * A7
00002578  6600 017A               1742              BNE     _PDa7
0000257C  0803 0008               1743  Pd_d0       BTST.L  #$08,D3     * D0
00002580  6600 003C               1744              BNE     _PDd0
00002584  0803 0009               1745  Pd_d1       BTST.L  #$09,D3     * D1
00002588  6600 0042               1746              BNE     _PDd1
0000258C  0803 000A               1747  Pd_d2       BTST.L  #$0A,D3     * D2
00002590  6600 004E               1748              BNE     _PDd2
00002594  0803 000B               1749  Pd_d3       BTST.L  #$0B,D3     * D3
00002598  6600 005A               1750              BNE     _PDd3
0000259C  0803 000C               1751  Pd_d4       BTST.L  #$0C,D3     * D4
000025A0  6600 0066               1752              BNE     _PDd4
000025A4  0803 000D               1753  Pd_d5       BTST.L  #$0D,D3     * D5
000025A8  6600 0072               1754              BNE     _PDd5
000025AC  0803 000E               1755  Pd_d6       BTST.L  #$0E,D3     * D6
000025B0  6600 0080               1756              BNE     _PDd6
000025B4  0803 000F               1757  Pd_d7       BTST.L  #$0F,D3     * D7
000025B8  6600 008E               1758              BNE     _PDd7
000025BC                          1759  
000025BC  4E75                    1760              RTS
000025BE                          1761              
000025BE                          1762              
000025BE  14FC 0044               1763  _PDd0         MOVE.B  #'D',(A2)+
000025C2  14FC 0030               1764              MOVE.B  #'0',(A2)+
000025C6  103C 0001               1765              MOVE.B  #1,D0        * move flag for first register
000025CA  60B8                    1766              BRA     Pd_d1
000025CC                          1767  
000025CC  4EB9 00002708           1768  _PDd1         JSR     printSlash
000025D2  14FC 0044               1769              MOVE.B  #'D',(A2)+
000025D6  14FC 0031               1770              MOVE.B  #'1',(A2)+
000025DA  103C 0001               1771              MOVE.B  #1,D0        * move flag for first register
000025DE  60AC                    1772              BRA     Pd_d2
000025E0                          1773  
000025E0  4EB9 00002708           1774  _PDd2         JSR     printSlash
000025E6  14FC 0044               1775              MOVE.B  #'D',(A2)+
000025EA  14FC 0032               1776              MOVE.B  #'2',(A2)+
000025EE  103C 0001               1777              MOVE.B  #1,D0        * move flag for first register
000025F2  60A0                    1778              BRA     Pd_d3
000025F4                          1779  
000025F4  4EB9 00002708           1780  _PDd3         JSR     printSlash
000025FA  14FC 0044               1781              MOVE.B  #'D',(A2)+
000025FE  14FC 0033               1782              MOVE.B  #'3',(A2)+
00002602  103C 0001               1783              MOVE.B  #1,D0        * move flag for first register
00002606  6094                    1784              BRA     Pd_d4
00002608                          1785  
00002608  4EB9 00002708           1786  _PDd4         JSR     printSlash
0000260E  14FC 0044               1787              MOVE.B  #'D',(A2)+
00002612  14FC 0034               1788              MOVE.B  #'4',(A2)+
00002616  103C 0001               1789              MOVE.B  #1,D0        * move flag for first register
0000261A  6088                    1790              BRA     Pd_d5
0000261C                          1791  
0000261C  4EB9 00002708           1792  _PDd5         JSR     printSlash
00002622  14FC 0044               1793              MOVE.B  #'D',(A2)+
00002626  14FC 0035               1794              MOVE.B  #'5',(A2)+
0000262A  103C 0001               1795              MOVE.B  #1,D0        * move flag for first register
0000262E  6000 FF7C               1796              BRA     Pd_d6
00002632                          1797  
00002632  4EB9 00002708           1798  _PDd6         JSR     printSlash
00002638  14FC 0044               1799              MOVE.B  #'D',(A2)+
0000263C  14FC 0036               1800              MOVE.B  #'6',(A2)+
00002640  103C 0001               1801              MOVE.B  #1,D0        * move flag for first register
00002644  6000 FF6E               1802              BRA     Pd_d7
00002648                          1803  
00002648  4EB9 00002708           1804  _PDd7         JSR     printSlash
0000264E  14FC 0044               1805              MOVE.B  #'D',(A2)+
00002652  14FC 0037               1806              MOVE.B  #'7',(A2)+
00002656  103C 0001               1807              MOVE.B  #1,D0        * move flag for first register
0000265A                          1808              
0000265A                          1809  
0000265A  4EB9 00002708           1810  _PDa0         JSR     printSlash
00002660  14FC 0041               1811              MOVE.B  #'A',(A2)+
00002664  14FC 0030               1812              MOVE.B  #'0',(A2)+
00002668  103C 0001               1813              MOVE.B  #1,D0        * move flag for first register
0000266C  6000 FED6               1814              BRA     Pd_a1
00002670                          1815  
00002670  4EB9 00002708           1816  _PDa1         JSR     printSlash
00002676  14FC 0041               1817              MOVE.B  #'A',(A2)+
0000267A  14FC 0031               1818              MOVE.B  #'1',(A2)+
0000267E  103C 0001               1819              MOVE.B  #1,D0        * move flag for first register
00002682  6000 FEC8               1820              BRA     Pd_a2
00002686                          1821  
00002686  4EB9 00002708           1822  _PDa2         JSR     printSlash
0000268C  14FC 0041               1823              MOVE.B  #'A',(A2)+
00002690  14FC 0032               1824              MOVE.B  #'2',(A2)+
00002694  103C 0001               1825              MOVE.B  #1,D0        * move flag for first register
00002698  6000 FEBA               1826              BRA     Pd_a3
0000269C                          1827  
0000269C  4EB9 00002708           1828  _PDa3         JSR     printSlash
000026A2  14FC 0041               1829              MOVE.B  #'A',(A2)+
000026A6  14FC 0033               1830              MOVE.B  #'3',(A2)+
000026AA  103C 0001               1831              MOVE.B  #1,D0        * move flag for first register
000026AE  6000 FEAC               1832              BRA     Pd_a4
000026B2                          1833  
000026B2  4EB9 00002708           1834  _PDa4         JSR     printSlash
000026B8  14FC 0041               1835              MOVE.B  #'A',(A2)+
000026BC  14FC 0034               1836              MOVE.B  #'4',(A2)+
000026C0  103C 0001               1837              MOVE.B  #1,D0        * move flag for first register
000026C4  6000 FE9E               1838              BRA     Pd_a5
000026C8                          1839  
000026C8  4EB9 00002708           1840  _PDa5         JSR     printSlash
000026CE  14FC 0041               1841              MOVE.B  #'A',(A2)+
000026D2  14FC 0035               1842              MOVE.B  #'5',(A2)+
000026D6  103C 0001               1843              MOVE.B  #1,D0        * move flag for first register
000026DA  6000 FE90               1844              BRA     Pd_a6
000026DE                          1845  
000026DE  4EB9 00002708           1846  _PDa6         JSR     printSlash
000026E4  14FC 0041               1847              MOVE.B  #'A',(A2)+
000026E8  14FC 0036               1848              MOVE.B  #'6',(A2)+
000026EC  103C 0001               1849              MOVE.B  #1,D0        * move flag for first register
000026F0  6000 FE82               1850              BRA     Pd_a7
000026F4                          1851  
000026F4  4EB9 00002708           1852  _PDa7         JSR     printSlash
000026FA  14FC 0041               1853              MOVE.B  #'A',(A2)+
000026FE  14FC 0037               1854              MOVE.B  #'7',(A2)+
00002702  6000 FEB0               1855              BRA     Pd_d7
00002706  4E75                    1856              RTS
00002708                          1857  
00002708                          1858         
00002708                          1859  printSlash
00002708  0C00 0001               1860              CMPI.B  #1,D0       * see if a register has been added to the list
0000270C  6600 0006               1861              BNE     prtSlashDn    * if not, do not add slash
00002710  14FC 002F               1862              MOVE.B  #'/',(A2)+      * else add slash
00002714  4E75                    1863  prtSlashDn  RTS
00002716                          1864              
00002716                          1865              
00002716                          1866              
00002716                          1867                                                 
00002716                          1868  
00002716                          1869  * CLR ------------------------------------------------------------------------------
00002716  E98B                    1870  _clr        LSL.L   #4,D3   * shift out 4 bits to isolate size bit on the front
00002718  4EB8 1582               1871              JSR     BitTst2
0000271C  E58B                    1872              LSL.L   #2,D3   * shift out 2 size bits for error checking
0000271E  0C06 0000               1873              CMPI.B  #%00,D6
00002722  6700 0012               1874              BEQ     _clrB   * CLR.B
00002726  0C06 0001               1875              CMPI.B  #%01,D6
0000272A  6700 0074               1876              BEQ     _clrW   * CLR.W
0000272E  0C06 0002               1877              CMPI.B  #%10,D6
00002732  6700 00D6               1878              BEQ     _clrL   * CLR.L
00002736                          1879              
00002736                          1880  * CLR.B ----------------------
00002736                          1881  _clrB       
00002736  1E3C 0001               1882              MOVE.B  #1,D7       * indicate a byte instruction
0000273A  264A                    1883              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000273C  14FC 0043               1884              MOVE.B  #'C',(A2)+
00002740  14FC 004C               1885              MOVE.B  #'L',(A2)+
00002744  14FC 0052               1886              MOVE.B  #'R',(A2)+
00002748  14FC 002E               1887              MOVE.B  #'.',(A2)+
0000274C  14FC 0042               1888              MOVE.B  #'B',(A2)+
00002750  14FC 0020               1889              MOVE.B  #' ',(A2)+
00002754  14FC 0020               1890              MOVE.B  #' ',(A2)+
00002758  14FC 0020               1891              MOVE.B  #' ',(A2)+
0000275C  14FC 0020               1892              MOVE.B  #' ',(A2)+
00002760  14FC 0020               1893              MOVE.B  #' ',(A2)+
00002764                          1894              
00002764                          1895              * get EA 
00002764  4EB8 1638               1896              JSR     getMode
00002768  0C06 0001               1897              CMPI.B  #%001,D6    * cant clear address registers
0000276C  6700 20F0               1898              BEQ     OPERROR     * branch to error
00002770                          1899              
00002770  E74E                    1900              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002772  1A06                    1901              MOVE.B  D6,D5       * hold destination mode bits in d5
00002774  E78B                    1902              LSL.L   #3,D3       * shift destination mode bits out
00002776  4EB8 1560               1903              JSR     BitTst3     * test the destination register bits
0000277A  DA46                    1904              ADD.W   D6,D5       * add these to the mode bits
0000277C  0C05 003C               1905              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002780  6700 20DC               1906              BEQ     OPERROR     * immediate data, there is not allowed, error
00002784                          1907              
00002784                          1908              * no errors so get the mode again and load the EA table
00002784  4EB8 1638               1909              JSR     getMode
00002788  4DF9 000048CE           1910              LEA     eaTable,A6
0000278E  CCFC 0008               1911              MULU    #8,D6
00002792  4EB6 6000               1912              JSR     (A6,D6)
00002796                          1913              * check for error in EA
00002796  0C07 0004               1914              CMPI.B  #4,D7
0000279A  6700 20C2               1915              BEQ     OPERROR
0000279E  4E75                    1916              RTS
000027A0                          1917              
000027A0                          1918  * CLR.W ----------------------            
000027A0                          1919  _clrW       
000027A0  1E3C 0002               1920              MOVE.B  #2,D7       * indicate a word instruction
000027A4  264A                    1921              MOVEA.L A2,A3       * copy current address of A2 string to A3
000027A6  14FC 0043               1922              MOVE.B  #'C',(A2)+
000027AA  14FC 004C               1923              MOVE.B  #'L',(A2)+
000027AE  14FC 0052               1924              MOVE.B  #'R',(A2)+
000027B2  14FC 002E               1925              MOVE.B  #'.',(A2)+
000027B6  14FC 0057               1926              MOVE.B  #'W',(A2)+
000027BA  14FC 0020               1927              MOVE.B  #' ',(A2)+
000027BE  14FC 0020               1928              MOVE.B  #' ',(A2)+
000027C2  14FC 0020               1929              MOVE.B  #' ',(A2)+
000027C6  14FC 0020               1930              MOVE.B  #' ',(A2)+
000027CA  14FC 0020               1931              MOVE.B  #' ',(A2)+
000027CE                          1932              * get EA 
000027CE  4EB8 1638               1933              JSR     getMode
000027D2  0C06 0001               1934              CMPI.B  #%001,D6    * cant clear address registers
000027D6  6700 2086               1935              BEQ     OPERROR     * branch to error
000027DA                          1936              
000027DA  E74E                    1937              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000027DC  1A06                    1938              MOVE.B  D6,D5       * hold destination mode bits in d5
000027DE  E78B                    1939              LSL.L   #3,D3       * shift destination mode bits out
000027E0  4EB8 1560               1940              JSR     BitTst3     * test the destination register bits
000027E4  DA46                    1941              ADD.W   D6,D5       * add these to the mode bits
000027E6  0C05 003C               1942              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000027EA  6700 2072               1943              BEQ     OPERROR     * immediate data, there is not allowed, error
000027EE                          1944              
000027EE  4EB8 1638               1945              JSR     getMode
000027F2  4DF9 000048CE           1946              LEA     eaTable,A6
000027F8  CCFC 0008               1947              MULU    #8,D6
000027FC  4EB6 6000               1948              JSR     (A6,D6)
00002800                          1949              * check for error in EA
00002800  0C07 0004               1950              CMPI.B  #4,D7
00002804  6700 2058               1951              BEQ     OPERROR
00002808  4E75                    1952              RTS
0000280A                          1953              
0000280A                          1954  * CLR.L ----------------------            
0000280A                          1955  _clrL      
0000280A  1E3C 0003               1956              MOVE.B  #3,D7       * indicate a long instruction
0000280E  264A                    1957              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002810  14FC 0043               1958              MOVE.B  #'C',(A2)+
00002814  14FC 004C               1959              MOVE.B  #'L',(A2)+
00002818  14FC 0052               1960              MOVE.B  #'R',(A2)+
0000281C  14FC 002E               1961              MOVE.B  #'.',(A2)+
00002820  14FC 004C               1962              MOVE.B  #'L',(A2)+
00002824  14FC 0020               1963              MOVE.B  #' ',(A2)+
00002828  14FC 0020               1964              MOVE.B  #' ',(A2)+
0000282C  14FC 0020               1965              MOVE.B  #' ',(A2)+
00002830  14FC 0020               1966              MOVE.B  #' ',(A2)+
00002834  14FC 0020               1967              MOVE.B  #' ',(A2)+
00002838                          1968              * get EA 
00002838  4EB8 1638               1969              JSR     getMode
0000283C  0C06 0001               1970              CMPI.B  #%001,D6    * cant clear address registers
00002840  6700 201C               1971              BEQ     OPERROR     * branch to error
00002844                          1972              
00002844  E74E                    1973              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002846  1A06                    1974              MOVE.B  D6,D5       * hold destination mode bits in d5
00002848  E78B                    1975              LSL.L   #3,D3       * shift destination mode bits out
0000284A  4EB8 1560               1976              JSR     BitTst3     * test the destination register bits
0000284E  DA46                    1977              ADD.W   D6,D5       * add these to the mode bits
00002850  0C05 003C               1978              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002854  6700 2008               1979              BEQ     OPERROR     * immediate data, there is not allowed, error
00002858                          1980              
00002858                          1981              * no errors so get the mode again and load the EA table
00002858  4EB8 1638               1982              JSR     getMode
0000285C  4DF9 000048CE           1983              LEA     eaTable,A6
00002862  CCFC 0008               1984              MULU    #8,D6
00002866  4EB6 6000               1985              JSR     (A6,D6)
0000286A                          1986              * check for error in EA
0000286A  0C07 0004               1987              CMPI.B  #4,D7
0000286E  6700 1FEE               1988              BEQ     OPERROR
00002872                          1989              
00002872  4E75                    1990              RTS
00002874                          1991  
00002874                          1992  * ADDQ, SUBQ --------------------------------------------------------------------
00002874                          1993  op0101      
00002874  0803 0008               1994              BTST.L  #$08,D3 * test the 8th bit to check for ADDQ or SUBQ
00002878  6600 01CA               1995              BNE   _SubQ   * if 8th bit == 1, it is SUBQ instruction
0000287C                          1996              * else proceed as if it is an ADDQ instruction
0000287C  4843                    1997              SWAP    D3
0000287E  E18B                    1998              LSL.L   #8,D3   * shift out opcode & data to check for size
00002880  4EB8 1582               1999              JSR     BitTst2
00002884  2604                    2000              MOVE.L  D4,D3   * reset D3
00002886  4843                    2001              SWAP    D3      * send bits to front
00002888  E98B                    2002              LSL.L   #4,D3   * shift out opcode
0000288A  0C06 0000               2003              CMPI.B  #%00,D6  * go to ADDQ.B
0000288E  6700 0016               2004              BEQ     _AddQb
00002892  0C06 0001               2005              CMPI.B  #%01,D6  * go to ADDQ.W
00002896  6700 0098               2006              BEQ     _AddQw
0000289A  0C06 0002               2007              CMPI.B  #%10,D6  * go to ADDQ.L
0000289E  6700 011A               2008              BEQ     _AddQl
000028A2                          2009              
000028A2                          2010              * something unexpected/unsupported
000028A2  6000 1FBA               2011              BRA     OPERROR
000028A6                          2012              
000028A6                          2013  _AddQb      
000028A6  1E3C 0001               2014              MOVE.B  #1,D7       * indicate a byte instruction
000028AA  264A                    2015              MOVEA.L A2,A3       * copy current address of A2 string to A3
000028AC  14FC 0041               2016              MOVE.B  #'A',(A2)+
000028B0  14FC 0044               2017              MOVE.B  #'D',(A2)+
000028B4  14FC 0044               2018              MOVE.B  #'D',(A2)+
000028B8  14FC 0051               2019              MOVE.B  #'Q',(A2)+
000028BC  14FC 002E               2020              MOVE.B  #'.',(A2)+
000028C0  14FC 0042               2021              MOVE.B  #'B',(A2)+
000028C4  14FC 0020               2022              MOVE.B  #' ',(A2)+
000028C8  14FC 0020               2023              MOVE.B  #' ',(A2)+
000028CC  14FC 0020               2024              MOVE.B  #' ',(A2)+
000028D0  14FC 0020               2025              MOVE.B  #' ',(A2)+
000028D4  14FC 0023               2026              MOVE.B  #'#',(A2)+
000028D8                          2027              
000028D8  4EB8 1560               2028              JSR     BitTst3     * get the data value
000028DC  0C06 0000               2029              CMPI.B  #%000,D6    * if it is 000, add 8
000028E0  6600 0008               2030              BNE     AddQb       * if not, continue to next part
000028E4  4EB9 00002C0C           2031              JSR     Add8
000028EA  CCFC 0008               2032  AddQb       MULU    #8,D6       * multiply for offset
000028EE  4DF9 00004A6E           2033              LEA     numTable,A6 * load num table
000028F4  4EB6 6000               2034              JSR     (A6,D6)     * jump to table
000028F8                          2035                  
000028F8  14FC 002C               2036              MOVE.B  #',',(A2)+  * print comma
000028FC                          2037              
000028FC  4EB8 1638               2038              JSR     getMode     * get EA mode
00002900                          2039              
00002900  E74E                    2040              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002902  1A06                    2041              MOVE.B  D6,D5       * hold destination mode bits in d5
00002904  E78B                    2042              LSL.L   #3,D3       * shift destination mode bits out
00002906  4EB8 1560               2043              JSR     BitTst3     * test the destination register bits
0000290A  DA46                    2044              ADD.W   D6,D5       * add these to the mode bits
0000290C  0C05 003C               2045              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002910  6700 1F4C               2046              BEQ     OPERROR     * immediate data, there is not allowed, error
00002914                          2047  
00002914  4EB8 1638               2048              JSR     getMode
00002918  CCFC 0008               2049              MULU    #8,D6       * multiply for offset
0000291C  4DF9 000048CE           2050              LEA     eaTable,A6  * load e table
00002922  4EB6 6000               2051              JSR     (A6,D6)     * jump to table
00002926                          2052              * check for error in EA
00002926  0C07 0004               2053              CMPI.B  #4,D7
0000292A  6700 1F32               2054              BEQ     OPERROR
0000292E                          2055              
0000292E  4E75                    2056              RTS
00002930                          2057  
00002930                          2058  _AddQw      
00002930  1E3C 0002               2059              MOVE.B  #2,D7       * indicate a word instruction
00002934  264A                    2060              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002936  14FC 0041               2061              MOVE.B  #'A',(A2)+
0000293A  14FC 0044               2062              MOVE.B  #'D',(A2)+
0000293E  14FC 0044               2063              MOVE.B  #'D',(A2)+
00002942  14FC 0051               2064              MOVE.B  #'Q',(A2)+
00002946  14FC 002E               2065              MOVE.B  #'.',(A2)+
0000294A  14FC 0057               2066              MOVE.B  #'W',(A2)+
0000294E  14FC 0020               2067              MOVE.B  #' ',(A2)+
00002952  14FC 0020               2068              MOVE.B  #' ',(A2)+
00002956  14FC 0020               2069              MOVE.B  #' ',(A2)+
0000295A  14FC 0020               2070              MOVE.B  #' ',(A2)+
0000295E  14FC 0023               2071              MOVE.B  #'#',(A2)+
00002962                          2072              
00002962  4EB8 1560               2073              JSR     BitTst3     * get the data value
00002966  0C06 0000               2074              CMPI.B  #%000,D6    * if it is 000, add 8
0000296A  6600 0008               2075              BNE     AddQw       * if not, continue to next part
0000296E  4EB9 00002C0C           2076              JSR     Add8
00002974  CCFC 0008               2077  AddQw       MULU    #8,D6       * multiply for offset
00002978  4DF9 00004A6E           2078              LEA     numTable,A6 * load num table
0000297E  4EB6 6000               2079              JSR     (A6,D6)     * jump to table
00002982                          2080                  
00002982  14FC 002C               2081              MOVE.B  #',',(A2)+  * print comma
00002986                          2082              
00002986  4EB8 1638               2083              JSR     getMode     * get EA mode
0000298A  E74E                    2084              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000298C  1A06                    2085              MOVE.B  D6,D5       * hold destination mode bits in d5
0000298E  E78B                    2086              LSL.L   #3,D3       * shift destination mode bits out
00002990  4EB8 1560               2087              JSR     BitTst3     * test the destination register bits
00002994  DA46                    2088              ADD.W   D6,D5       * add these to the mode bits
00002996  0C05 003C               2089              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000299A  6700 1EC2               2090              BEQ     OPERROR     * immediate data, there is not allowed, error
0000299E                          2091              
0000299E  4EB8 1638               2092              JSR     getMode
000029A2  CCFC 0008               2093              MULU    #8,D6       * multiply for offset
000029A6  4DF9 000048CE           2094              LEA     eaTable,A6  * load e table
000029AC  4EB6 6000               2095              JSR     (A6,D6)     * jump to table
000029B0                          2096              * check for error in EA
000029B0  0C07 0004               2097              CMPI.B  #4,D7
000029B4  6700 1EA8               2098              BEQ     OPERROR
000029B8  4E75                    2099              RTS
000029BA                          2100              
000029BA                          2101  _AddQl      
000029BA  1E3C 0003               2102              MOVE.B  #3,D7       * indicate a long instruction
000029BE  264A                    2103              MOVEA.L A2,A3       * copy current address of A2 string to A3
000029C0  14FC 0041               2104              MOVE.B  #'A',(A2)+
000029C4  14FC 0044               2105              MOVE.B  #'D',(A2)+
000029C8  14FC 0044               2106              MOVE.B  #'D',(A2)+
000029CC  14FC 0051               2107              MOVE.B  #'Q',(A2)+
000029D0  14FC 002E               2108              MOVE.B  #'.',(A2)+
000029D4  14FC 004C               2109              MOVE.B  #'L',(A2)+
000029D8  14FC 0020               2110              MOVE.B  #' ',(A2)+
000029DC  14FC 0020               2111              MOVE.B  #' ',(A2)+
000029E0  14FC 0020               2112              MOVE.B  #' ',(A2)+
000029E4  14FC 0020               2113              MOVE.B  #' ',(A2)+
000029E8  14FC 0023               2114              MOVE.B  #'#',(A2)+
000029EC                          2115              
000029EC  4EB8 1560               2116              JSR     BitTst3     * get the data value
000029F0  0C06 0000               2117              CMPI.B  #%000,D6    * if it is 000, add 8
000029F4  6600 0008               2118              BNE     AddQl       * if not, continue to next part
000029F8  4EB9 00002C0C           2119              JSR     Add8
000029FE  CCFC 0008               2120  AddQl       MULU    #8,D6       * multiply for offset
00002A02  4DF9 00004A6E           2121              LEA     numTable,A6 * load num table
00002A08  4EB6 6000               2122              JSR     (A6,D6)     * jump to table
00002A0C                          2123                  
00002A0C  14FC 002C               2124              MOVE.B  #',',(A2)+  * print comma
00002A10                          2125              
00002A10  4EB8 1638               2126              JSR     getMode     * get EA mode
00002A14                          2127              
00002A14  E74E                    2128              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002A16  1A06                    2129              MOVE.B  D6,D5       * hold destination mode bits in d5
00002A18  E78B                    2130              LSL.L   #3,D3       * shift destination mode bits out
00002A1A  4EB8 1560               2131              JSR     BitTst3     * test the destination register bits
00002A1E  DA46                    2132              ADD.W   D6,D5       * add these to the mode bits
00002A20  0C05 003C               2133              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002A24  6700 1E38               2134              BEQ     OPERROR     * immediate data, there is not allowed, error
00002A28                          2135              
00002A28  4EB8 1638               2136              JSR     getMode
00002A2C  CCFC 0008               2137              MULU    #8,D6       * multiply for offset
00002A30  4DF9 000048CE           2138              LEA     eaTable,A6  * load e table
00002A36  4EB6 6000               2139              JSR     (A6,D6)     * jump to table
00002A3A                          2140              * check for error in EA
00002A3A  0C07 0004               2141              CMPI.B  #4,D7
00002A3E  6700 1E1E               2142              BEQ     OPERROR
00002A42                          2143              
00002A42  4E75                    2144              RTS
00002A44                          2145              
00002A44                          2146  * SUBQ ------------------------------------------------------------------------------            
00002A44                          2147  _SubQ       
00002A44  4843                    2148              SWAP    D3
00002A46  E18B                    2149              LSL.L   #8,D3   * shift out opcode & data to check for size
00002A48  4EB8 1582               2150              JSR     BitTst2
00002A4C  2604                    2151              MOVE.L  D4,D3   * reset D3
00002A4E  4843                    2152              SWAP    D3
00002A50  E98B                    2153              LSL.L   #4,D3   * shift out opcode
00002A52  0C06 0000               2154              CMPI.B  #%00,D6  * go to SUBQ.B
00002A56  6700 0016               2155              BEQ     _SubQb
00002A5A  0C06 0001               2156              CMPI.B  #%01,D6  * go to SUBQ.W
00002A5E  6700 0098               2157              BEQ     _SubQw
00002A62  0C06 0002               2158              CMPI.B  #%10,D6  * go to SUBQ.L
00002A66  6700 011A               2159              BEQ     _SubQl
00002A6A                          2160              
00002A6A                          2161              * something unexpected/unsupported
00002A6A  6000 1DF2               2162              BRA     OPERROR
00002A6E                          2163              
00002A6E                          2164  _SubQb      
00002A6E  1E3C 0001               2165              MOVE.B  #1,D7       * indicate a byte instruction
00002A72  264A                    2166              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002A74  14FC 0053               2167              MOVE.B  #'S',(A2)+
00002A78  14FC 0055               2168              MOVE.B  #'U',(A2)+
00002A7C  14FC 0042               2169              MOVE.B  #'B',(A2)+
00002A80  14FC 0051               2170              MOVE.B  #'Q',(A2)+
00002A84  14FC 002E               2171              MOVE.B  #'.',(A2)+
00002A88  14FC 0042               2172              MOVE.B  #'B',(A2)+
00002A8C  14FC 0020               2173              MOVE.B  #' ',(A2)+
00002A90  14FC 0020               2174              MOVE.B  #' ',(A2)+
00002A94  14FC 0020               2175              MOVE.B  #' ',(A2)+
00002A98  14FC 0020               2176              MOVE.B  #' ',(A2)+
00002A9C  14FC 0023               2177              MOVE.B  #'#',(A2)+
00002AA0                          2178              
00002AA0  4EB8 1560               2179              JSR     BitTst3     * get the data value
00002AA4  0C06 0000               2180              CMPI.B  #%000,D6    * if it is 000, add 8
00002AA8  6600 0008               2181              BNE     SubQb       * if not, continue to next part
00002AAC  4EB9 00002C0C           2182              JSR     Add8
00002AB2  CCFC 0008               2183  SubQb       MULU    #8,D6       * multiply for offset
00002AB6  4DF9 00004A6E           2184              LEA     numTable,A6 * load num table
00002ABC  4EB6 6000               2185              JSR     (A6,D6)     * jump to table
00002AC0                          2186                  
00002AC0  14FC 002C               2187              MOVE.B  #',',(A2)+  * print comma
00002AC4                          2188              
00002AC4  4EB8 1638               2189              JSR     getMode     * get EA mode
00002AC8  E74E                    2190              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002ACA  1A06                    2191              MOVE.B  D6,D5       * hold destination mode bits in d5
00002ACC  E78B                    2192              LSL.L   #3,D3       * shift destination mode bits out
00002ACE  4EB8 1560               2193              JSR     BitTst3     * test the destination register bits
00002AD2  DA46                    2194              ADD.W   D6,D5       * add these to the mode bits
00002AD4  0C05 003C               2195              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002AD8  6700 1D84               2196              BEQ     OPERROR     * immediate data, there is not allowed, error
00002ADC                          2197              
00002ADC  4EB8 1638               2198              JSR     getMode
00002AE0  CCFC 0008               2199              MULU    #8,D6       * multiply for offset
00002AE4  4DF9 000048CE           2200              LEA     eaTable,A6  * load e table
00002AEA  4EB6 6000               2201              JSR     (A6,D6)     * jump to table
00002AEE                          2202              * check for error in EA
00002AEE  0C07 0004               2203              CMPI.B  #4,D7
00002AF2  6700 1D6A               2204              BEQ     OPERROR
00002AF6  4E75                    2205              RTS
00002AF8                          2206  
00002AF8                          2207  _SubQw       
00002AF8  1E3C 0002               2208              MOVE.B  #2,D7       * indicate a word instruction
00002AFC  264A                    2209              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002AFE  14FC 0053               2210              MOVE.B  #'S',(A2)+
00002B02  14FC 0055               2211              MOVE.B  #'U',(A2)+
00002B06  14FC 0042               2212              MOVE.B  #'B',(A2)+
00002B0A  14FC 0051               2213              MOVE.B  #'Q',(A2)+
00002B0E  14FC 002E               2214              MOVE.B  #'.',(A2)+
00002B12  14FC 0057               2215              MOVE.B  #'W',(A2)+
00002B16  14FC 0020               2216              MOVE.B  #' ',(A2)+
00002B1A  14FC 0020               2217              MOVE.B  #' ',(A2)+
00002B1E  14FC 0020               2218              MOVE.B  #' ',(A2)+
00002B22  14FC 0020               2219              MOVE.B  #' ',(A2)+
00002B26  14FC 0023               2220              MOVE.B  #'#',(A2)+
00002B2A  4EB8 1560               2221              JSR     BitTst3     * get the data value
00002B2E  0C06 0000               2222              CMPI.B  #%000,D6    * if it is 000, add 8
00002B32  6600 0008               2223              BNE     SubQw       * if not, continue to next part
00002B36  4EB9 00002C0C           2224              JSR     Add8
00002B3C  CCFC 0008               2225  SubQw       MULU    #8,D6       * multiply for offset
00002B40  4DF9 00004A6E           2226              LEA     numTable,A6 * load num table
00002B46  4EB6 6000               2227              JSR     (A6,D6)     * jump to table
00002B4A                          2228                  
00002B4A  14FC 002C               2229              MOVE.B  #',',(A2)+  * print comma
00002B4E                          2230              
00002B4E  4EB8 1638               2231              JSR     getMode     * get EA mode
00002B52  E74E                    2232              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002B54  1A06                    2233              MOVE.B  D6,D5       * hold destination mode bits in d5
00002B56  E78B                    2234              LSL.L   #3,D3       * shift destination mode bits out
00002B58  4EB8 1560               2235              JSR     BitTst3     * test the destination register bits
00002B5C  DA46                    2236              ADD.W   D6,D5       * add these to the mode bits
00002B5E  0C05 003C               2237              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002B62  6700 1CFA               2238              BEQ     OPERROR     * immediate data, there is not allowed, error
00002B66                          2239      
00002B66  4EB8 1638               2240              JSR     getMode
00002B6A  CCFC 0008               2241              MULU    #8,D6       * multiply for offset
00002B6E  4DF9 000048CE           2242              LEA     eaTable,A6  * load e table
00002B74  4EB6 6000               2243              JSR     (A6,D6)     * jump to table
00002B78                          2244              * check for error in EA
00002B78  0C07 0004               2245              CMPI.B  #4,D7
00002B7C  6700 1CE0               2246              BEQ     OPERROR
00002B80                          2247              
00002B80  4E75                    2248              RTS
00002B82                          2249  
00002B82                          2250  _SubQl      
00002B82  1E3C 0003               2251              MOVE.B  #3,D7       * indicate a long instruction
00002B86  264A                    2252              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002B88  14FC 0053               2253              MOVE.B  #'S',(A2)+
00002B8C  14FC 0055               2254              MOVE.B  #'U',(A2)+
00002B90  14FC 0042               2255              MOVE.B  #'B',(A2)+
00002B94  14FC 0051               2256              MOVE.B  #'Q',(A2)+
00002B98  14FC 002E               2257              MOVE.B  #'.',(A2)+
00002B9C  14FC 004C               2258              MOVE.B  #'L',(A2)+
00002BA0  14FC 0020               2259              MOVE.B  #' ',(A2)+
00002BA4  14FC 0020               2260              MOVE.B  #' ',(A2)+
00002BA8  14FC 0020               2261              MOVE.B  #' ',(A2)+
00002BAC  14FC 0020               2262              MOVE.B  #' ',(A2)+
00002BB0  14FC 0023               2263              MOVE.B  #'#',(A2)+
00002BB4                          2264              
00002BB4  4EB8 1560               2265              JSR     BitTst3     * get the data value
00002BB8  0C06 0000               2266              CMPI.B  #%000,D6    * if it is 000, add 8
00002BBC  6600 0008               2267              BNE     SubQl       * if not, continue to next part
00002BC0  4EB9 00002C0C           2268              JSR     Add8
00002BC6  CCFC 0008               2269  SubQl       MULU    #8,D6       * multiply for offset
00002BCA  4DF9 00004A6E           2270              LEA     numTable,A6 * load num table
00002BD0  4EB6 6000               2271              JSR     (A6,D6)     * jump to table
00002BD4                          2272                  
00002BD4  14FC 002C               2273              MOVE.B  #',',(A2)+  * print comma
00002BD8                          2274              
00002BD8  4EB8 1638               2275              JSR     getMode     * get EA mode
00002BDC  E74E                    2276              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002BDE  1A06                    2277              MOVE.B  D6,D5       * hold destination mode bits in d5
00002BE0  E78B                    2278              LSL.L   #3,D3       * shift destination mode bits out
00002BE2  4EB8 1560               2279              JSR     BitTst3     * test the destination register bits
00002BE6  DA46                    2280              ADD.W   D6,D5       * add these to the mode bits
00002BE8  0C05 003C               2281              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002BEC  6700 1C70               2282              BEQ     OPERROR     * immediate data, there is not allowed, error
00002BF0                          2283      
00002BF0  4EB8 1638               2284              JSR     getMode
00002BF4  CCFC 0008               2285              MULU    #8,D6       * multiply for offset
00002BF8  4DF9 000048CE           2286              LEA     eaTable,A6  * load e table
00002BFE  4EB6 6000               2287              JSR     (A6,D6)     * jump to table
00002C02                          2288              * check for error in EA
00002C02  0C07 0004               2289              CMPI.B  #4,D7
00002C06  6700 1C56               2290              BEQ     OPERROR
00002C0A                          2291              
00002C0A  4E75                    2292              RTS
00002C0C                          2293  **************************************************************************************
00002C0C                          2294  * Add 8 - subroutine that adds 8 if the data value in instruction code is 000.
00002C0C                          2295  * Used for SUBQ and ADDQ.
00002C0C                          2296  **************************************************************************************
00002C0C                          2297  Add8        
00002C0C  5006                    2298              ADDI.B  #8,D6   * add 8 to d6
00002C0E  4E75                    2299              RTS             * return
00002C10                          2300   
00002C10                          2301  * Bcc (BRA/BCC/BLT/BGE) --------------------------------------------------------------
00002C10                          2302  op0110      
00002C10  4843                    2303              SWAP    D3
00002C12  E98B                    2304              LSL.L   #4,D3        * shift out opcode
00002C14  4EB8 1534               2305              JSR     BITTEST      * test next four bits for condition
00002C18  0C06 0000               2306              CMPI.B  #%0000,D6
00002C1C  6700 003E               2307              BEQ     _Bra         * check BRA condition
00002C20  0C06 0004               2308              CMPI.B  #%0100,D6
00002C24  6700 007A               2309              BEQ     _Bcc         * check BCC condition
00002C28  0C06 0005               2310              CMPI.B  #%0101,D6
00002C2C  6700 00B6               2311              BEQ     _Bcs         * check BCS condition
00002C30  0C06 0006               2312              CMPI.B  #%0110,D6
00002C34  6700 00F2               2313              BEQ     _Bne         * check BNE condition
00002C38  0C06 000C               2314              CMPI.B  #%1100,D6
00002C3C  6700 012E               2315              BEQ     _Bge         * check BGE condition
00002C40  0C06 000D               2316              CMPI.B  #%1101,D6
00002C44  6700 016A               2317              BEQ     _Blt         * check BLT condition
00002C48  0C06 000E               2318              CMPI.B  #%1110,D6
00002C4C  6700 01A6               2319              BEQ     _Bgt         * check BGT condition
00002C50  0C06 000F               2320              CMPI.B  #%1111,D6
00002C54  6700 01E2               2321              BEQ     _Ble         * check BLE condition
00002C58                          2322              
00002C58                          2323              * branch to unsupported/error
00002C58  6000 1C04               2324              BRA     OPERROR
00002C5C                          2325              
00002C5C                          2326  * BRA ------------------------
00002C5C  14FC 0042               2327  _Bra        MOVE.B  #'B',(A2)+      * add BRA to A2 string
00002C60  14FC 0052               2328              MOVE.B  #'R',(A2)+
00002C64  14FC 0041               2329              MOVE.B  #'A',(A2)+
00002C68  14FC 0020               2330              MOVE.B  #' ',(A2)+
00002C6C  14FC 0020               2331              MOVE.B  #' ',(A2)+
00002C70  14FC 0020               2332              MOVE.B  #' ',(A2)+
00002C74  14FC 0020               2333              MOVE.B  #' ',(A2)+
00002C78  14FC 0020               2334              MOVE.B  #' ',(A2)+
00002C7C  14FC 0020               2335              MOVE.B  #' ',(A2)+
00002C80  14FC 0020               2336              MOVE.B  #' ',(A2)+
00002C84  14FC 0024               2337              MOVE.B  #'$',(A2)+
00002C88  4243                    2338              CLR     D3
00002C8A  1604                    2339              MOVE.B  D4,D3
00002C8C  0C03 0000               2340              CMPI.B  #$00,D3     * branch of 16 bit offset
00002C90  6700 01EA               2341              BEQ     _WordDisp
00002C94  0C03 00FF               2342              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002C98  6700 01E8               2343              BEQ     _LongDisp
00002C9C  6000 01EA               2344              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002CA0                          2345              
00002CA0                          2346  * BCC ------------------------
00002CA0  14FC 0042               2347  _Bcc        MOVE.B  #'B',(A2)+      * add BCC to A2 String
00002CA4  14FC 0043               2348              MOVE.B  #'C',(A2)+
00002CA8  14FC 0043               2349              MOVE.B  #'C',(A2)+
00002CAC  14FC 0020               2350              MOVE.B  #' ',(A2)+
00002CB0  14FC 0020               2351              MOVE.B  #' ',(A2)+
00002CB4  14FC 0020               2352              MOVE.B  #' ',(A2)+
00002CB8  14FC 0020               2353              MOVE.B  #' ',(A2)+
00002CBC  14FC 0020               2354              MOVE.B  #' ',(A2)+
00002CC0  14FC 0020               2355              MOVE.B  #' ',(A2)+
00002CC4  14FC 0020               2356              MOVE.B  #' ',(A2)+
00002CC8  14FC 0024               2357              MOVE.B  #'$',(A2)+
00002CCC  4243                    2358              CLR     D3
00002CCE  1604                    2359              MOVE.B  D4,D3
00002CD0  0C03 0000               2360              CMPI.B  #$00,D3     * branch of 16 bit offset
00002CD4  6700 01A6               2361              BEQ     _WordDisp
00002CD8  0C03 00FF               2362              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002CDC  6700 01A4               2363              BEQ     _LongDisp
00002CE0  6000 01A6               2364              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002CE4                          2365              
00002CE4                          2366  * BCS ------------------------
00002CE4                          2367  _Bcs
00002CE4  14FC 0042               2368              MOVE.B  #'B',(A2)+      * add BCS to A2 string
00002CE8  14FC 0043               2369              MOVE.B  #'C',(A2)+
00002CEC  14FC 0053               2370              MOVE.B  #'S',(A2)+
00002CF0  14FC 0020               2371              MOVE.B  #' ',(A2)+
00002CF4  14FC 0020               2372              MOVE.B  #' ',(A2)+
00002CF8  14FC 0020               2373              MOVE.B  #' ',(A2)+
00002CFC  14FC 0020               2374              MOVE.B  #' ',(A2)+
00002D00  14FC 0020               2375              MOVE.B  #' ',(A2)+
00002D04  14FC 0020               2376              MOVE.B  #' ',(A2)+
00002D08  14FC 0020               2377              MOVE.B  #' ',(A2)+
00002D0C  14FC 0024               2378              MOVE.B  #'$',(A2)+
00002D10  4243                    2379              CLR     D3
00002D12  1604                    2380              MOVE.B  D4,D3
00002D14  0C03 0000               2381              CMPI.B  #$00,D3     * branch of 16 bit offset
00002D18  6700 0162               2382              BEQ     _WordDisp
00002D1C  0C03 00FF               2383              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002D20  6700 0160               2384              BEQ     _LongDisp
00002D24  6000 0162               2385              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002D28                          2386              
00002D28                          2387  * BNE ------------------------
00002D28                          2388  _Bne  
00002D28  14FC 0042               2389              MOVE.B  #'B',(A2)+      * add BNE to A2 string
00002D2C  14FC 0052               2390              MOVE.B  #'R',(A2)+
00002D30  14FC 0041               2391              MOVE.B  #'A',(A2)+
00002D34  14FC 0020               2392              MOVE.B  #' ',(A2)+
00002D38  14FC 0020               2393              MOVE.B  #' ',(A2)+
00002D3C  14FC 0020               2394              MOVE.B  #' ',(A2)+
00002D40  14FC 0020               2395              MOVE.B  #' ',(A2)+
00002D44  14FC 0020               2396              MOVE.B  #' ',(A2)+
00002D48  14FC 0020               2397              MOVE.B  #' ',(A2)+
00002D4C  14FC 0020               2398              MOVE.B  #' ',(A2)+
00002D50  14FC 0024               2399              MOVE.B  #'$',(A2)+
00002D54  4243                    2400              CLR     D3
00002D56  1604                    2401              MOVE.B  D4,D3
00002D58  0C03 0000               2402              CMPI.B  #$00,D3     * branch of 16 bit offset
00002D5C  6700 011E               2403              BEQ     _WordDisp
00002D60  0C03 00FF               2404              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002D64  6700 011C               2405              BEQ     _LongDisp
00002D68  6000 011E               2406              BRA     _ByteDisp   * branch defaults to 8 bit offset 
00002D6C                          2407              
00002D6C                          2408  * BGE ------------------------
00002D6C  14FC 0042               2409  _Bge        MOVE.B  #'B',(A2)+      * add BGE to A2 string
00002D70  14FC 0047               2410              MOVE.B  #'G',(A2)+
00002D74  14FC 0045               2411              MOVE.B  #'E',(A2)+
00002D78  14FC 0020               2412              MOVE.B  #' ',(A2)+
00002D7C  14FC 0020               2413              MOVE.B  #' ',(A2)+
00002D80  14FC 0020               2414              MOVE.B  #' ',(A2)+
00002D84  14FC 0020               2415              MOVE.B  #' ',(A2)+
00002D88  14FC 0020               2416              MOVE.B  #' ',(A2)+
00002D8C  14FC 0020               2417              MOVE.B  #' ',(A2)+
00002D90  14FC 0020               2418              MOVE.B  #' ',(A2)+
00002D94  14FC 0024               2419              MOVE.B  #'$',(A2)+
00002D98  4243                    2420              CLR     D3
00002D9A  1604                    2421              MOVE.B  D4,D3
00002D9C  0C03 0000               2422              CMPI.B  #$00,D3     * branch of 16 bit offset
00002DA0  6700 00DA               2423              BEQ     _WordDisp
00002DA4  0C03 00FF               2424              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002DA8  6700 00D8               2425              BEQ     _LongDisp
00002DAC  6000 00DA               2426              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002DB0                          2427              
00002DB0                          2428              
00002DB0                          2429  * BLT ------------------------
00002DB0  14FC 0042               2430  _Blt        MOVE.B  #'B',(A2)+      * add BLT to A2 String
00002DB4  14FC 004C               2431              MOVE.B  #'L',(A2)+
00002DB8  14FC 0054               2432              MOVE.B  #'T',(A2)+
00002DBC  14FC 0020               2433              MOVE.B  #' ',(A2)+
00002DC0  14FC 0020               2434              MOVE.B  #' ',(A2)+
00002DC4  14FC 0020               2435              MOVE.B  #' ',(A2)+
00002DC8  14FC 0020               2436              MOVE.B  #' ',(A2)+
00002DCC  14FC 0020               2437              MOVE.B  #' ',(A2)+
00002DD0  14FC 0020               2438              MOVE.B  #' ',(A2)+
00002DD4  14FC 0020               2439              MOVE.B  #' ',(A2)+
00002DD8  14FC 0024               2440              MOVE.B  #'$',(A2)+
00002DDC  4243                    2441              CLR     D3
00002DDE  1604                    2442              MOVE.B  D4,D3
00002DE0  0C03 0000               2443              CMPI.B  #$00,D3     * branch of 16 bit offset
00002DE4  6700 0096               2444              BEQ     _WordDisp
00002DE8  0C03 00FF               2445              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002DEC  6700 0094               2446              BEQ     _LongDisp
00002DF0  6000 0096               2447              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002DF4                          2448              
00002DF4                          2449  * BGT -------------------------            
00002DF4                          2450  _Bgt
00002DF4  14FC 0042               2451              MOVE.B  #'B',(A2)+      * add BGT to A2 string
00002DF8  14FC 0052               2452              MOVE.B  #'R',(A2)+
00002DFC  14FC 0041               2453              MOVE.B  #'A',(A2)+
00002E00  14FC 0020               2454              MOVE.B  #' ',(A2)+
00002E04  14FC 0020               2455              MOVE.B  #' ',(A2)+
00002E08  14FC 0020               2456              MOVE.B  #' ',(A2)+
00002E0C  14FC 0020               2457              MOVE.B  #' ',(A2)+
00002E10  14FC 0020               2458              MOVE.B  #' ',(A2)+
00002E14  14FC 0020               2459              MOVE.B  #' ',(A2)+
00002E18  14FC 0020               2460              MOVE.B  #' ',(A2)+
00002E1C  14FC 0024               2461              MOVE.B  #'$',(A2)+
00002E20  4243                    2462              CLR     D3
00002E22  1604                    2463              MOVE.B  D4,D3
00002E24  0C03 0000               2464              CMPI.B  #$00,D3     * branch of 16 bit offset
00002E28  6700 0052               2465              BEQ     _WordDisp
00002E2C  0C03 00FF               2466              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002E30  6700 0050               2467              BEQ     _LongDisp
00002E34  6000 0052               2468              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002E38                          2469  * BLE -------------------------
00002E38                          2470  _Ble
00002E38  14FC 0042               2471              MOVE.B  #'B',(A2)+      * add BLE to A2 string
00002E3C  14FC 004C               2472              MOVE.B  #'L',(A2)+
00002E40  14FC 0045               2473              MOVE.B  #'E',(A2)+
00002E44  14FC 0020               2474              MOVE.B  #' ',(A2)+
00002E48  14FC 0020               2475              MOVE.B  #' ',(A2)+
00002E4C  14FC 0020               2476              MOVE.B  #' ',(A2)+
00002E50  14FC 0020               2477              MOVE.B  #' ',(A2)+
00002E54  14FC 0020               2478              MOVE.B  #' ',(A2)+
00002E58  14FC 0020               2479              MOVE.B  #' ',(A2)+
00002E5C  14FC 0020               2480              MOVE.B  #' ',(A2)+
00002E60  14FC 0024               2481              MOVE.B  #'$',(A2)+
00002E64  4243                    2482              CLR     D3
00002E66  1604                    2483              MOVE.B  D4,D3
00002E68  0C03 0000               2484              CMPI.B  #$00,D3     * branch of 16 bit offset
00002E6C  6700 000E               2485              BEQ     _WordDisp
00002E70  0C03 00FF               2486              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002E74  6700 000C               2487              BEQ     _LongDisp
00002E78  6000 000E               2488              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002E7C                          2489  
00002E7C                          2490  **************************************************************************
00002E7C                          2491  * Functions that handle the different types of displacements for a branch
00002E7C                          2492  **************************************************************************
00002E7C                          2493  * Displacement is a word length
00002E7C                          2494  _WordDisp
00002E7C  4EB8 15DA               2495              JSR     printWord
00002E80  4E75                    2496              RTS
00002E82                          2497  * Displacement is long length
00002E82                          2498  _LongDisp
00002E82  4EB8 1608               2499              JSR     printLong
00002E86  4E75                    2500              RTS
00002E88                          2501  * Displacement is byte length
00002E88                          2502  _ByteDisp  
00002E88  4242                    2503              CLR     D2
00002E8A  4DF9 00004A6E           2504              LEA     numTable,A6
00002E90  4843                    2505              SWAP    D3
00002E92  E18B                    2506              LSL.L   #8,D3
00002E94                          2507              
00002E94  0C02 0002               2508  ByteDispLp  CMPI.B  #2,D2       * loop through twice,
00002E98  6700 0014               2509              BEQ     dispDone    * print done
00002E9C  4EB8 1534               2510              JSR     BITTEST     * get leading 4 bits
00002EA0  CCFC 0008               2511              MULU    #8,D6       * multiply by 8 for jump offset 
00002EA4  4EB6 6000               2512              JSR     (A6,D6)     * get number from table and add to A2 string
00002EA8  E98B                    2513              LSL.L   #4,D3       * shift out the 4 bits were done with
00002EAA  5242                    2514              ADDQ    #1,D2       * increment loop counter
00002EAC  60E6                    2515              BRA     ByteDispLp  
00002EAE                          2516              
00002EAE  4E75                    2517  dispDone    RTS
00002EB0                          2518               
00002EB0                          2519  * MOVEQ ---------------------------------------------------------------------------
00002EB0                          2520  op0111      
00002EB0  14FC 004D               2521              MOVE.B  #'M',(A2)+      * add MOVEQ to A2 String
00002EB4  14FC 004F               2522              MOVE.B  #'O',(A2)+
00002EB8  14FC 0056               2523              MOVE.B  #'V',(A2)+
00002EBC  14FC 0045               2524              MOVE.B  #'E',(A2)+
00002EC0  14FC 0051               2525              MOVE.B  #'Q',(A2)+
00002EC4  14FC 0020               2526              MOVE.B  #' ',(A2)+
00002EC8  14FC 0020               2527              MOVE.B  #' ',(A2)+
00002ECC  14FC 0020               2528              MOVE.B  #' ',(A2)+
00002ED0  14FC 0020               2529              MOVE.B  #' ',(A2)+
00002ED4  14FC 0020               2530              MOVE.B  #' ',(A2)+
00002ED8  14FC 0023               2531              MOVE.B  #'#',(A2)+
00002EDC  14FC 0024               2532              MOVE.B  #'$',(A2)+
00002EE0  4EB8 2E88               2533              JSR     _ByteDisp       * print byte data of MOVEQ instruction
00002EE4  14FC 002C               2534              MOVE.B  #',',(A2)+      * print comma
00002EE8  14FC 0044               2535              MOVE.B  #'D',(A2)+      * print D
00002EEC  2604                    2536              MOVE.L  D4,D3
00002EEE  4843                    2537              SWAP    D3
00002EF0  E98B                    2538              LSL.L   #4,D3           * shift out opcode
00002EF2  4EB8 1560               2539              JSR     BitTst3         * get bits 9->11 for data register
00002EF6  CCFC 0008               2540              MULU    #8,D6           * multiply for offset 
00002EFA  4DF9 00004A6E           2541              LEA     numTable,A6     * load num table
00002F00  4EB6 6000               2542              JSR     (A6,D6)         * get number and print
00002F04  4E75                    2543              RTS 
00002F06                          2544             
00002F06                          2545  * DIVU, DIVS, OR ------------------------------------------------------------------
00002F06                          2546  op1000      
00002F06  4843                    2547              SWAP    D3  
00002F08  EF8B                    2548              LSL.L   #7,D3   * shift out opcode & dest register
00002F0A  4EB8 1560               2549              JSR     BitTst3     * check the next three bits
00002F0E  0C06 0003               2550              CMPI.B  #%011,D6    * they are fixed for divu/divs
00002F12  6700 000E               2551              BEQ     _DivU       * branch to divu if 011
00002F16  0C06 0007               2552              CMPI.B  #%111,D6
00002F1A  6700 0070               2553              BEQ     _DivS       * branch to divs if 111
00002F1E                          2554              
00002F1E  6000 00C0               2555              BRA     _Or     * its either OR or an error
00002F22                          2556              
00002F22                          2557  * DIVU -----------------------            
00002F22                          2558  _DivU       
00002F22  1E3C 0002               2559              MOVE.B  #2,D7       * indicate a word instruction
00002F26  264A                    2560              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002F28  14FC 0044               2561              MOVE.B  #'D',(A2)+      * add DIVU to A2 String
00002F2C  14FC 0049               2562              MOVE.B  #'I',(A2)+
00002F30  14FC 0056               2563              MOVE.B  #'V',(A2)+
00002F34  14FC 0055               2564              MOVE.B  #'U',(A2)+
00002F38  14FC 0020               2565              MOVE.B  #' ',(A2)+
00002F3C  14FC 0020               2566              MOVE.B  #' ',(A2)+
00002F40  14FC 0020               2567              MOVE.B  #' ',(A2)+
00002F44  14FC 0020               2568              MOVE.B  #' ',(A2)+
00002F48  14FC 0020               2569              MOVE.B  #' ',(A2)+
00002F4C  14FC 0020               2570              MOVE.B  #' ',(A2)+
00002F50                          2571              * get EA
00002F50  4EB8 1638               2572              JSR     getMode     * get mode bits
00002F54  4DF9 000048CE           2573              LEA     eaTable,A6   * load e table
00002F5A  CCFC 0008               2574              MULU    #8,D6       * offset
00002F5E  4EB6 6000               2575              JSR     (A6,D6)     * get EA and print
00002F62                          2576              * check for error in EA
00002F62  0C07 0004               2577              CMPI.B  #4,D7
00002F66  6700 18F6               2578              BEQ     OPERROR
00002F6A                          2579      
00002F6A  14FC 002C               2580              MOVE.B  #',',(A2)+  * print comma
00002F6E  14FC 0044               2581              MOVE.B  #'D',(A2)+  * print D
00002F72  2604                    2582              MOVE.L  D4,D3       * reset D3
00002F74  4843                    2583              SWAP    D3          * push bits to front
00002F76  E98B                    2584              LSL.L   #4,D3       * shift out opcode
00002F78  4EB8 1560               2585              JSR     BitTst3     * get next three bits
00002F7C                          2586              
00002F7C  CCFC 0008               2587              MULU    #8,D6
00002F80  4DF9 00004A6E           2588              LEA     numTable,A6
00002F86  4EB6 6000               2589              JSR     (A6,D6)
00002F8A                          2590              
00002F8A  4E75                    2591              RTS
00002F8C                          2592              
00002F8C                          2593  * DIVS -----------------------
00002F8C                          2594  _DivS       
00002F8C  1E3C 0002               2595              MOVE.B  #2,D7       * indicate a word instruction
00002F90  264A                    2596              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002F92  14FC 0044               2597              MOVE.B  #'D',(A2)+      * add DIVS to A2 String
00002F96  14FC 0049               2598              MOVE.B  #'I',(A2)+
00002F9A  14FC 0056               2599              MOVE.B  #'V',(A2)+
00002F9E  14FC 0053               2600              MOVE.B  #'S',(A2)+
00002FA2  14FC 0020               2601              MOVE.B  #' ',(A2)+
00002FA6  14FC 0020               2602              MOVE.B  #' ',(A2)+
00002FAA  14FC 0020               2603              MOVE.B  #' ',(A2)+
00002FAE  14FC 0020               2604              MOVE.B  #' ',(A2)+
00002FB2  14FC 0020               2605              MOVE.B  #' ',(A2)+
00002FB6  14FC 0020               2606              MOVE.B  #' ',(A2)+
00002FBA                          2607              * get EA
00002FBA  4EB8 1638               2608              JSR     getMode 
00002FBE  14FC 002C               2609              MOVE.B  #',',(A2)+  * print comma
00002FC2  14FC 0044               2610              MOVE.B  #'D',(A2)+  * print D
00002FC6  2604                    2611              MOVE.L  D4,D3       * reset D3
00002FC8  4843                    2612              SWAP    D3
00002FCA  E98B                    2613              LSL.L   #4,D3       * shift out opcode
00002FCC  4EB8 1560               2614              JSR     BitTst3     * get next three bits
00002FD0                          2615              
00002FD0  CCFC 0008               2616              MULU    #8,D6
00002FD4  4DF9 00004A6E           2617              LEA     numTable,A6
00002FDA  4EB6 6000               2618              JSR     (A6,D6)
00002FDE  4E75                    2619              RTS
00002FE0                          2620              
00002FE0                          2621  * OR -------------------------------------------------------------------------------
00002FE0                          2622  _Or         
00002FE0  2604                    2623              MOVE.L  D4,D3       * reset D3
00002FE2  0803 0008               2624              BTST.L  #$08,D3     * check 8th bit for ea mode
00002FE6  6600 01C4               2625              BNE     _OrEA
00002FEA  4843                    2626              SWAP    D3          * swap it forward
00002FEC  E18B                    2627              LSL.L   #8,D3       * shift out 8 bits so leading 2 bits are the size
00002FEE  4EB8 1582               2628              JSR     BitTst2     * get size bits in D6
00002FF2  0C06 0000               2629              CMPI.B  #%00,D6     * check the size bit of D6 from previous test
00002FF6  6700 0016               2630              BEQ     _OrB        * OR.B
00002FFA  0C06 0001               2631              CMPI.B  #%01,D6
00002FFE  6700 0098               2632              BEQ     _OrW        * OR.W
00003002  0C06 0002               2633              CMPI.B  #%10,D6
00003006  6700 011A               2634              BEQ     _OrL        * OR.L
0000300A                          2635              
0000300A  6000 1852               2636              BRA     OPERROR
0000300E                          2637  
0000300E                          2638  * OR.B -----------------------            
0000300E                          2639  _OrB        
0000300E  1E3C 0001               2640              MOVE.B  #1,D7       * indicate a byte instruction
00003012  264A                    2641              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003014  14FC 004F               2642              MOVE.B  #'O',(A2)+      * add OR.B to A2 String
00003018  14FC 0052               2643              MOVE.B  #'R',(A2)+
0000301C  14FC 002E               2644              MOVE.B  #'.',(A2)+
00003020  14FC 0042               2645              MOVE.B  #'B',(A2)+
00003024  14FC 0020               2646              MOVE.B  #' ',(A2)+
00003028  14FC 0020               2647              MOVE.B  #' ',(A2)+
0000302C  14FC 0020               2648              MOVE.B  #' ',(A2)+
00003030  14FC 0020               2649              MOVE.B  #' ',(A2)+
00003034  14FC 0020               2650              MOVE.B  #' ',(A2)+
00003038  14FC 0020               2651              MOVE.B  #' ',(A2)+
0000303C                          2652              * get EA
0000303C  4EB8 1638               2653              JSR     getMode
00003040  0C06 0001               2654              CMPI.B  #%001,D6    * source cannot be An
00003044  6700 1818               2655              BEQ     OPERROR
00003048  E74E                    2656              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000304A  1A06                    2657              MOVE.B  D6,D5       * hold destination mode bits in d5
0000304C  E78B                    2658              LSL.L   #3,D3       * shift destination mode bits out
0000304E  4EB8 1560               2659              JSR     BitTst3     * test the destination register bits
00003052  DA46                    2660              ADD.W   D6,D5       * add these to the mode bits
00003054  0C05 003C               2661              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003058  6700 1804               2662              BEQ     OPERROR     * immediate data, there is not allowed, error
0000305C                          2663             
0000305C                          2664              * no errors
0000305C  4EB8 1638               2665              JSR     getMode 
00003060  4DF9 000048CE           2666              LEA     eaTable,A6
00003066  CCFC 0008               2667              MULU    #8,D6
0000306A  4EB6 6000               2668              JSR     (A6,D6)
0000306E                          2669              * check for error in EA
0000306E  0C07 0004               2670              CMPI.B  #4,D7
00003072  6700 17EA               2671              BEQ     OPERROR
00003076                          2672              * destination must be data register
00003076  14FC 002C               2673              MOVE.B  #',',(A2)+
0000307A  14FC 0044               2674              MOVE.B  #'D',(A2)+
0000307E  2604                    2675              MOVE.L  D4,D3   * reset D3
00003080  4843                    2676              SWAP    D3
00003082  E98B                    2677              LSL.L   #4,D3   * shift out opcode
00003084  4EB8 1560               2678              JSR     BitTst3 * get data register number
00003088  CCFC 0008               2679              MULU    #8,D6   * multiply for offset
0000308C  4DF9 00004A6E           2680              LEA     numTable,A6 * load num table
00003092  4EB6 6000               2681              JSR     (A6,D6)     * get number from table and print
00003096  4E75                    2682              RTS
00003098                          2683              
00003098                          2684  * OR.W -----------------------
00003098                          2685  _OrW        
00003098  1E3C 0002               2686              MOVE.B  #2,D7       * indicate a word instruction
0000309C  264A                    2687              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000309E  14FC 004F               2688              MOVE.B  #'O',(A2)+      * add OR.W to A2 String
000030A2  14FC 0052               2689              MOVE.B  #'R',(A2)+
000030A6  14FC 002E               2690              MOVE.B  #'.',(A2)+
000030AA  14FC 0057               2691              MOVE.B  #'W',(A2)+
000030AE  14FC 0020               2692              MOVE.B  #' ',(A2)+
000030B2  14FC 0020               2693              MOVE.B  #' ',(A2)+
000030B6  14FC 0020               2694              MOVE.B  #' ',(A2)+
000030BA  14FC 0020               2695              MOVE.B  #' ',(A2)+
000030BE  14FC 0020               2696              MOVE.B  #' ',(A2)+
000030C2  14FC 0020               2697              MOVE.B  #' ',(A2)+
000030C6                          2698              * get EA
000030C6  4EB8 1638               2699              JSR     getMode
000030CA  0C06 0001               2700              CMPI.B  #%001,D6    * source cannot be An
000030CE  6700 178E               2701              BEQ     OPERROR
000030D2  E74E                    2702              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000030D4  1A06                    2703              MOVE.B  D6,D5       * hold destination mode bits in d5
000030D6  E78B                    2704              LSL.L   #3,D3       * shift destination mode bits out
000030D8  4EB8 1560               2705              JSR     BitTst3     * test the destination register bits
000030DC  DA46                    2706              ADD.W   D6,D5       * add these to the mode bits
000030DE  0C05 003C               2707              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000030E2  6700 177A               2708              BEQ     OPERROR     * immediate data, there is not allowed, error
000030E6                          2709              * no errors
000030E6  4EB8 1638               2710              JSR     getMode
000030EA  4DF9 000048CE           2711              LEA     eaTable,A6
000030F0  CCFC 0008               2712              MULU    #8,D6
000030F4  4EB6 6000               2713              JSR     (A6,D6)
000030F8                          2714              * check for error in EA
000030F8  0C07 0004               2715              CMPI.B  #4,D7
000030FC  6700 1760               2716              BEQ     OPERROR
00003100                          2717              * destination must be data register
00003100  14FC 002C               2718              MOVE.B  #',',(A2)+
00003104  14FC 0044               2719              MOVE.B  #'D',(A2)+
00003108  2604                    2720              MOVE.L  D4,D3   * reset D3
0000310A  4843                    2721              SWAP    D3
0000310C  E98B                    2722              LSL.L   #4,D3   * shift out opcode
0000310E  4EB8 1560               2723              JSR     BitTst3 * get data register number
00003112  CCFC 0008               2724              MULU    #8,D6   * multiply for offset
00003116  4DF9 00004A6E           2725              LEA     numTable,A6 * load num table
0000311C  4EB6 6000               2726              JSR     (A6,D6)     * get number from table and print
00003120  4E75                    2727              RTS
00003122                          2728              
00003122                          2729  * OR.L -----------------------
00003122                          2730  _OrL        
00003122  1E3C 0003               2731              MOVE.B  #3,D7       * indicate a word instruction
00003126  264A                    2732              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003128  14FC 004F               2733              MOVE.B  #'O',(A2)+      * add OR.L to A2 String
0000312C  14FC 0052               2734              MOVE.B  #'R',(A2)+
00003130  14FC 002E               2735              MOVE.B  #'.',(A2)+
00003134  14FC 004C               2736              MOVE.B  #'L',(A2)+
00003138  14FC 0020               2737              MOVE.B  #' ',(A2)+
0000313C  14FC 0020               2738              MOVE.B  #' ',(A2)+
00003140  14FC 0020               2739              MOVE.B  #' ',(A2)+
00003144  14FC 0020               2740              MOVE.B  #' ',(A2)+
00003148  14FC 0020               2741              MOVE.B  #' ',(A2)+
0000314C  14FC 0020               2742              MOVE.B  #' ',(A2)+
00003150                          2743              * get EA
00003150  4EB8 1638               2744              JSR     getMode
00003154  0C06 0001               2745              CMPI.B  #%001,D6    * source cannot be An
00003158  6700 1704               2746              BEQ     OPERROR
0000315C  E74E                    2747              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000315E  1A06                    2748              MOVE.B  D6,D5       * hold destination mode bits in d5
00003160  E78B                    2749              LSL.L   #3,D3       * shift destination mode bits out
00003162  4EB8 1560               2750              JSR     BitTst3     * test the destination register bits
00003166  DA46                    2751              ADD.W   D6,D5       * add these to the mode bits
00003168  0C05 003C               2752              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000316C  6700 16F0               2753              BEQ     OPERROR     * immediate data, there is not allowed, error
00003170                          2754              
00003170  4EB8 1638               2755              JSR     getMode
00003174  4DF9 000048CE           2756              LEA     eaTable,A6
0000317A  CCFC 0008               2757              MULU    #8,D6
0000317E  4EB6 6000               2758              JSR     (A6,D6)
00003182                          2759              * check for error in EA
00003182  0C07 0004               2760              CMPI.B  #4,D7
00003186  6700 16D6               2761              BEQ     OPERROR
0000318A                          2762              * destination must be data register
0000318A  14FC 002C               2763              MOVE.B  #',',(A2)+
0000318E  14FC 0044               2764              MOVE.B  #'D',(A2)+
00003192  2604                    2765              MOVE.L  D4,D3   * reset D3
00003194  4843                    2766              SWAP    D3
00003196  E98B                    2767              LSL.L   #4,D3   * shift out opcode
00003198  4EB8 1560               2768              JSR     BitTst3 * get data register number
0000319C  CCFC 0008               2769              MULU    #8,D6   * multiply for offset
000031A0  4DF9 00004A6E           2770              LEA     numTable,A6 * load num table
000031A6  4EB6 6000               2771              JSR     (A6,D6)     * get number from table and print
000031AA  4E75                    2772              RTS
000031AC                          2773       
000031AC                          2774  * Or to effective address ----------------------------------------------------       
000031AC                          2775  _OrEA
000031AC  4843                    2776              SWAP    D3          * swap it forward
000031AE  E18B                    2777              LSL.L   #8,D3       * shift out 8 bits so leading 2 bits are the size
000031B0  4EB8 1582               2778              JSR     BitTst2     * get size bits in D6
000031B4  2604                    2779              MOVE.L  D4,D3       * reset D3
000031B6  4843                    2780              SWAP    D3
000031B8  0C06 0000               2781              CMPI.B  #%00,D6     * check the size bit of D6 from previous test
000031BC  6700 0012               2782              BEQ     _OrB_EA        * OR.B
000031C0  0C06 0001               2783              CMPI.B  #%01,D6
000031C4  6700 0090               2784              BEQ     _OrW_EA      * OR.W
000031C8  0C06 0002               2785              CMPI.B  #%10,D6
000031CC  6700 010E               2786              BEQ     _OrL_EA     * OR.L
000031D0                          2787  
000031D0                          2788  _OrB_EA     
000031D0  1E3C 0001               2789              MOVE.B  #1,D7       * indicate a byte instruction
000031D4  264A                    2790              MOVEA.L A2,A3       * copy current address of A2 string to A3
000031D6  14FC 004F               2791              MOVE.B  #'O',(A2)+      * add OR.B to A2 String
000031DA  14FC 0052               2792              MOVE.B  #'R',(A2)+
000031DE  14FC 002E               2793              MOVE.B  #'.',(A2)+
000031E2  14FC 0042               2794              MOVE.B  #'B',(A2)+
000031E6  14FC 0020               2795              MOVE.B  #' ',(A2)+
000031EA  14FC 0020               2796              MOVE.B  #' ',(A2)+
000031EE  14FC 0020               2797              MOVE.B  #' ',(A2)+
000031F2  14FC 0020               2798              MOVE.B  #' ',(A2)+
000031F6  14FC 0020               2799              MOVE.B  #' ',(A2)+
000031FA  14FC 0020               2800              MOVE.B  #' ',(A2)+
000031FE  14FC 0044               2801              MOVE.B  #'D',(A2)+  * starting source must be data register
00003202  E98B                    2802              LSL.L   #4,D3   * shift out opcode
00003204  4EB8 1560               2803              JSR     BitTst3 * get data register number
00003208  CCFC 0008               2804              MULU    #8,D6   * multiply for offset
0000320C  4DF9 00004A6E           2805              LEA     numTable,A6 * load num table
00003212  4EB6 6000               2806              JSR     (A6,D6)     * get number from table and print
00003216  14FC 002C               2807              MOVE.B  #',',(A2)+
0000321A                          2808              
0000321A                          2809              * get EA mode and check for errors
0000321A  4EB8 1638               2810              JSR     getMode
0000321E  0C06 0001               2811              CMPI.B  #%001,D6    * cant write to An
00003222  6700 163A               2812              BEQ     OPERROR
00003226  E74E                    2813              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003228  1A06                    2814              MOVE.B  D6,D5       * hold destination mode bits in d5
0000322A  E78B                    2815              LSL.L   #3,D3       * shift destination mode bits out
0000322C  4EB8 1560               2816              JSR     BitTst3     * test the destination register bits
00003230  DA46                    2817              ADD.W   D6,D5       * add these to the mode bits
00003232  0C05 003C               2818              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003236  6700 1626               2819              BEQ     OPERROR     * immediate data, there is not allowed, error
0000323A                          2820              
0000323A                          2821              * no errors
0000323A  4EB8 1638               2822              JSR     getMode
0000323E  4DF9 000048CE           2823              LEA     eaTable,A6
00003244  CCFC 0008               2824              MULU    #8,D6
00003248  4EB6 6000               2825              JSR     (A6,D6)
0000324C                          2826              * check for error in EA
0000324C  0C07 0004               2827              CMPI.B  #4,D7
00003250  6700 160C               2828              BEQ     OPERROR
00003254  4E75                    2829              RTS
00003256                          2830  
00003256                          2831  _OrW_EA     
00003256  1E3C 0002               2832              MOVE.B  #2,D7       * indicate a word instruction
0000325A  264A                    2833              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000325C  14FC 004F               2834              MOVE.B  #'O',(A2)+      * add OR.W to A2 String
00003260  14FC 0052               2835              MOVE.B  #'R',(A2)+
00003264  14FC 002E               2836              MOVE.B  #'.',(A2)+
00003268  14FC 0057               2837              MOVE.B  #'W',(A2)+
0000326C  14FC 0020               2838              MOVE.B  #' ',(A2)+
00003270  14FC 0020               2839              MOVE.B  #' ',(A2)+
00003274  14FC 0020               2840              MOVE.B  #' ',(A2)+
00003278  14FC 0020               2841              MOVE.B  #' ',(A2)+
0000327C  14FC 0020               2842              MOVE.B  #' ',(A2)+
00003280  14FC 0020               2843              MOVE.B  #' ',(A2)+
00003284  14FC 0044               2844              MOVE.B  #'D',(A2)+  * starting source must be data register
00003288  E98B                    2845              LSL.L   #4,D3   * shift out opcode
0000328A  4EB8 1560               2846              JSR     BitTst3 * get data register number
0000328E  CCFC 0008               2847              MULU    #8,D6   * multiply for offset
00003292  4DF9 00004A6E           2848              LEA     numTable,A6 * load num table
00003298  4EB6 6000               2849              JSR     (A6,D6)     * get number from table and print
0000329C  14FC 002C               2850              MOVE.B  #',',(A2)+
000032A0                          2851              
000032A0                          2852              * get EA mode and check for errors
000032A0  4EB8 1638               2853              JSR     getMode
000032A4  0C06 0001               2854              CMPI.B  #%001,D6    * cant write to An
000032A8  6700 15B4               2855              BEQ     OPERROR
000032AC  E74E                    2856              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000032AE  1A06                    2857              MOVE.B  D6,D5       * hold destination mode bits in d5
000032B0  E78B                    2858              LSL.L   #3,D3       * shift destination mode bits out
000032B2  4EB8 1560               2859              JSR     BitTst3     * test the destination register bits
000032B6  DA46                    2860              ADD.W   D6,D5       * add these to the mode bits
000032B8  0C05 003C               2861              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000032BC  6700 15A0               2862              BEQ     OPERROR     * immediate data, there is not allowed, error
000032C0                          2863              
000032C0                          2864              * no errors
000032C0  4EB8 1638               2865              JSR     getMode
000032C4  4DF9 000048CE           2866              LEA     eaTable,A6
000032CA  CCFC 0008               2867              MULU    #8,D6
000032CE  4EB6 6000               2868              JSR     (A6,D6)
000032D2                          2869              * check for error in EA
000032D2  0C07 0004               2870              CMPI.B  #4,D7
000032D6  6700 1586               2871              BEQ     OPERROR
000032DA  4E75                    2872              RTS
000032DC                          2873  
000032DC                          2874  _OrL_EA
000032DC  1E3C 0003               2875              MOVE.B  #3,D7       * indicate a long instruction
000032E0  264A                    2876              MOVEA.L A2,A3       * copy current address of A2 string to A3
000032E2  14FC 004F               2877              MOVE.B  #'O',(A2)+      * add OR.W to A2 String
000032E6  14FC 0052               2878              MOVE.B  #'R',(A2)+
000032EA  14FC 002E               2879              MOVE.B  #'.',(A2)+
000032EE  14FC 0057               2880              MOVE.B  #'W',(A2)+
000032F2  14FC 0020               2881              MOVE.B  #' ',(A2)+
000032F6  14FC 0020               2882              MOVE.B  #' ',(A2)+
000032FA  14FC 0020               2883              MOVE.B  #' ',(A2)+
000032FE  14FC 0020               2884              MOVE.B  #' ',(A2)+
00003302  14FC 0020               2885              MOVE.B  #' ',(A2)+
00003306  14FC 0020               2886              MOVE.B  #' ',(A2)+
0000330A  14FC 0044               2887              MOVE.B  #'D',(A2)+  * starting source must be data register
0000330E  E98B                    2888              LSL.L   #4,D3   * shift out opcode
00003310  4EB8 1560               2889              JSR     BitTst3 * get data register number
00003314  CCFC 0008               2890              MULU    #8,D6   * multiply for offset
00003318  4DF9 00004A6E           2891              LEA     numTable,A6 * load num table
0000331E  4EB6 6000               2892              JSR     (A6,D6)     * get number from table and print
00003322  14FC 002C               2893              MOVE.B  #',',(A2)+
00003326                          2894              
00003326                          2895              * get EA mode and check for errors
00003326  4EB8 1638               2896              JSR     getMode
0000332A  0C06 0001               2897              CMPI.B  #%001,D6    * cant write to An
0000332E  6700 152E               2898              BEQ     OPERROR
00003332  E74E                    2899              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003334  1A06                    2900              MOVE.B  D6,D5       * hold destination mode bits in d5
00003336  E78B                    2901              LSL.L   #3,D3       * shift destination mode bits out
00003338  4EB8 1560               2902              JSR     BitTst3     * test the destination register bits
0000333C  DA46                    2903              ADD.W   D6,D5       * add these to the mode bits
0000333E  0C05 003C               2904              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003342  6700 151A               2905              BEQ     OPERROR     * immediate data, there is not allowed, error
00003346                          2906              
00003346                          2907              * no errors
00003346  4EB8 1638               2908              JSR     getMode
0000334A  4DF9 000048CE           2909              LEA     eaTable,A6
00003350  CCFC 0008               2910              MULU    #8,D6
00003354  4EB6 6000               2911              JSR     (A6,D6)
00003358                          2912              * check for error in EA
00003358  0C07 0004               2913              CMPI.B  #4,D7
0000335C  6700 1500               2914              BEQ     OPERROR
00003360                          2915              
00003360  4E75                    2916              RTS
00003362                          2917  
00003362                          2918  * SUB ------------------------------------------------------------------------            
00003362  0803 0008               2919  op1001      BTST.L  #$08,D3
00003366  6600 01C4               2920              BNE     Sub_EA  * <ea>*Dn -> <ea>
0000336A  4843                    2921              SWAP    D3
0000336C  E18B                    2922              LSL.L   #8,D3   * shift leading 8 bits out to check size
0000336E  4EB8 1582               2923              JSR     BitTst2
00003372  0C06 0000               2924              CMPI.B  #%00,D6
00003376  6700 0016               2925              BEQ     _SubB   * SUB.B
0000337A  0C06 0001               2926              CMPI.B  #%01,D6
0000337E  6700 0098               2927              BEQ     _SubW   * SUB.W
00003382  0C06 0002               2928              CMPI.B  #%10,D6
00003386  6700 011A               2929              BEQ     _SubL   * SUB.L
0000338A                          2930              
0000338A  6000 14D2               2931              BRA     OPERROR
0000338E                          2932              
0000338E                          2933  _SubB       
0000338E  1E3C 0001               2934              MOVE.B  #1,D7       * indicate a byte instruction
00003392  264A                    2935              MOVEA.L A2,A3       * copy current address of A2 string to A3            
00003394  14FC 0053               2936              MOVE.B  #'S',(A2)+      * add SUB.B to A2 String
00003398  14FC 0055               2937              MOVE.B  #'U',(A2)+
0000339C  14FC 0042               2938              MOVE.B  #'B',(A2)+
000033A0  14FC 002E               2939              MOVE.B  #'.',(A2)+
000033A4  14FC 0042               2940              MOVE.B  #'B',(A2)+
000033A8  14FC 0020               2941              MOVE.B  #' ',(A2)+
000033AC  14FC 0020               2942              MOVE.B  #' ',(A2)+
000033B0  14FC 0020               2943              MOVE.B  #' ',(A2)+
000033B4  14FC 0020               2944              MOVE.B  #' ',(A2)+
000033B8  14FC 0020               2945              MOVE.B  #' ',(A2)+
000033BC                          2946              * get EA
000033BC  4EB8 1638               2947              JSR     getMode
000033C0  0C06 0001               2948              CMPI.B  #%001,D6    * source cannot be An
000033C4  6700 1498               2949              BEQ     OPERROR
000033C8  E74E                    2950              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000033CA  1A06                    2951              MOVE.B  D6,D5       * hold destination mode bits in d5
000033CC  E78B                    2952              LSL.L   #3,D3       * shift destination mode bits out
000033CE  4EB8 1560               2953              JSR     BitTst3     * test the destination register bits
000033D2  DA46                    2954              ADD.W   D6,D5       * add these to the mode bits
000033D4  0C05 003C               2955              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000033D8  6700 1484               2956              BEQ     OPERROR     * immediate data, this is not allowed, error
000033DC                          2957              * no errors
000033DC  4EB8 1638               2958              JSR     getMode
000033E0  4DF9 000048CE           2959              LEA     eaTable,A6
000033E6  CCFC 0008               2960              MULU    #8,D6
000033EA  4EB6 6000               2961              JSR     (A6,D6)
000033EE                          2962              * check for error in EA
000033EE  0C07 0004               2963              CMPI.B  #4,D7
000033F2  6700 146A               2964              BEQ     OPERROR
000033F6                          2965              * destination must be data register
000033F6  14FC 002C               2966              MOVE.B  #',',(A2)+
000033FA  14FC 0044               2967              MOVE.B  #'D',(A2)+
000033FE  2604                    2968              MOVE.L  D4,D3   * reset D3
00003400  4843                    2969              SWAP    D3
00003402  E98B                    2970              LSL.L   #4,D3   * shift out opcode
00003404  4EB8 1560               2971              JSR     BitTst3 * get data register number
00003408  CCFC 0008               2972              MULU    #8,D6   * multiply for offset
0000340C  4DF9 00004A6E           2973              LEA     numTable,A6 * load num table
00003412  4EB6 6000               2974              JSR     (A6,D6)     * get number from table and print
00003416                          2975  
00003416  4E75                    2976              RTS  
00003418                          2977  
00003418                          2978  _SubW       
00003418  1E3C 0002               2979              MOVE.B  #2,D7       * indicate a word instruction
0000341C  264A                    2980              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000341E  14FC 0053               2981              MOVE.B  #'S',(A2)+      * add SUB.W to A2 String
00003422  14FC 0055               2982              MOVE.B  #'U',(A2)+
00003426  14FC 0042               2983              MOVE.B  #'B',(A2)+
0000342A  14FC 002E               2984              MOVE.B  #'.',(A2)+
0000342E  14FC 0057               2985              MOVE.B  #'W',(A2)+
00003432  14FC 0020               2986              MOVE.B  #' ',(A2)+
00003436  14FC 0020               2987              MOVE.B  #' ',(A2)+
0000343A  14FC 0020               2988              MOVE.B  #' ',(A2)+
0000343E  14FC 0020               2989              MOVE.B  #' ',(A2)+
00003442  14FC 0020               2990              MOVE.B  #' ',(A2)+
00003446                          2991              * get EA
00003446  4EB8 1638               2992              JSR     getMode
0000344A  0C06 0001               2993              CMPI.B  #%001,D6    * source cannot be An
0000344E  6700 140E               2994              BEQ     OPERROR
00003452  E74E                    2995              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003454  1A06                    2996              MOVE.B  D6,D5       * hold destination mode bits in d5
00003456  E78B                    2997              LSL.L   #3,D3       * shift destination mode bits out
00003458  4EB8 1560               2998              JSR     BitTst3     * test the destination register bits
0000345C  DA46                    2999              ADD.W   D6,D5       * add these to the mode bits
0000345E  0C05 003C               3000              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003462  6700 13FA               3001              BEQ     OPERROR     * immediate data, there is not allowed, error
00003466                          3002              * no errors
00003466  4EB8 1638               3003              JSR     getMode
0000346A  4DF9 000048CE           3004              LEA     eaTable,A6
00003470  CCFC 0008               3005              MULU    #8,D6
00003474  4EB6 6000               3006              JSR     (A6,D6)
00003478                          3007              * check for error in EA
00003478  0C07 0004               3008              CMPI.B  #4,D7
0000347C  6700 13E0               3009              BEQ     OPERROR
00003480                          3010              * destination must be data register
00003480  14FC 002C               3011              MOVE.B  #',',(A2)+
00003484  14FC 0044               3012              MOVE.B  #'D',(A2)+
00003488  2604                    3013              MOVE.L  D4,D3   * reset D3
0000348A  4843                    3014              SWAP    D3
0000348C  E98B                    3015              LSL.L   #4,D3   * shift out opcode
0000348E  4EB8 1560               3016              JSR     BitTst3 * get data register number
00003492  CCFC 0008               3017              MULU    #8,D6   * multiply for offset
00003496  4DF9 00004A6E           3018              LEA     numTable,A6 * load num table
0000349C  4EB6 6000               3019              JSR     (A6,D6)     * get number from table and print
000034A0                          3020  
000034A0  4E75                    3021              RTS
000034A2                          3022  
000034A2                          3023  _SubL       
000034A2  1E3C 0003               3024              MOVE.B  #3,D7       * indicate a long instruction
000034A6  264A                    3025              MOVEA.L A2,A3       * copy current address of A2 string to A3
000034A8  14FC 0053               3026              MOVE.B  #'S',(A2)+      * add SUB.L to A2 String
000034AC  14FC 0055               3027              MOVE.B  #'U',(A2)+
000034B0  14FC 0042               3028              MOVE.B  #'B',(A2)+
000034B4  14FC 002E               3029              MOVE.B  #'.',(A2)+
000034B8  14FC 004C               3030              MOVE.B  #'L',(A2)+
000034BC  14FC 0020               3031              MOVE.B  #' ',(A2)+
000034C0  14FC 0020               3032              MOVE.B  #' ',(A2)+
000034C4  14FC 0020               3033              MOVE.B  #' ',(A2)+
000034C8  14FC 0020               3034              MOVE.B  #' ',(A2)+
000034CC  14FC 0020               3035              MOVE.B  #' ',(A2)+
000034D0                          3036              * get EA
000034D0  4EB8 1638               3037              JSR     getMode
000034D4  0C06 0001               3038              CMPI.B  #%001,D6    * source cannot be An
000034D8  6700 1384               3039              BEQ     OPERROR
000034DC  E74E                    3040              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000034DE  1A06                    3041              MOVE.B  D6,D5       * hold destination mode bits in d5
000034E0  E78B                    3042              LSL.L   #3,D3       * shift destination mode bits out
000034E2  4EB8 1560               3043              JSR     BitTst3     * test the destination register bits
000034E6  DA46                    3044              ADD.W   D6,D5       * add these to the mode bits
000034E8  0C05 003C               3045              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000034EC  6700 1370               3046              BEQ     OPERROR     * immediate data, there is not allowed, error
000034F0                          3047              * no errors
000034F0  4EB8 1638               3048              JSR     getMode
000034F4  4DF9 000048CE           3049              LEA     eaTable,A6
000034FA  CCFC 0008               3050              MULU    #8,D6
000034FE  4EB6 6000               3051              JSR     (A6,D6)
00003502                          3052              * check for error in EA
00003502  0C07 0004               3053              CMPI.B  #4,D7
00003506  6700 1356               3054              BEQ     OPERROR
0000350A                          3055              * destination must be data register
0000350A  14FC 002C               3056              MOVE.B  #',',(A2)+
0000350E  14FC 0044               3057              MOVE.B  #'D',(A2)+
00003512  2604                    3058              MOVE.L  D4,D3   * reset D3
00003514  4843                    3059              SWAP    D3
00003516  E98B                    3060              LSL.L   #4,D3   * shift out opcode
00003518  4EB8 1560               3061              JSR     BitTst3 * get data register number
0000351C  CCFC 0008               3062              MULU    #8,D6   * multiply for offset
00003520  4DF9 00004A6E           3063              LEA     numTable,A6 * load num table
00003526  4EB6 6000               3064              JSR     (A6,D6)     * get number from table and print
0000352A                          3065  
0000352A  4E75                    3066              RTS
0000352C                          3067  
0000352C                          3068  Sub_EA      
0000352C  4843                    3069              SWAP    D3
0000352E  E18B                    3070              LSL.L   #8,D3   * shift leading 8 bits out to check size
00003530  4EB8 1582               3071              JSR     BitTst2
00003534  2604                    3072              MOVE.L  D4,D3   * reset D3
00003536  4843                    3073              SWAP    D3
00003538  0C06 0000               3074              CMPI.B  #%00,D6
0000353C  6700 0012               3075              BEQ     _SubB_EA   * SUB.B
00003540  0C06 0001               3076              CMPI.B  #%01,D6
00003544  6700 0090               3077              BEQ     _SubW_EA   * SUB.W
00003548  0C06 0002               3078              CMPI.B  #%10,D6
0000354C  6700 010E               3079              BEQ     _SubL_EA   * SUB.L
00003550                          3080              
00003550                          3081  _SubB_EA
00003550  1E3C 0001               3082              MOVE.B  #1,D7       * indicate a byte instruction
00003554  264A                    3083              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003556  14FC 0053               3084              MOVE.B  #'S',(A2)+      * add OR.W to A2 String
0000355A  14FC 0055               3085              MOVE.B  #'U',(A2)+
0000355E  14FC 0042               3086              MOVE.B  #'B',(A2)+
00003562  14FC 002E               3087              MOVE.B  #'.',(A2)+
00003566  14FC 0042               3088              MOVE.B  #'B',(A2)+
0000356A  14FC 0020               3089              MOVE.B  #' ',(A2)+
0000356E  14FC 0020               3090              MOVE.B  #' ',(A2)+
00003572  14FC 0020               3091              MOVE.B  #' ',(A2)+
00003576  14FC 0020               3092              MOVE.B  #' ',(A2)+
0000357A  14FC 0020               3093              MOVE.B  #' ',(A2)+
0000357E  14FC 0044               3094              MOVE.B  #'D',(A2)+  * starting source must be data register
00003582  E98B                    3095              LSL.L   #4,D3   * shift out opcode
00003584  4EB8 1560               3096              JSR     BitTst3 * get data register number
00003588  CCFC 0008               3097              MULU    #8,D6   * multiply for offset
0000358C  4DF9 00004A6E           3098              LEA     numTable,A6 * load num table
00003592  4EB6 6000               3099              JSR     (A6,D6)     * get number from table and print
00003596  14FC 002C               3100              MOVE.B  #',',(A2)+
0000359A                          3101              
0000359A                          3102              * get EA mode and check for errors
0000359A  4EB8 1638               3103              JSR     getMode
0000359E  0C06 0001               3104              CMPI.B  #%001,D6    * cant write to An
000035A2  6700 12BA               3105              BEQ     OPERROR
000035A6  E74E                    3106              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000035A8  1A06                    3107              MOVE.B  D6,D5       * hold destination mode bits in d5
000035AA  E78B                    3108              LSL.L   #3,D3       * shift destination mode bits out
000035AC  4EB8 1560               3109              JSR     BitTst3     * test the destination register bits
000035B0  DA46                    3110              ADD.W   D6,D5       * add these to the mode bits
000035B2  0C05 003C               3111              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000035B6  6700 12A6               3112              BEQ     OPERROR     * immediate data, there is not allowed, error
000035BA                          3113              
000035BA                          3114              * no errors
000035BA  4EB8 1638               3115              JSR     getMode
000035BE  4DF9 000048CE           3116              LEA     eaTable,A6
000035C4  CCFC 0008               3117              MULU    #8,D6
000035C8  4EB6 6000               3118              JSR     (A6,D6)
000035CC                          3119              * check for error in EA
000035CC  0C07 0004               3120              CMPI.B  #4,D7
000035D0  6700 128C               3121              BEQ     OPERROR
000035D4                          3122              
000035D4  4E75                    3123              RTS
000035D6                          3124  
000035D6                          3125  
000035D6                          3126  _SubW_EA    
000035D6  1E3C 0002               3127              MOVE.B  #2,D7       * indicate a word instruction
000035DA  264A                    3128              MOVEA.L A2,A3       * copy current address of A2 string to A3
000035DC  14FC 0053               3129              MOVE.B  #'S',(A2)+      * add OR.W to A2 String
000035E0  14FC 0055               3130              MOVE.B  #'U',(A2)+
000035E4  14FC 0042               3131              MOVE.B  #'B',(A2)+
000035E8  14FC 002E               3132              MOVE.B  #'.',(A2)+
000035EC  14FC 0057               3133              MOVE.B  #'W',(A2)+
000035F0  14FC 0020               3134              MOVE.B  #' ',(A2)+
000035F4  14FC 0020               3135              MOVE.B  #' ',(A2)+
000035F8  14FC 0020               3136              MOVE.B  #' ',(A2)+
000035FC  14FC 0020               3137              MOVE.B  #' ',(A2)+
00003600  14FC 0020               3138              MOVE.B  #' ',(A2)+
00003604  14FC 0044               3139              MOVE.B  #'D',(A2)+  * starting source must be data register
00003608  E98B                    3140              LSL.L   #4,D3   * shift out opcode
0000360A  4EB8 1560               3141              JSR     BitTst3 * get data register number
0000360E  CCFC 0008               3142              MULU    #8,D6   * multiply for offset
00003612  4DF9 00004A6E           3143              LEA     numTable,A6 * load num table
00003618  4EB6 6000               3144              JSR     (A6,D6)     * get number from table and print
0000361C  14FC 002C               3145              MOVE.B  #',',(A2)+
00003620                          3146              
00003620                          3147              * get EA mode and check for errors
00003620  4EB8 1638               3148              JSR     getMode
00003624  0C06 0001               3149              CMPI.B  #%001,D6    * cant write to An
00003628  6700 1234               3150              BEQ     OPERROR
0000362C  E74E                    3151              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000362E  1A06                    3152              MOVE.B  D6,D5       * hold destination mode bits in d5
00003630  E78B                    3153              LSL.L   #3,D3       * shift destination mode bits out
00003632  4EB8 1560               3154              JSR     BitTst3     * test the destination register bits
00003636  DA46                    3155              ADD.W   D6,D5       * add these to the mode bits
00003638  0C05 003C               3156              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000363C  6700 1220               3157              BEQ     OPERROR     * immediate data, there is not allowed, error
00003640                          3158              
00003640                          3159              * no errors
00003640  4EB8 1638               3160              JSR     getMode
00003644  4DF9 000048CE           3161              LEA     eaTable,A6
0000364A  CCFC 0008               3162              MULU    #8,D6
0000364E  4EB6 6000               3163              JSR     (A6,D6)
00003652                          3164              * check for error in EA
00003652  0C07 0004               3165              CMPI.B  #4,D7
00003656  6700 1206               3166              BEQ     OPERROR
0000365A                          3167              
0000365A  4E75                    3168              RTS
0000365C                          3169  
0000365C                          3170  
0000365C                          3171  _SubL_EA
0000365C  1E3C 0003               3172              MOVE.B  #3,D7       * indicate a long instruction
00003660  264A                    3173              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003662  14FC 0053               3174              MOVE.B  #'S',(A2)+      * add OR.W to A2 String
00003666  14FC 0055               3175              MOVE.B  #'U',(A2)+
0000366A  14FC 0042               3176              MOVE.B  #'B',(A2)+
0000366E  14FC 002E               3177              MOVE.B  #'.',(A2)+
00003672  14FC 004C               3178              MOVE.B  #'L',(A2)+
00003676  14FC 0020               3179              MOVE.B  #' ',(A2)+
0000367A  14FC 0020               3180              MOVE.B  #' ',(A2)+
0000367E  14FC 0020               3181              MOVE.B  #' ',(A2)+
00003682  14FC 0020               3182              MOVE.B  #' ',(A2)+
00003686  14FC 0020               3183              MOVE.B  #' ',(A2)+
0000368A  14FC 0044               3184              MOVE.B  #'D',(A2)+  * starting source must be data register
0000368E  E98B                    3185              LSL.L   #4,D3   * shift out opcode
00003690  4EB8 1560               3186              JSR     BitTst3 * get data register number
00003694  CCFC 0008               3187              MULU    #8,D6   * multiply for offset
00003698  4DF9 00004A6E           3188              LEA     numTable,A6 * load num table
0000369E  4EB6 6000               3189              JSR     (A6,D6)     * get number from table and print
000036A2  14FC 002C               3190              MOVE.B  #',',(A2)+
000036A6                          3191              
000036A6                          3192              * get EA mode and check for errors
000036A6  4EB8 1638               3193              JSR     getMode
000036AA  0C06 0001               3194              CMPI.B  #%001,D6    * cant write to An
000036AE  6700 11AE               3195              BEQ     OPERROR
000036B2  E74E                    3196              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000036B4  1A06                    3197              MOVE.B  D6,D5       * hold destination mode bits in d5
000036B6  E78B                    3198              LSL.L   #3,D3       * shift destination mode bits out
000036B8  4EB8 1560               3199              JSR     BitTst3     * test the destination register bits
000036BC  DA46                    3200              ADD.W   D6,D5       * add these to the mode bits
000036BE  0C05 003C               3201              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000036C2  6700 119A               3202              BEQ     OPERROR     * immediate data, there is not allowed, error
000036C6                          3203              
000036C6                          3204              * no errors
000036C6  4EB8 1638               3205              JSR     getMode
000036CA  4DF9 000048CE           3206              LEA     eaTable,A6
000036D0  CCFC 0008               3207              MULU    #8,D6
000036D4  4EB6 6000               3208              JSR     (A6,D6)
000036D8                          3209              * check for error in EA
000036D8  0C07 0004               3210              CMPI.B  #4,D7
000036DC  6700 1180               3211              BEQ     OPERROR
000036E0                          3212              
000036E0  4E75                    3213              RTS
000036E2                          3214  
000036E2                          3215  
000036E2                          3216  * CMP ---------------------------------------------------------------------------------
000036E2                          3217  op1011      
000036E2  0803 0008               3218              BTST.L  #$08,D3      * if 8th bit is 1, it is not CMP/CMPA
000036E6  6600 1176               3219              BNE     OPERROR     * branch to unsupported
000036EA  4843                    3220              SWAP    D3      * move bits forward
000036EC  E98B                    3221              LSL.L   #4,D3   * shift out opcode
000036EE  E98B                    3222              LSL.L   #4,D3   * shift out dest register & 8th bit
000036F0  4EB8 1582               3223              JSR     BitTst2
000036F4  0C06 0000               3224              CMPI.B  #%00,D6 * check size bits
000036F8  6700 0016               3225              BEQ     _CmpB   * CMP.B
000036FC  0C06 0001               3226              CMPI.B  #%01,D6
00003700  6700 0098               3227              BEQ     _CmpW   * CMP.W
00003704  0C06 0002               3228              CMPI.B  #%10,D6
00003708  6700 011A               3229              BEQ     _CmpL   * CMP.L
0000370C                          3230              
0000370C                          3231              * CMPA/unexpected input, branch to error
0000370C  6000 1150               3232              BRA     OPERROR
00003710                          3233              
00003710                          3234  * CMP.B ----------------------            
00003710                          3235  _CmpB       
00003710  1E3C 0001               3236              MOVE.B  #1,D7       * indicate a byte instruction
00003714  264A                    3237              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003716  14FC 0043               3238              MOVE.B  #'C',(A2)+      * add CMP.B to A2 String
0000371A  14FC 004D               3239              MOVE.B  #'M',(A2)+
0000371E  14FC 0050               3240              MOVE.B  #'P',(A2)+
00003722  14FC 002E               3241              MOVE.B  #'.',(A2)+
00003726  14FC 0042               3242              MOVE.B  #'B',(A2)+
0000372A  14FC 0020               3243              MOVE.B  #' ',(A2)+
0000372E  14FC 0020               3244              MOVE.B  #' ',(A2)+
00003732  14FC 0020               3245              MOVE.B  #' ',(A2)+
00003736  14FC 0020               3246              MOVE.B  #' ',(A2)+
0000373A  14FC 0020               3247              MOVE.B  #' ',(A2)+
0000373E                          3248              * get EA to check for errors
0000373E  4EB8 1638               3249              JSR     getMode
00003742  0C06 0001               3250              CMPI.B  #%001,D6    * mode cannot be An
00003746  6700 1116               3251              BEQ     OPERROR
0000374A  E74E                    3252              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000374C  1A06                    3253              MOVE.B  D6,D5       * hold destination mode bits in d5
0000374E  E78B                    3254              LSL.L   #3,D3       * shift destination mode bits out
00003750  4EB8 1560               3255              JSR     BitTst3     * test the destination register bits
00003754  DA46                    3256              ADD.W   D6,D5       * add these to the mode bits
00003756  0C05 003C               3257              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000375A  6700 1102               3258              BEQ     OPERROR     * immediate data, there is not allowed, error
0000375E                          3259              * no errors
0000375E  4EB8 1638               3260              JSR     getMode
00003762  4DF9 000048CE           3261              LEA     eaTable,A6
00003768  CCFC 0008               3262              MULU    #8,D6
0000376C  4EB6 6000               3263              JSR     (A6,D6)
00003770                          3264              * check for error in EA
00003770  0C07 0004               3265              CMPI.B  #4,D7
00003774  6700 10E8               3266              BEQ     OPERROR
00003778                          3267              
00003778  14FC 002C               3268              MOVE.B  #',',(A2)+
0000377C  14FC 0044               3269              MOVE.B  #'D',(A2)+
00003780  2604                    3270              MOVE.L  D4,D3   * reset D3
00003782  4843                    3271              SWAP    D3
00003784  E98B                    3272              LSL.L   #4,D3   * shift out opcode
00003786  4EB8 1560               3273              JSR     BitTst3 * get data register number
0000378A  CCFC 0008               3274              MULU    #8,D6   * multiply for offset
0000378E  4DF9 00004A6E           3275              LEA     numTable,A6 * load num table
00003794  4EB6 6000               3276              JSR     (A6,D6)     * get number from table and print
00003798                          3277              
00003798  4E75                    3278              RTS 
0000379A                          3279              
0000379A                          3280  * CMP.W ----------------------
0000379A                          3281  _CmpW       
0000379A  1E3C 0002               3282              MOVE.B  #2,D7       * indicate a long instruction
0000379E  264A                    3283              MOVEA.L A2,A3       * copy current address of A2 string to A3
000037A0  14FC 0043               3284              MOVE.B  #'C',(A2)+      * add CMP.W to A2 String
000037A4  14FC 004D               3285              MOVE.B  #'M',(A2)+
000037A8  14FC 0050               3286              MOVE.B  #'P',(A2)+
000037AC  14FC 002E               3287              MOVE.B  #'.',(A2)+
000037B0  14FC 0057               3288              MOVE.B  #'W',(A2)+
000037B4  14FC 0020               3289              MOVE.B  #' ',(A2)+
000037B8  14FC 0020               3290              MOVE.B  #' ',(A2)+
000037BC  14FC 0020               3291              MOVE.B  #' ',(A2)+
000037C0  14FC 0020               3292              MOVE.B  #' ',(A2)+
000037C4  14FC 0020               3293              MOVE.B  #' ',(A2)+
000037C8                          3294              * get EA to check for errors
000037C8  4EB8 1638               3295              JSR     getMode
000037CC  0C06 0001               3296              CMPI.B  #%001,D6    * mode cannot be An
000037D0  6700 108C               3297              BEQ     OPERROR
000037D4  E74E                    3298              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000037D6  1A06                    3299              MOVE.B  D6,D5       * hold destination mode bits in d5
000037D8  E78B                    3300              LSL.L   #3,D3       * shift destination mode bits out
000037DA  4EB8 1560               3301              JSR     BitTst3     * test the destination register bits
000037DE  DA46                    3302              ADD.W   D6,D5       * add these to the mode bits
000037E0  0C05 003C               3303              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000037E4  6700 1078               3304              BEQ     OPERROR     * immediate data, there is not allowed, error
000037E8                          3305              * no errors
000037E8  4EB8 1638               3306              JSR     getMode
000037EC  4DF9 000048CE           3307              LEA     eaTable,A6
000037F2  CCFC 0008               3308              MULU    #8,D6
000037F6  4EB6 6000               3309              JSR     (A6,D6)
000037FA                          3310              * check for error in EA
000037FA  0C07 0004               3311              CMPI.B  #4,D7
000037FE  6700 105E               3312              BEQ     OPERROR
00003802                          3313              
00003802  14FC 002C               3314              MOVE.B  #',',(A2)+
00003806  14FC 0044               3315              MOVE.B  #'D',(A2)+
0000380A  2604                    3316              MOVE.L  D4,D3   * reset D3
0000380C  4843                    3317              SWAP    D3
0000380E  E98B                    3318              LSL.L   #4,D3   * shift out opcode
00003810  4EB8 1560               3319              JSR     BitTst3 * get data register number
00003814  CCFC 0008               3320              MULU    #8,D6   * multiply for offset
00003818  4DF9 00004A6E           3321              LEA     numTable,A6 * load num table
0000381E  4EB6 6000               3322              JSR     (A6,D6)     * get number from table and print
00003822                          3323  
00003822  4E75                    3324              RTS
00003824                          3325  * CMP.L ----------------------
00003824                          3326  _CmpL       
00003824  1E3C 0003               3327              MOVE.B  #3,D7       * indicate a long instruction
00003828  264A                    3328              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000382A  14FC 0043               3329              MOVE.B  #'C',(A2)+      * add CMP.L to A2 String
0000382E  14FC 004D               3330              MOVE.B  #'M',(A2)+
00003832  14FC 0050               3331              MOVE.B  #'P',(A2)+
00003836  14FC 002E               3332              MOVE.B  #'.',(A2)+
0000383A  14FC 004C               3333              MOVE.B  #'L',(A2)+
0000383E  14FC 0020               3334              MOVE.B  #' ',(A2)+
00003842  14FC 0020               3335              MOVE.B  #' ',(A2)+
00003846  14FC 0020               3336              MOVE.B  #' ',(A2)+
0000384A  14FC 0020               3337              MOVE.B  #' ',(A2)+
0000384E  14FC 0020               3338              MOVE.B  #' ',(A2)+
00003852                          3339              * get EA to check for errors
00003852  4EB8 1638               3340              JSR     getMode
00003856  0C06 0001               3341              CMPI.B  #%001,D6    * mode cannot be An
0000385A  6700 1002               3342              BEQ     OPERROR
0000385E  E74E                    3343              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003860  1A06                    3344              MOVE.B  D6,D5       * hold destination mode bits in d5
00003862  E78B                    3345              LSL.L   #3,D3       * shift destination mode bits out
00003864  4EB8 1560               3346              JSR     BitTst3     * test the destination register bits
00003868  DA46                    3347              ADD.W   D6,D5       * add these to the mode bits
0000386A  0C05 003C               3348              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000386E  6700 0FEE               3349              BEQ     OPERROR     * immediate data, there is not allowed, error
00003872                          3350              * no errors
00003872  4EB8 1638               3351              JSR     getMode
00003876  4DF9 000048CE           3352              LEA     eaTable,A6
0000387C  CCFC 0008               3353              MULU    #8,D6
00003880  4EB6 6000               3354              JSR     (A6,D6)
00003884                          3355              * check for error in EA
00003884  0C07 0004               3356              CMPI.B  #4,D7
00003888  6700 0FD4               3357              BEQ     OPERROR
0000388C                          3358              
0000388C  14FC 002C               3359              MOVE.B  #',',(A2)+
00003890  14FC 0044               3360              MOVE.B  #'D',(A2)+
00003894  2604                    3361              MOVE.L  D4,D3   * reset D3
00003896  4843                    3362              SWAP    D3
00003898  E98B                    3363              LSL.L   #4,D3   * shift out opcode
0000389A  4EB8 1560               3364              JSR     BitTst3 * get data register number
0000389E  CCFC 0008               3365              MULU    #8,D6   * multiply for offset
000038A2  4DF9 00004A6E           3366              LEA     numTable,A6 * load num table
000038A8  4EB6 6000               3367              JSR     (A6,D6)     * get number from table and print
000038AC                          3368  
000038AC  4E75                    3369              RTS
000038AE                          3370              
000038AE                          3371  * MULS, AND --------------------------------------------------------------
000038AE                          3372  op1100      
000038AE  4843                    3373              SWAP    D3
000038B0  E18B                    3374              LSL.L   #8,D3   * shift out op code and next four bits
000038B2  4EB8 1582               3375              JSR     BitTst2 * check next two bits for size/MUL instruction
000038B6  0C06 0003               3376              CMPI.B  #%11,D6 * if bits 6-7 are not 11, it is not a MUL
000038BA  6600 0076               3377              BNE     _And    * branch to AND
000038BE  2604                    3378              MOVE.L  D4,D3   * reset D3
000038C0  0803 0008               3379              BTST.L  #$08,D3 * if bit 8 is 0, it is not MULS, error
000038C4  6700 0F98               3380              BEQ     OPERROR
000038C8                          3381              * otherwise, it is a MULS instruction
000038C8  1E3C 0002               3382              MOVE.B  #2,D7       * indicate a word instruction
000038CC  264A                    3383              MOVEA.L A2,A3       * copy current address of A2 string to A3
000038CE  14FC 004D               3384              MOVE.B  #'M',(A2)+      * add DIVS to A2 String
000038D2  14FC 0055               3385              MOVE.B  #'U',(A2)+
000038D6  14FC 004C               3386              MOVE.B  #'L',(A2)+
000038DA  14FC 0053               3387              MOVE.B  #'S',(A2)+
000038DE  14FC 0020               3388              MOVE.B  #' ',(A2)+
000038E2  14FC 0020               3389              MOVE.B  #' ',(A2)+
000038E6  14FC 0020               3390              MOVE.B  #' ',(A2)+
000038EA  14FC 0020               3391              MOVE.B  #' ',(A2)+
000038EE  14FC 0020               3392              MOVE.B  #' ',(A2)+
000038F2  14FC 0020               3393              MOVE.B  #' ',(A2)+
000038F6                          3394              * get EA
000038F6  4EB8 1638               3395              JSR     getMode     * get mode
000038FA  4DF9 000048CE           3396              LEA     eaTable,A6  * load ea table
00003900  CCFC 0008               3397              MULU    #8,D6       * offset
00003904  4EB6 6000               3398              JSR     (A6,D6)     * get EA and reg number
00003908                          3399              * check for error in EA
00003908  0C07 0004               3400              CMPI.B  #4,D7
0000390C  6700 0F50               3401              BEQ     OPERROR
00003910                          3402   
00003910  14FC 002C               3403              MOVE.B  #',',(A2)+  * print comma
00003914  14FC 0044               3404              MOVE.B  #'D',(A2)+  * print D
00003918  2604                    3405              MOVE.L  D4,D3
0000391A  4843                    3406              SWAP    D3
0000391C  E98B                    3407              LSL.L   #4,D3       * shift out opcode
0000391E  4EB8 1560               3408              JSR     BitTst3     * get next three bits
00003922                          3409              
00003922  CCFC 0008               3410              MULU    #8,D6
00003926  4DF9 00004A6E           3411              LEA     numTable,A6
0000392C  4EB6 6000               3412              JSR     (A6,D6)
00003930                          3413              
00003930  4E75                    3414              RTS
00003932                          3415  * AND ---------------------------------------------------------------------
00003932                          3416  _And        
00003932  2604                    3417              MOVE.L  D4,D3   * reset D3
00003934  0803 0008               3418              BTST.L  #$08,D3 * if 8th bit is 1, <ea> * Dn -> <ea>
00003938  6600 01C4               3419              BNE     _AndEA  * branch to AND to EA
0000393C  4843                    3420              SWAP    D3
0000393E  E18B                    3421              LSL.L   #8,D3
00003940  4EB8 1582               3422              JSR     BitTst2     * test size bits
00003944                          3423              * must be an AND instruction or error
00003944  0C06 0000               3424              CMPI.B  #%00,D6 * use d6 to check size
00003948  6700 0016               3425              BEQ     _AndB   * AND.B
0000394C  0C06 0001               3426              CMPI.B  #%01,D6
00003950  6700 0098               3427              BEQ     _AndW   * AND.W
00003954  0C06 0002               3428              CMPI.B  #%10,D6
00003958  6700 011A               3429              BEQ     _AndL   * AND.L
0000395C                          3430              
0000395C  6000 0F00               3431              BRA     OPERROR
00003960                          3432              
00003960                          3433  * AND.B ----------------------            
00003960                          3434  _AndB       
00003960  1E3C 0001               3435              MOVE.B  #1,D7       * indicate a byte instruction
00003964  264A                    3436              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003966  14FC 0041               3437              MOVE.B  #'A',(A2)+      * add AND.B to A2 String
0000396A  14FC 004E               3438              MOVE.B  #'N',(A2)+
0000396E  14FC 0044               3439              MOVE.B  #'D',(A2)+
00003972  14FC 002E               3440              MOVE.B  #'.',(A2)+
00003976  14FC 0042               3441              MOVE.B  #'B',(A2)+
0000397A  14FC 0020               3442              MOVE.B  #' ',(A2)+
0000397E  14FC 0020               3443              MOVE.B  #' ',(A2)+
00003982  14FC 0020               3444              MOVE.B  #' ',(A2)+
00003986  14FC 0020               3445              MOVE.B  #' ',(A2)+
0000398A  14FC 0020               3446              MOVE.B  #' ',(A2)+
0000398E                          3447              * get EA
0000398E  4EB8 1638               3448              JSR     getMode
00003992  0C06 0001               3449              CMPI.B  #%001,D6    * source cannot be An
00003996  6700 0EC6               3450              BEQ     OPERROR
0000399A  E74E                    3451              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000399C  1A06                    3452              MOVE.B  D6,D5       * hold destination mode bits in d5
0000399E  E78B                    3453              LSL.L   #3,D3       * shift destination mode bits out
000039A0  4EB8 1560               3454              JSR     BitTst3     * test the destination register bits
000039A4  DA46                    3455              ADD.W   D6,D5       * add these to the mode bits
000039A6  0C05 003C               3456              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000039AA  6700 0EB2               3457              BEQ     OPERROR     * immediate data, there is not allowed, error
000039AE                          3458              * no errors
000039AE  4EB8 1638               3459              JSR     getMode
000039B2  4DF9 000048CE           3460              LEA     eaTable,A6
000039B8  CCFC 0008               3461              MULU    #8,D6
000039BC  4EB6 6000               3462              JSR     (A6,D6)
000039C0                          3463              * check for error in EA
000039C0  0C07 0004               3464              CMPI.B  #4,D7
000039C4  6700 0E98               3465              BEQ     OPERROR
000039C8                          3466              * destination must be data register
000039C8  14FC 002C               3467              MOVE.B  #',',(A2)+
000039CC  14FC 0044               3468              MOVE.B  #'D',(A2)+
000039D0  2604                    3469              MOVE.L  D4,D3   * reset D3
000039D2  4843                    3470              SWAP    D3
000039D4  E98B                    3471              LSL.L   #4,D3   * shift out opcode
000039D6  4EB8 1560               3472              JSR     BitTst3 * get data register number
000039DA  CCFC 0008               3473              MULU    #8,D6   * multiply for offset
000039DE  4DF9 00004A6E           3474              LEA     numTable,A6 * load num table
000039E4  4EB6 6000               3475              JSR     (A6,D6)     * get number from table and print
000039E8                          3476  
000039E8  4E75                    3477              RTS
000039EA                          3478              
000039EA                          3479  * AND.W ----------------------
000039EA                          3480  _AndW       
000039EA  1E3C 0002               3481              MOVE.B  #2,D7       * indicate a word instruction
000039EE  264A                    3482              MOVEA.L A2,A3       * copy current address of A2 string to A3
000039F0  14FC 0041               3483              MOVE.B  #'A',(A2)+      * add AND.W to A2 String
000039F4  14FC 004E               3484              MOVE.B  #'N',(A2)+
000039F8  14FC 0044               3485              MOVE.B  #'D',(A2)+
000039FC  14FC 002E               3486              MOVE.B  #'.',(A2)+
00003A00  14FC 0057               3487              MOVE.B  #'W',(A2)+
00003A04  14FC 0020               3488              MOVE.B  #' ',(A2)+
00003A08  14FC 0020               3489              MOVE.B  #' ',(A2)+
00003A0C  14FC 0020               3490              MOVE.B  #' ',(A2)+
00003A10  14FC 0020               3491              MOVE.B  #' ',(A2)+
00003A14  14FC 0020               3492              MOVE.B  #' ',(A2)+
00003A18                          3493              * get EA
00003A18  4EB8 1638               3494              JSR     getMode
00003A1C  0C06 0001               3495              CMPI.B  #%001,D6    * source cannot be An
00003A20  6700 0E3C               3496              BEQ     OPERROR
00003A24  E74E                    3497              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003A26  1A06                    3498              MOVE.B  D6,D5       * hold destination mode bits in d5
00003A28  E78B                    3499              LSL.L   #3,D3       * shift destination mode bits out
00003A2A  4EB8 1560               3500              JSR     BitTst3     * test the destination register bits
00003A2E  DA46                    3501              ADD.W   D6,D5       * add these to the mode bits
00003A30  0C05 003C               3502              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003A34  6700 0E28               3503              BEQ     OPERROR     * immediate data, there is not allowed, error
00003A38                          3504              * no errors
00003A38  4EB8 1638               3505              JSR     getMode
00003A3C  4DF9 000048CE           3506              LEA     eaTable,A6
00003A42  CCFC 0008               3507              MULU    #8,D6
00003A46  4EB6 6000               3508              JSR     (A6,D6)
00003A4A                          3509              * check for error in EA
00003A4A  0C07 0004               3510              CMPI.B  #4,D7
00003A4E  6700 0E0E               3511              BEQ     OPERROR
00003A52                          3512              * destination must be data register
00003A52  14FC 002C               3513              MOVE.B  #',',(A2)+
00003A56  14FC 0044               3514              MOVE.B  #'D',(A2)+
00003A5A  2604                    3515              MOVE.L  D4,D3   * reset D3
00003A5C  4843                    3516              SWAP    D3
00003A5E  E98B                    3517              LSL.L   #4,D3   * shift out opcode
00003A60  4EB8 1560               3518              JSR     BitTst3 * get data register number
00003A64  CCFC 0008               3519              MULU    #8,D6   * multiply for offset
00003A68  4DF9 00004A6E           3520              LEA     numTable,A6 * load num table
00003A6E  4EB6 6000               3521              JSR     (A6,D6)     * get number from table and print
00003A72                          3522  
00003A72  4E75                    3523              RTS
00003A74                          3524              
00003A74                          3525  * AND.L ----------------------
00003A74                          3526  _AndL       
00003A74  1E3C 0003               3527              MOVE.B  #3,D7       * indicate a long instruction
00003A78  264A                    3528              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003A7A  14FC 0041               3529              MOVE.B  #'A',(A2)+      * add AND.L to A2 String
00003A7E  14FC 004E               3530              MOVE.B  #'N',(A2)+
00003A82  14FC 0044               3531              MOVE.B  #'D',(A2)+
00003A86  14FC 002E               3532              MOVE.B  #'.',(A2)+
00003A8A  14FC 004C               3533              MOVE.B  #'L',(A2)+
00003A8E  14FC 0020               3534              MOVE.B  #' ',(A2)+
00003A92  14FC 0020               3535              MOVE.B  #' ',(A2)+
00003A96  14FC 0020               3536              MOVE.B  #' ',(A2)+
00003A9A  14FC 0020               3537              MOVE.B  #' ',(A2)+
00003A9E  14FC 0020               3538              MOVE.B  #' ',(A2)+
00003AA2                          3539              * get EA
00003AA2  4EB8 1638               3540              JSR     getMode
00003AA6  0C06 0001               3541              CMPI.B  #%001,D6    * source cannot be An
00003AAA  6700 0DB2               3542              BEQ     OPERROR
00003AAE  E74E                    3543              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003AB0  1A06                    3544              MOVE.B  D6,D5       * hold destination mode bits in d5
00003AB2  E78B                    3545              LSL.L   #3,D3       * shift destination mode bits out
00003AB4  4EB8 1560               3546              JSR     BitTst3     * test the destination register bits
00003AB8  DA46                    3547              ADD.W   D6,D5       * add these to the mode bits
00003ABA  0C05 003C               3548              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003ABE  6700 0D9E               3549              BEQ     OPERROR     * immediate data, there is not allowed, error
00003AC2                          3550              * no errors
00003AC2  4EB8 1638               3551              JSR     getMode
00003AC6  4DF9 000048CE           3552              LEA     eaTable,A6
00003ACC  CCFC 0008               3553              MULU    #8,D6
00003AD0  4EB6 6000               3554              JSR     (A6,D6)
00003AD4                          3555              * check for error in EA
00003AD4  0C07 0004               3556              CMPI.B  #4,D7
00003AD8  6700 0D84               3557              BEQ     OPERROR
00003ADC                          3558              * destination must be data register
00003ADC  14FC 002C               3559              MOVE.B  #',',(A2)+
00003AE0  14FC 0044               3560              MOVE.B  #'D',(A2)+
00003AE4  2604                    3561              MOVE.L  D4,D3   * reset D3
00003AE6  4843                    3562              SWAP    D3
00003AE8  E98B                    3563              LSL.L   #4,D3   * shift out opcode
00003AEA  4EB8 1560               3564              JSR     BitTst3 * get data register number
00003AEE  CCFC 0008               3565              MULU    #8,D6   * multiply for offset
00003AF2  4DF9 00004A6E           3566              LEA     numTable,A6 * load num table
00003AF8  4EB6 6000               3567              JSR     (A6,D6)     * get number from table and print
00003AFC                          3568  
00003AFC  4E75                    3569              RTS
00003AFE                          3570  
00003AFE                          3571  _AndEA  
00003AFE  2604                    3572              MOVE.L  D4,D3       * reset D3
00003B00  4843                    3573              SWAP    D3          * swap to front
00003B02  E18B                    3574              LSL.L   #8,D3       * shift out 8 bits so leading 2 bits are the size
00003B04  4EB8 1582               3575              JSR     BitTst2     * get size bits in D6
00003B08  2604                    3576              MOVE.L  D4,D3       * reset D3
00003B0A  4843                    3577              SWAP    D3    
00003B0C                          3578              * check for size
00003B0C  0C06 0000               3579              CMPI.B  #%00,D6 
00003B10  6700 0016               3580              BEQ     _AndBea   * AND.B
00003B14  0C06 0001               3581              CMPI.B  #%01,D6
00003B18  6700 0094               3582              BEQ     _AndWea   * AND.W
00003B1C  0C06 0002               3583              CMPI.B  #%10,D6
00003B20  6700 0112               3584              BEQ     _AndLea   * AND.L
00003B24                          3585              
00003B24  6000 0D38               3586              BRA     OPERROR
00003B28                          3587  
00003B28                          3588  * AND.B to EA ----------------
00003B28                          3589  _AndBea     
00003B28  1E3C 0001               3590              MOVE.B  #1,D7       * indicate a word instruction
00003B2C  264A                    3591              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003B2E  14FC 0041               3592              MOVE.B  #'A',(A2)+      * add AND.L to A2 String
00003B32  14FC 004E               3593              MOVE.B  #'N',(A2)+
00003B36  14FC 0044               3594              MOVE.B  #'D',(A2)+
00003B3A  14FC 002E               3595              MOVE.B  #'.',(A2)+
00003B3E  14FC 004C               3596              MOVE.B  #'L',(A2)+
00003B42  14FC 0020               3597              MOVE.B  #' ',(A2)+
00003B46  14FC 0020               3598              MOVE.B  #' ',(A2)+
00003B4A  14FC 0020               3599              MOVE.B  #' ',(A2)+
00003B4E  14FC 0020               3600              MOVE.B  #' ',(A2)+
00003B52  14FC 0020               3601              MOVE.B  #' ',(A2)+
00003B56  14FC 0044               3602              MOVE.B  #'D',(A2)+  * starting source must be data register
00003B5A  E98B                    3603              LSL.L   #4,D3   * shift out opcode
00003B5C  4EB8 1560               3604              JSR     BitTst3 * get data register number
00003B60  CCFC 0008               3605              MULU    #8,D6   * multiply for offset
00003B64  4DF9 00004A6E           3606              LEA     numTable,A6 * load num table
00003B6A  4EB6 6000               3607              JSR     (A6,D6)     * get number from table and print
00003B6E  14FC 002C               3608              MOVE.B  #',',(A2)+
00003B72                          3609              
00003B72                          3610              * get EA mode and check for errors
00003B72  4EB8 1638               3611              JSR     getMode
00003B76  0C06 0001               3612              CMPI.B  #%001,D6    * cant write to An
00003B7A  6700 0CE2               3613              BEQ     OPERROR
00003B7E  E74E                    3614              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003B80  1A06                    3615              MOVE.B  D6,D5       * hold destination mode bits in d5
00003B82  E78B                    3616              LSL.L   #3,D3       * shift destination mode bits out
00003B84  4EB8 1560               3617              JSR     BitTst3     * test the destination register bits
00003B88  DA46                    3618              ADD.W   D6,D5       * add these to the mode bits
00003B8A  0C05 003C               3619              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003B8E  6700 0CCE               3620              BEQ     OPERROR     * immediate data, there is not allowed, error
00003B92                          3621              
00003B92                          3622              * no errors
00003B92  4EB8 1638               3623              JSR     getMode
00003B96  4DF9 000048CE           3624              LEA     eaTable,A6
00003B9C  CCFC 0008               3625              MULU    #8,D6
00003BA0  4EB6 6000               3626              JSR     (A6,D6)
00003BA4                          3627              * check for error in EA
00003BA4  0C07 0004               3628              CMPI.B  #4,D7
00003BA8  6700 0CB4               3629              BEQ     OPERROR
00003BAC                          3630  
00003BAC  4E75                    3631              RTS
00003BAE                          3632              
00003BAE                          3633  * AND.W to EA ----------------
00003BAE                          3634  _AndWea     
00003BAE  1E3C 0002               3635              MOVE.B  #2,D7       * indicate a word instruction
00003BB2  264A                    3636              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003BB4  14FC 0041               3637              MOVE.B  #'A',(A2)+      * add AND.L to A2 String
00003BB8  14FC 004E               3638              MOVE.B  #'N',(A2)+
00003BBC  14FC 0044               3639              MOVE.B  #'D',(A2)+
00003BC0  14FC 002E               3640              MOVE.B  #'.',(A2)+
00003BC4  14FC 004C               3641              MOVE.B  #'L',(A2)+
00003BC8  14FC 0020               3642              MOVE.B  #' ',(A2)+
00003BCC  14FC 0020               3643              MOVE.B  #' ',(A2)+
00003BD0  14FC 0020               3644              MOVE.B  #' ',(A2)+
00003BD4  14FC 0020               3645              MOVE.B  #' ',(A2)+
00003BD8  14FC 0020               3646              MOVE.B  #' ',(A2)+
00003BDC  14FC 0044               3647              MOVE.B  #'D',(A2)+  * starting source must be data register
00003BE0  E98B                    3648              LSL.L   #4,D3   * shift out opcode
00003BE2  4EB8 1560               3649              JSR     BitTst3 * get data register number
00003BE6  CCFC 0008               3650              MULU    #8,D6   * multiply for offset
00003BEA  4DF9 00004A6E           3651              LEA     numTable,A6 * load num table
00003BF0  4EB6 6000               3652              JSR     (A6,D6)     * get number from table and print
00003BF4  14FC 002C               3653              MOVE.B  #',',(A2)+
00003BF8                          3654              
00003BF8                          3655              * get EA mode and check for errors
00003BF8  4EB8 1638               3656              JSR     getMode
00003BFC  0C06 0001               3657              CMPI.B  #%001,D6    * cant write to An
00003C00  6700 0C5C               3658              BEQ     OPERROR
00003C04  E74E                    3659              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003C06  1A06                    3660              MOVE.B  D6,D5       * hold destination mode bits in d5
00003C08  E78B                    3661              LSL.L   #3,D3       * shift destination mode bits out
00003C0A  4EB8 1560               3662              JSR     BitTst3     * test the destination register bits
00003C0E  DA46                    3663              ADD.W   D6,D5       * add these to the mode bits
00003C10  0C05 003C               3664              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003C14  6700 0C48               3665              BEQ     OPERROR     * immediate data, there is not allowed, error
00003C18                          3666              
00003C18                          3667              * no errors
00003C18  4EB8 1638               3668              JSR     getMode
00003C1C  4DF9 000048CE           3669              LEA     eaTable,A6
00003C22  CCFC 0008               3670              MULU    #8,D6
00003C26  4EB6 6000               3671              JSR     (A6,D6)
00003C2A                          3672              * check for error in EA
00003C2A  0C07 0004               3673              CMPI.B  #4,D7
00003C2E  6700 0C2E               3674              BEQ     OPERROR
00003C32  4E75                    3675              RTS
00003C34                          3676              
00003C34                          3677  * AND.L to EA ----------------
00003C34                          3678  _AndLea     
00003C34  1E3C 0003               3679              MOVE.B  #3,D7       * indicate a long instruction
00003C38  264A                    3680              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003C3A  14FC 0041               3681              MOVE.B  #'A',(A2)+      * add AND.L to A2 String
00003C3E  14FC 004E               3682              MOVE.B  #'N',(A2)+
00003C42  14FC 0044               3683              MOVE.B  #'D',(A2)+
00003C46  14FC 002E               3684              MOVE.B  #'.',(A2)+
00003C4A  14FC 004C               3685              MOVE.B  #'L',(A2)+
00003C4E  14FC 0020               3686              MOVE.B  #' ',(A2)+
00003C52  14FC 0020               3687              MOVE.B  #' ',(A2)+
00003C56  14FC 0020               3688              MOVE.B  #' ',(A2)+
00003C5A  14FC 0020               3689              MOVE.B  #' ',(A2)+
00003C5E  14FC 0020               3690              MOVE.B  #' ',(A2)+
00003C62  14FC 0044               3691              MOVE.B  #'D',(A2)+  * starting source must be data register
00003C66  E98B                    3692              LSL.L   #4,D3   * shift out opcode
00003C68  4EB8 1560               3693              JSR     BitTst3 * get data register number
00003C6C  CCFC 0008               3694              MULU    #8,D6   * multiply for offset
00003C70  4DF9 00004A6E           3695              LEA     numTable,A6 * load num table
00003C76  4EB6 6000               3696              JSR     (A6,D6)     * get number from table and print
00003C7A  14FC 002C               3697              MOVE.B  #',',(A2)+
00003C7E                          3698              
00003C7E                          3699              * get EA mode and check for errors
00003C7E  4EB8 1638               3700              JSR     getMode
00003C82  0C06 0001               3701              CMPI.B  #%001,D6    * cant write to An
00003C86  6700 0BD6               3702              BEQ     OPERROR
00003C8A  E74E                    3703              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003C8C  1A06                    3704              MOVE.B  D6,D5       * hold destination mode bits in d5
00003C8E  E78B                    3705              LSL.L   #3,D3       * shift destination mode bits out
00003C90  4EB8 1560               3706              JSR     BitTst3     * test the destination register bits
00003C94  DA46                    3707              ADD.W   D6,D5       * add these to the mode bits
00003C96  0C05 003C               3708              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003C9A  6700 0BC2               3709              BEQ     OPERROR     * immediate data, there is not allowed, error
00003C9E                          3710              
00003C9E                          3711              * no errors
00003C9E  4EB8 1638               3712              JSR     getMode
00003CA2  4DF9 000048CE           3713              LEA     eaTable,A6
00003CA8  CCFC 0008               3714              MULU    #8,D6
00003CAC  4EB6 6000               3715              JSR     (A6,D6)
00003CB0                          3716              * check for error in EA
00003CB0  0C07 0004               3717              CMPI.B  #4,D7
00003CB4  6700 0BA8               3718              BEQ     OPERROR
00003CB8  4E75                    3719              RTS               
00003CBA                          3720  
00003CBA                          3721  * ADD, ADDA -------------------------------------------------------------------------
00003CBA                          3722  op1101      
00003CBA  4843                    3723              SWAP    D3
00003CBC  E18B                    3724              LSL.L   #8,D3   * shift out op code and next four bits
00003CBE  4EB8 1582               3725              JSR     BitTst2 * check next two bits for size/MUL instruction
00003CC2  2604                    3726              MOVE.L  D4,D3   * reset D3
00003CC4  0C06 0003               3727              CMPI.B  #%11,D6 * if bits 6-7 are 11, it is ADDA
00003CC8  6700 0380               3728              BEQ     _AddA
00003CCC                          3729              
00003CCC                          3730              * figure out direction of ADD
00003CCC  0803 0008               3731              BTST.L  #$08,D3 * if 8th bit is 1, <ea> * dn -> <ea>
00003CD0  6600 01BC               3732              BNE     _AddEA  * branch to add to EA
00003CD4                          3733              * it is basic ADD
00003CD4  0C06 0000               3734              CMPI.B  #%00,D6
00003CD8  6700 0016               3735              BEQ     _AddB
00003CDC  0C06 0001               3736              CMPI.B  #%01,D6
00003CE0  6700 0098               3737              BEQ     _AddW
00003CE4  0C06 0002               3738              CMPI.B  #%10,D6
00003CE8  6700 011A               3739              BEQ     _AddL
00003CEC                          3740              
00003CEC  6000 0B70               3741              BRA     OPERROR
00003CF0                          3742              
00003CF0                          3743  * ADD.B ----------------------
00003CF0                          3744  _AddB       
00003CF0  1E3C 0001               3745              MOVE.B  #1,D7       * indicate a byte instruction
00003CF4  264A                    3746              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003CF6  14FC 0041               3747              MOVE.B  #'A',(A2)+      * add ADD.B to A2 String
00003CFA  14FC 0044               3748              MOVE.B  #'D',(A2)+
00003CFE  14FC 0044               3749              MOVE.B  #'D',(A2)+
00003D02  14FC 002E               3750              MOVE.B  #'.',(A2)+
00003D06  14FC 0042               3751              MOVE.B  #'B',(A2)+
00003D0A  14FC 0020               3752              MOVE.B  #' ',(A2)+
00003D0E  14FC 0020               3753              MOVE.B  #' ',(A2)+
00003D12  14FC 0020               3754              MOVE.B  #' ',(A2)+
00003D16  14FC 0020               3755              MOVE.B  #' ',(A2)+
00003D1A  14FC 0020               3756              MOVE.B  #' ',(A2)+
00003D1E                          3757              * get EA
00003D1E  4EB8 1638               3758              JSR     getMode
00003D22  0C06 0001               3759              CMPI.B  #%001,D6    * source cannot be An
00003D26  6700 0B36               3760              BEQ     OPERROR
00003D2A  E74E                    3761              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003D2C  1A06                    3762              MOVE.B  D6,D5       * hold destination mode bits in d5
00003D2E  E78B                    3763              LSL.L   #3,D3       * shift destination mode bits out
00003D30  4EB8 1560               3764              JSR     BitTst3     * test the destination register bits
00003D34  DA46                    3765              ADD.W   D6,D5       * add these to the mode bits
00003D36  0C05 003C               3766              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003D3A  6700 0B22               3767              BEQ     OPERROR     * immediate data, there is not allowed, error
00003D3E                          3768              * no errors
00003D3E  4EB8 1638               3769              JSR     getMode
00003D42  4DF9 000048CE           3770              LEA     eaTable,A6
00003D48  CCFC 0008               3771              MULU    #8,D6
00003D4C  4EB6 6000               3772              JSR     (A6,D6)
00003D50                          3773              * check for error in EA
00003D50  0C07 0004               3774              CMPI.B  #4,D7
00003D54  6700 0B08               3775              BEQ     OPERROR
00003D58                          3776              * destination must be data register
00003D58  14FC 002C               3777              MOVE.B  #',',(A2)+
00003D5C  14FC 0044               3778              MOVE.B  #'D',(A2)+
00003D60  2604                    3779              MOVE.L  D4,D3   * reset D3
00003D62  4843                    3780              SWAP    D3
00003D64  E98B                    3781              LSL.L   #4,D3   * shift out opcode
00003D66  4EB8 1560               3782              JSR     BitTst3 * get data register number
00003D6A  CCFC 0008               3783              MULU    #8,D6   * multiply for offset
00003D6E  4DF9 00004A6E           3784              LEA     numTable,A6 * load num table
00003D74  4EB6 6000               3785              JSR     (A6,D6)     * get number from table and print
00003D78  4E75                    3786              RTS 
00003D7A                          3787              
00003D7A                          3788  * ADD.W ----------------------
00003D7A                          3789  _AddW       
00003D7A  1E3C 0002               3790              MOVE.B  #2,D7       * indicate a word instruction
00003D7E  264A                    3791              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003D80  14FC 0041               3792              MOVE.B  #'A',(A2)+      * add ADD.W to A2 String
00003D84  14FC 0044               3793              MOVE.B  #'D',(A2)+
00003D88  14FC 0044               3794              MOVE.B  #'D',(A2)+
00003D8C  14FC 002E               3795              MOVE.B  #'.',(A2)+
00003D90  14FC 0057               3796              MOVE.B  #'W',(A2)+
00003D94  14FC 0020               3797              MOVE.B  #' ',(A2)+
00003D98  14FC 0020               3798              MOVE.B  #' ',(A2)+
00003D9C  14FC 0020               3799              MOVE.B  #' ',(A2)+
00003DA0  14FC 0020               3800              MOVE.B  #' ',(A2)+
00003DA4  14FC 0020               3801              MOVE.B  #' ',(A2)+
00003DA8                          3802              * get EA
00003DA8  4EB8 1638               3803              JSR     getMode
00003DAC  0C06 0001               3804              CMPI.B  #%001,D6    * source cannot be An
00003DB0  6700 0AAC               3805              BEQ     OPERROR
00003DB4  E74E                    3806              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003DB6  1A06                    3807              MOVE.B  D6,D5       * hold destination mode bits in d5
00003DB8  E78B                    3808              LSL.L   #3,D3       * shift destination mode bits out
00003DBA  4EB8 1560               3809              JSR     BitTst3     * test the destination register bits
00003DBE  DA46                    3810              ADD.W   D6,D5       * add these to the mode bits
00003DC0  0C05 003C               3811              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003DC4  6700 0A98               3812              BEQ     OPERROR     * immediate data, there is not allowed, error
00003DC8                          3813              * no errors
00003DC8  4EB8 1638               3814              JSR     getMode
00003DCC  4DF9 000048CE           3815              LEA     eaTable,A6
00003DD2  CCFC 0008               3816              MULU    #8,D6
00003DD6  4EB6 6000               3817              JSR     (A6,D6)
00003DDA                          3818              * check for error in EA
00003DDA  0C07 0004               3819              CMPI.B  #4,D7
00003DDE  6700 0A7E               3820              BEQ     OPERROR
00003DE2                          3821              * destination must be data register
00003DE2  14FC 002C               3822              MOVE.B  #',',(A2)+
00003DE6  14FC 0044               3823              MOVE.B  #'D',(A2)+
00003DEA  2604                    3824              MOVE.L  D4,D3   * reset D3
00003DEC  4843                    3825              SWAP    D3
00003DEE  E98B                    3826              LSL.L   #4,D3   * shift out opcode
00003DF0  4EB8 1560               3827              JSR     BitTst3 * get data register number
00003DF4  CCFC 0008               3828              MULU    #8,D6   * multiply for offset
00003DF8  4DF9 00004A6E           3829              LEA     numTable,A6 * load num table
00003DFE  4EB6 6000               3830              JSR     (A6,D6)     * get number from table and print
00003E02  4E75                    3831              RTS 
00003E04                          3832  
00003E04                          3833  * ADD.L ----------------------
00003E04                          3834  _AddL       
00003E04  1E3C 0003               3835              MOVE.B  #3,D7       * indicate a long instruction
00003E08  264A                    3836              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003E0A  14FC 0041               3837              MOVE.B  #'A',(A2)+      * add ADD.L to A2 String
00003E0E  14FC 0044               3838              MOVE.B  #'D',(A2)+
00003E12  14FC 0044               3839              MOVE.B  #'D',(A2)+
00003E16  14FC 002E               3840              MOVE.B  #'.',(A2)+
00003E1A  14FC 004C               3841              MOVE.B  #'L',(A2)+
00003E1E  14FC 0020               3842              MOVE.B  #' ',(A2)+
00003E22  14FC 0020               3843              MOVE.B  #' ',(A2)+
00003E26  14FC 0020               3844              MOVE.B  #' ',(A2)+
00003E2A  14FC 0020               3845              MOVE.B  #' ',(A2)+
00003E2E  14FC 0020               3846              MOVE.B  #' ',(A2)+
00003E32                          3847              * get EA
00003E32  4EB8 1638               3848              JSR     getMode
00003E36  0C06 0001               3849              CMPI.B  #%001,D6    * source cannot be An
00003E3A  6700 0A22               3850              BEQ     OPERROR
00003E3E  E74E                    3851              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003E40  1A06                    3852              MOVE.B  D6,D5       * hold destination mode bits in d5
00003E42  E78B                    3853              LSL.L   #3,D3       * shift destination mode bits out
00003E44  4EB8 1560               3854              JSR     BitTst3     * test the destination register bits
00003E48  DA46                    3855              ADD.W   D6,D5       * add these to the mode bits
00003E4A  0C05 003C               3856              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003E4E  6700 0A0E               3857              BEQ     OPERROR     * immediate data, there is not allowed, error
00003E52                          3858              * no errors
00003E52  4EB8 1638               3859              JSR     getMode
00003E56  4DF9 000048CE           3860              LEA     eaTable,A6
00003E5C  CCFC 0008               3861              MULU    #8,D6
00003E60  4EB6 6000               3862              JSR     (A6,D6)
00003E64                          3863              * check for error in EA
00003E64  0C07 0004               3864              CMPI.B  #4,D7
00003E68  6700 09F4               3865              BEQ     OPERROR
00003E6C                          3866              * destination must be data register
00003E6C  14FC 002C               3867              MOVE.B  #',',(A2)+
00003E70  14FC 0044               3868              MOVE.B  #'D',(A2)+
00003E74  2604                    3869              MOVE.L  D4,D3   * reset D3
00003E76  4843                    3870              SWAP    D3
00003E78  E98B                    3871              LSL.L   #4,D3   * shift out opcode
00003E7A  4EB8 1560               3872              JSR     BitTst3 * get data register number
00003E7E  CCFC 0008               3873              MULU    #8,D6   * multiply for offset
00003E82  4DF9 00004A6E           3874              LEA     numTable,A6 * load num table
00003E88  4EB6 6000               3875              JSR     (A6,D6)     * get number from table and print
00003E8C  4E75                    3876              RTS 
00003E8E                          3877        
00003E8E                          3878  
00003E8E                          3879  _AddEA      
00003E8E  2604                    3880              MOVE.L  D4,D3       * reset D3
00003E90  4843                    3881              SWAP    D3          * swap to front
00003E92  E18B                    3882              LSL.L   #8,D3       * shift out 8 bits so leading 2 bits are the size
00003E94  4EB8 1582               3883              JSR     BitTst2     * get size bits in D6
00003E98  2604                    3884              MOVE.L  D4,D3       * reset D3
00003E9A  4843                    3885              SWAP    D3  
00003E9C  0C06 0000               3886              CMPI.B  #%00,D6
00003EA0  6700 0016               3887              BEQ     _AddBea
00003EA4  0C06 0001               3888              CMPI.B  #%01,D6
00003EA8  6700 0094               3889              BEQ     _AddWea
00003EAC  0C06 0002               3890              CMPI.B  #%10,D6
00003EB0  6700 0112               3891              BEQ     _AddLea
00003EB4                          3892              
00003EB4  6000 09A8               3893              BRA     OPERROR
00003EB8                          3894              
00003EB8                          3895  * ADD.B to EA ----------------            
00003EB8                          3896  _AddBea     
00003EB8  1E3C 0001               3897              MOVE.B  #1,D7       * indicate a byte instruction
00003EBC  264A                    3898              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003EBE  14FC 0041               3899              MOVE.B  #'A',(A2)+      * add ADD.B to A2 String
00003EC2  14FC 0044               3900              MOVE.B  #'D',(A2)+
00003EC6  14FC 0044               3901              MOVE.B  #'D',(A2)+
00003ECA  14FC 002E               3902              MOVE.B  #'.',(A2)+
00003ECE  14FC 0042               3903              MOVE.B  #'B',(A2)+
00003ED2  14FC 0020               3904              MOVE.B  #' ',(A2)+
00003ED6  14FC 0020               3905              MOVE.B  #' ',(A2)+
00003EDA  14FC 0020               3906              MOVE.B  #' ',(A2)+
00003EDE  14FC 0020               3907              MOVE.B  #' ',(A2)+
00003EE2  14FC 0020               3908              MOVE.B  #' ',(A2)+
00003EE6  14FC 0044               3909              MOVE.B  #'D',(A2)+  * starting source must be data register
00003EEA  E98B                    3910              LSL.L   #4,D3   * shift out opcode
00003EEC  4EB8 1560               3911              JSR     BitTst3 * get data register number
00003EF0  CCFC 0008               3912              MULU    #8,D6   * multiply for offset
00003EF4  4DF9 00004A6E           3913              LEA     numTable,A6 * load num table
00003EFA  4EB6 6000               3914              JSR     (A6,D6)     * get number from table and print
00003EFE  14FC 002C               3915              MOVE.B  #',',(A2)+
00003F02                          3916              
00003F02                          3917              * get EA mode and check for errors
00003F02  4EB8 1638               3918              JSR     getMode
00003F06  0C06 0001               3919              CMPI.B  #%001,D6    * cant write to An
00003F0A  6700 0952               3920              BEQ     OPERROR
00003F0E  E74E                    3921              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003F10  1A06                    3922              MOVE.B  D6,D5       * hold destination mode bits in d5
00003F12  E78B                    3923              LSL.L   #3,D3       * shift destination mode bits out
00003F14  4EB8 1560               3924              JSR     BitTst3     * test the destination register bits
00003F18  DA46                    3925              ADD.W   D6,D5       * add these to the mode bits
00003F1A  0C05 003C               3926              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003F1E  6700 093E               3927              BEQ     OPERROR     * immediate data, there is not allowed, error
00003F22                          3928              
00003F22                          3929              * no errors
00003F22  4EB8 1638               3930              JSR     getMode
00003F26  4DF9 000048CE           3931              LEA     eaTable,A6
00003F2C  CCFC 0008               3932              MULU    #8,D6
00003F30  4EB6 6000               3933              JSR     (A6,D6)
00003F34                          3934              * check for error in EA
00003F34  0C07 0004               3935              CMPI.B  #4,D7
00003F38  6700 0924               3936              BEQ     OPERROR
00003F3C  4E75                    3937              RTS
00003F3E                          3938              
00003F3E                          3939  * ADD.W to EA ----------------
00003F3E                          3940  _AddWea     
00003F3E  1E3C 0002               3941              MOVE.B  #2,D7       * indicate a long instruction
00003F42  264A                    3942              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003F44  14FC 0041               3943              MOVE.B  #'A',(A2)+      * add ADD.W to A2 String
00003F48  14FC 0044               3944              MOVE.B  #'D',(A2)+
00003F4C  14FC 0044               3945              MOVE.B  #'D',(A2)+
00003F50  14FC 002E               3946              MOVE.B  #'.',(A2)+
00003F54  14FC 0057               3947              MOVE.B  #'W',(A2)+
00003F58  14FC 0020               3948              MOVE.B  #' ',(A2)+
00003F5C  14FC 0020               3949              MOVE.B  #' ',(A2)+
00003F60  14FC 0020               3950              MOVE.B  #' ',(A2)+
00003F64  14FC 0020               3951              MOVE.B  #' ',(A2)+
00003F68  14FC 0020               3952              MOVE.B  #' ',(A2)+
00003F6C  14FC 0044               3953              MOVE.B  #'D',(A2)+  * starting source must be data register
00003F70  E98B                    3954              LSL.L   #4,D3   * shift out opcode
00003F72  4EB8 1560               3955              JSR     BitTst3 * get data register number
00003F76  CCFC 0008               3956              MULU    #8,D6   * multiply for offset
00003F7A  4DF9 00004A6E           3957              LEA     numTable,A6 * load num table
00003F80  4EB6 6000               3958              JSR     (A6,D6)     * get number from table and print
00003F84  14FC 002C               3959              MOVE.B  #',',(A2)+
00003F88                          3960              
00003F88                          3961              * get EA mode and check for errors
00003F88  4EB8 1638               3962              JSR     getMode
00003F8C  0C06 0001               3963              CMPI.B  #%001,D6    * cant write to An
00003F90  6700 08CC               3964              BEQ     OPERROR
00003F94  E74E                    3965              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003F96  1A06                    3966              MOVE.B  D6,D5       * hold destination mode bits in d5
00003F98  E78B                    3967              LSL.L   #3,D3       * shift destination mode bits out
00003F9A  4EB8 1560               3968              JSR     BitTst3     * test the destination register bits
00003F9E  DA46                    3969              ADD.W   D6,D5       * add these to the mode bits
00003FA0  0C05 003C               3970              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003FA4  6700 08B8               3971              BEQ     OPERROR     * immediate data, there is not allowed, error
00003FA8                          3972              
00003FA8                          3973              * no errors
00003FA8  4EB8 1638               3974              JSR     getMode
00003FAC  4DF9 000048CE           3975              LEA     eaTable,A6
00003FB2  CCFC 0008               3976              MULU    #8,D6
00003FB6  4EB6 6000               3977              JSR     (A6,D6)
00003FBA                          3978              * check for error in EA
00003FBA  0C07 0004               3979              CMPI.B  #4,D7
00003FBE  6700 089E               3980              BEQ     OPERROR
00003FC2  4E75                    3981              RTS
00003FC4                          3982              
00003FC4                          3983  * ADD.L to EA ----------------
00003FC4                          3984  _AddLea     
00003FC4  1E3C 0003               3985              MOVE.B  #3,D7       * indicate a long instruction
00003FC8  264A                    3986              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003FCA  14FC 0041               3987              MOVE.B  #'A',(A2)+      * add ADD.L to A2 String
00003FCE  14FC 0044               3988              MOVE.B  #'D',(A2)+
00003FD2  14FC 0044               3989              MOVE.B  #'D',(A2)+
00003FD6  14FC 002E               3990              MOVE.B  #'.',(A2)+
00003FDA  14FC 004C               3991              MOVE.B  #'L',(A2)+
00003FDE  14FC 0020               3992              MOVE.B  #' ',(A2)+
00003FE2  14FC 0020               3993              MOVE.B  #' ',(A2)+
00003FE6  14FC 0020               3994              MOVE.B  #' ',(A2)+
00003FEA  14FC 0020               3995              MOVE.B  #' ',(A2)+
00003FEE  14FC 0020               3996              MOVE.B  #' ',(A2)+
00003FF2  14FC 0044               3997              MOVE.B  #'D',(A2)+  * starting source must be data register
00003FF6  E98B                    3998              LSL.L   #4,D3   * shift out opcode
00003FF8  4EB8 1560               3999              JSR     BitTst3 * get data register number
00003FFC  CCFC 0008               4000              MULU    #8,D6   * multiply for offset
00004000  4DF9 00004A6E           4001              LEA     numTable,A6 * load num table
00004006  4EB6 6000               4002              JSR     (A6,D6)     * get number from table and print
0000400A  14FC 002C               4003              MOVE.B  #',',(A2)+
0000400E                          4004              
0000400E                          4005              * get EA mode and check for errors
0000400E  4EB8 1638               4006              JSR     getMode
00004012  0C06 0001               4007              CMPI.B  #%001,D6    * cant write to An
00004016  6700 0846               4008              BEQ     OPERROR
0000401A  E74E                    4009              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000401C  1A06                    4010              MOVE.B  D6,D5       * hold destination mode bits in d5
0000401E  E78B                    4011              LSL.L   #3,D3       * shift destination mode bits out
00004020  4EB8 1560               4012              JSR     BitTst3     * test the destination register bits
00004024  DA46                    4013              ADD.W   D6,D5       * add these to the mode bits
00004026  0C05 003C               4014              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000402A  6700 0832               4015              BEQ     OPERROR     * immediate data, there is not allowed, error
0000402E                          4016              
0000402E                          4017              * no errors
0000402E  4EB8 1638               4018              JSR     getMode
00004032  4DF9 000048CE           4019              LEA     eaTable,A6
00004038  CCFC 0008               4020              MULU    #8,D6
0000403C  4EB6 6000               4021              JSR     (A6,D6)
00004040                          4022              * check for error in EA
00004040  0C07 0004               4023              CMPI.B  #4,D7
00004044  6700 0818               4024              BEQ     OPERROR
00004048  4E75                    4025              RTS
0000404A                          4026              
0000404A                          4027  * ADDA -------------------------------------------------------------------            
0000404A  0803 0008               4028  _AddA       BTST.L  #$08,D3     * check the size bit of ADDA
0000404E  6700 006C               4029              BEQ     _AddAw      * if 0, go to ADDA.W
00004052                          4030              
00004052                          4031              * proceed as if ADDA.L
00004052                          4032  * ADDA.L ---------------------
00004052  1E3C 0003               4033              MOVE.B  #3,D7       * indicate a long instruction
00004056  264A                    4034              MOVEA.L A2,A3       * copy current address of A2 string to A3
00004058  14FC 0041               4035              MOVE.B  #'A',(A2)+      * add ADDA.L to A2 String
0000405C  14FC 0044               4036              MOVE.B  #'D',(A2)+
00004060  14FC 0044               4037              MOVE.B  #'D',(A2)+
00004064  14FC 0041               4038              MOVE.B  #'A',(A2)+
00004068  14FC 002E               4039              MOVE.B  #'.',(A2)+
0000406C  14FC 004C               4040              MOVE.B  #'L',(A2)+
00004070  14FC 0020               4041              MOVE.B  #' ',(A2)+
00004074  14FC 0020               4042              MOVE.B  #' ',(A2)+
00004078  14FC 0020               4043              MOVE.B  #' ',(A2)+
0000407C  14FC 0020               4044              MOVE.B  #' ',(A2)+
00004080                          4045              *get EA
00004080  4EB8 1638               4046              JSR     getMode
00004084  4DF9 000048CE           4047              LEA     eaTable,A6
0000408A  CCFC 0008               4048              MULU    #8,D6
0000408E  4EB6 6000               4049              JSR     (A6,D6)
00004092                          4050              * check for error in EA
00004092  0C07 0004               4051              CMPI.B  #4,D7
00004096  6700 07C6               4052              BEQ     OPERROR
0000409A                          4053              * destination must be address register
0000409A  14FC 002C               4054              MOVE.B  #',',(A2)+
0000409E  14FC 0041               4055              MOVE.B  #'A',(A2)+
000040A2  2604                    4056              MOVE.L  D4,D3   * reset D3
000040A4  4843                    4057              SWAP    D3
000040A6  E98B                    4058              LSL.L   #4,D3   * shift out opcode
000040A8  4EB8 1560               4059              JSR     BitTst3 * get data register number
000040AC  CCFC 0008               4060              MULU    #8,D6   * multiply for offset
000040B0  4DF9 00004A6E           4061              LEA     numTable,A6 * load num table
000040B6  4EB6 6000               4062              JSR     (A6,D6)     * get number from table and print
000040BA  4E75                    4063              RTS
000040BC                          4064              
000040BC                          4065  * ADDA.W ---------------------    
000040BC                          4066  _AddAw      
000040BC  1E3C 0002               4067              MOVE.B  #2,D7       * indicate a word instruction
000040C0  264A                    4068              MOVEA.L A2,A3       * copy current address of A2 string to A3
000040C2  14FC 0041               4069              MOVE.B  #'A',(A2)+      * add ADDA.W to A2 String
000040C6  14FC 0044               4070              MOVE.B  #'D',(A2)+
000040CA  14FC 0044               4071              MOVE.B  #'D',(A2)+
000040CE  14FC 0041               4072              MOVE.B  #'A',(A2)+
000040D2  14FC 002E               4073              MOVE.B  #'.',(A2)+
000040D6  14FC 0057               4074              MOVE.B  #'W',(A2)+
000040DA  14FC 0020               4075              MOVE.B  #' ',(A2)+
000040DE  14FC 0020               4076              MOVE.B  #' ',(A2)+
000040E2  14FC 0020               4077              MOVE.B  #' ',(A2)+
000040E6  14FC 0020               4078              MOVE.B  #' ',(A2)+
000040EA                          4079              *get EA
000040EA  4EB8 1638               4080              JSR     getMode
000040EE  4DF9 000048CE           4081              LEA     eaTable,A6
000040F4  CCFC 0008               4082              MULU    #8,D6
000040F8  4EB6 6000               4083              JSR     (A6,D6)
000040FC                          4084              * check for error in EA
000040FC  0C07 0004               4085              CMPI.B  #4,D7
00004100  6700 075C               4086              BEQ     OPERROR
00004104                          4087              * destination must be address register
00004104  14FC 002C               4088              MOVE.B  #',',(A2)+
00004108  14FC 0041               4089              MOVE.B  #'A',(A2)+
0000410C  2604                    4090              MOVE.L  D4,D3   * reset D3
0000410E  4843                    4091              SWAP    D3
00004110  E98B                    4092              LSL.L   #4,D3   * shift out opcode
00004112  4EB8 1560               4093              JSR     BitTst3 * get data register number
00004116  CCFC 0008               4094              MULU    #8,D6   * multiply for offset
0000411A  4DF9 00004A6E           4095              LEA     numTable,A6 * load num table
00004120  4EB6 6000               4096              JSR     (A6,D6)     * get number from table and print
00004124  4E75                    4097              RTS
00004126                          4098              
00004126                          4099  * LSL, LSR, ASL, ASR, ROL, ROR, ROXL, ROXR ---------------------------------------            
00004126                          4100  op1110
00004126  4EB8 159A               4101              JSR     getSize     * get size bits
0000412A  0C06 0003               4102              CMPI.B  #%11,D6
0000412E  6600 01CC               4103              BNE     _ShiftReg   * if the size isnt 11, it is a reg shift
00004132                          4104              * it is a mem shift
00004132                          4105              * determine type of shift
00004132  EB8B                    4106              LSL.L   #5,D3
00004134  4EB8 1582               4107              JSR     BitTst2
00004138  0C06 0000               4108              CMPI.B  #%00,D6
0000413C  6700 0072               4109              BEQ     _As     * arithmetic shift
00004140  0C06 0001               4110              CMPI.B  #%01,D6
00004144  6700 00CA               4111              BEQ     _Ls     * logical shift
00004148  0C06 0002               4112              CMPI.B  #%10,D6
0000414C  6700 0122               4113              BEQ     _Rox    * roll extend
00004150                          4114              * proceed as if it is a roll
00004150  0803 001D               4115              BTST.L  #$1D,D3 * test the 8th bit of the instruction
00004154  6700 002E               4116              BEQ     _Ror    * if 0, it is a roll right
00004158                          4117              
00004158                          4118  * ROL ------------------------
00004158                          4119              * it is a ROL instruction
00004158  14FC 0052               4120              MOVE.B  #'R',(A2)+ * add "ROL" to A2 string
0000415C  14FC 004F               4121              MOVE.B  #'O',(A2)+
00004160  14FC 004C               4122              MOVE.B  #'L',(A2)+
00004164  14FC 0020               4123              MOVE.B  #' ',(A2)+
00004168  14FC 0020               4124              MOVE.B  #' ',(A2)+
0000416C  14FC 0020               4125              MOVE.B  #' ',(A2)+
00004170  14FC 0020               4126              MOVE.B  #' ',(A2)+
00004174  14FC 0020               4127              MOVE.B  #' ',(A2)+
00004178  14FC 0020               4128              MOVE.B  #' ',(A2)+
0000417C  14FC 0020               4129              MOVE.B  #' ',(A2)+
00004180  6000 0156               4130              BRA     _shftMemEA  * finish by branching to shift to mem EA
00004184                          4131              
00004184                          4132  * ROR ------------------------                       
00004184                          4133  _Ror        
00004184  14FC 0052               4134              MOVE.B  #'R',(A2)+ * add "ROR" to A2 string
00004188  14FC 004F               4135              MOVE.B  #'O',(A2)+
0000418C  14FC 0052               4136              MOVE.B  #'R',(A2)+
00004190  14FC 0020               4137              MOVE.B  #' ',(A2)+
00004194  14FC 0020               4138              MOVE.B  #' ',(A2)+
00004198  14FC 0020               4139              MOVE.B  #' ',(A2)+
0000419C  14FC 0020               4140              MOVE.B  #' ',(A2)+
000041A0  14FC 0020               4141              MOVE.B  #' ',(A2)+
000041A4  14FC 0020               4142              MOVE.B  #' ',(A2)+
000041A8  14FC 0020               4143              MOVE.B  #' ',(A2)+
000041AC  6000 012A               4144              BRA     _shftMemEA * finish by branching to shift to mem EA
000041B0                          4145              
000041B0  0803 001D               4146  _As         BTST.L  #$1D,D3 * test the 8th bit of the instruction
000041B4  6700 002E               4147              BEQ     _Asr    * if 1, it is right
000041B8                          4148              * not so it is left
000041B8                          4149  * ASL ------------------------
000041B8  14FC 0041               4150              MOVE.B  #'A',(A2)+ * add "ASL" to A2 string
000041BC  14FC 0053               4151              MOVE.B  #'S',(A2)+
000041C0  14FC 004C               4152              MOVE.B  #'L',(A2)+
000041C4  14FC 0020               4153              MOVE.B  #' ',(A2)+
000041C8  14FC 0020               4154              MOVE.B  #' ',(A2)+
000041CC  14FC 0020               4155              MOVE.B  #' ',(A2)+
000041D0  14FC 0020               4156              MOVE.B  #' ',(A2)+
000041D4  14FC 0020               4157              MOVE.B  #' ',(A2)+
000041D8  14FC 0020               4158              MOVE.B  #' ',(A2)+
000041DC  14FC 0020               4159              MOVE.B  #' ',(A2)+
000041E0  6000 00F6               4160              BRA     _shftMemEA * finish by branching to shift to mem EA
000041E4                          4161              
000041E4                          4162  * ASR ------------------------            
000041E4  14FC 0041               4163  _Asr        MOVE.B  #'A',(A2)+ * add "ASR" to A2 string
000041E8  14FC 0053               4164              MOVE.B  #'S',(A2)+
000041EC  14FC 0052               4165              MOVE.B  #'R',(A2)+
000041F0  14FC 0020               4166              MOVE.B  #' ',(A2)+
000041F4  14FC 0020               4167              MOVE.B  #' ',(A2)+
000041F8  14FC 0020               4168              MOVE.B  #' ',(A2)+
000041FC  14FC 0020               4169              MOVE.B  #' ',(A2)+
00004200  14FC 0020               4170              MOVE.B  #' ',(A2)+
00004204  14FC 0020               4171              MOVE.B  #' ',(A2)+
00004208  14FC 0020               4172              MOVE.B  #' ',(A2)+
0000420C  6000 00CA               4173              BRA     _shftMemEA * finish by branching to shift to mem EA
00004210                          4174              
00004210                          4175              
00004210  0803 001D               4176  _Ls         BTST.L  #$1D,D3 * test the 8th bit of the instruction
00004214  6700 002E               4177              BEQ     _Lsr    * if 1, it is right
00004218                          4178              * not so it is left
00004218                          4179  * LSL ------------------------
00004218  14FC 004C               4180              MOVE.B  #'L',(A2)+ * add "LSL" to A2 string
0000421C  14FC 0053               4181              MOVE.B  #'S',(A2)+
00004220  14FC 004C               4182              MOVE.B  #'L',(A2)+
00004224  14FC 0020               4183              MOVE.B  #' ',(A2)+
00004228  14FC 0020               4184              MOVE.B  #' ',(A2)+
0000422C  14FC 0020               4185              MOVE.B  #' ',(A2)+
00004230  14FC 0020               4186              MOVE.B  #' ',(A2)+
00004234  14FC 0020               4187              MOVE.B  #' ',(A2)+
00004238  14FC 0020               4188              MOVE.B  #' ',(A2)+
0000423C  14FC 0020               4189              MOVE.B  #' ',(A2)+
00004240  6000 0096               4190              BRA     _shftMemEA * finish by branching to shift to mem EA
00004244                          4191              
00004244                          4192  * LSR ------------------------            
00004244  14FC 004C               4193  _Lsr        MOVE.B  #'L',(A2)+ * add "LSR" to A2 string
00004248  14FC 0053               4194              MOVE.B  #'S',(A2)+
0000424C  14FC 0052               4195              MOVE.B  #'R',(A2)+
00004250  14FC 0020               4196              MOVE.B  #' ',(A2)+
00004254  14FC 0020               4197              MOVE.B  #' ',(A2)+
00004258  14FC 0020               4198              MOVE.B  #' ',(A2)+
0000425C  14FC 0020               4199              MOVE.B  #' ',(A2)+
00004260  14FC 0020               4200              MOVE.B  #' ',(A2)+
00004264  14FC 0020               4201              MOVE.B  #' ',(A2)+
00004268  14FC 0020               4202              MOVE.B  #' ',(A2)+
0000426C  6000 006A               4203              BRA     _shftMemEA * finish by branching to shift to mem EA
00004270                          4204              
00004270                          4205  * ROXL -----------------------            
00004270  0803 001D               4206  _Rox        BTST.L  #$1D,D3 * test the 8th bit of the instruction
00004274  6700 0032               4207              BEQ     _Roxr   * if 1, it is right
00004278                          4208              * not, so it is left
00004278  14FC 0052               4209              MOVE.B  #'R',(A2)+ * add "ROXL" to A2 string
0000427C  14FC 004F               4210              MOVE.B  #'O',(A2)+
00004280  14FC 0058               4211              MOVE.B  #'X',(A2)+
00004284  14FC 004C               4212              MOVE.B  #'L',(A2)+
00004288  14FC 0020               4213              MOVE.B  #' ',(A2)+
0000428C  14FC 0020               4214              MOVE.B  #' ',(A2)+
00004290  14FC 0020               4215              MOVE.B  #' ',(A2)+
00004294  14FC 0020               4216              MOVE.B  #' ',(A2)+
00004298  14FC 0020               4217              MOVE.B  #' ',(A2)+
0000429C  14FC 0020               4218              MOVE.B  #' ',(A2)+
000042A0  14FC 0020               4219              MOVE.B  #' ',(A2)+
000042A4  6000 0032               4220              BRA     _shftMemEA * finish by branching to shift to mem EA
000042A8                          4221              
000042A8                          4222  * ROXR -----------------------           
000042A8  14FC 0052               4223  _Roxr       MOVE.B  #'R',(A2)+ * add "ROXR" to A2 string
000042AC  14FC 004F               4224              MOVE.B  #'O',(A2)+
000042B0  14FC 0058               4225              MOVE.B  #'X',(A2)+
000042B4  14FC 0052               4226              MOVE.B  #'R',(A2)+
000042B8  14FC 0020               4227              MOVE.B  #' ',(A2)+
000042BC  14FC 0020               4228              MOVE.B  #' ',(A2)+
000042C0  14FC 0020               4229              MOVE.B  #' ',(A2)+
000042C4  14FC 0020               4230              MOVE.B  #' ',(A2)+
000042C8  14FC 0020               4231              MOVE.B  #' ',(A2)+
000042CC  14FC 0020               4232              MOVE.B  #' ',(A2)+
000042D0  14FC 0020               4233              MOVE.B  #' ',(A2)+
000042D4  6000 0002               4234              BRA     _shftMemEA * finish by branching to shift to mem EA
000042D8                          4235              
000042D8                          4236  _shftMemEA  
000042D8  4EB8 1638               4237              JSR     getMode     * get the mode
000042DC  0C06 0001               4238              CMPI.B  #%001,D6    * cant be Dn, or An
000042E0  6F00 057C               4239              BLE     OPERROR     * branch to error
000042E4  4DF9 000048CE           4240              LEA     eaTable,A6   * load ea table
000042EA  CCFC 0008               4241              MULU    #8,D6       * multiply by 8 for table jump
000042EE  4EB6 6000               4242              JSR     (A6,D6)     * jump to ea
000042F2                          4243              * check for error in EA
000042F2  0C07 0004               4244              CMPI.B  #4,D7
000042F6  6700 0566               4245              BEQ     OPERROR
000042FA  4E75                    4246              RTS                 * return
000042FC                          4247              
000042FC                          4248  _ShiftReg   
000042FC                          4249              * determine size of shift
000042FC  0C06 0000               4250              CMPI.B  #%00,D6
00004300  6700 0012               4251              BEQ     _byteShift
00004304  0C06 0001               4252              CMPI.B  #%01,D6
00004308  6700 01AC               4253              BEQ     _wordShift
0000430C  0C06 0002               4254              CMPI.B  #%10,D6
00004310  6700 0346               4255              BEQ     _longShift
00004314                          4256              
00004314                          4257  _byteShift  
00004314                          4258              * determine type of shift
00004314  E18B                    4259              LSL.L   #8,D3       * shift out 
00004316  E78B                    4260              LSL.L   #3,D3
00004318  4EB8 1582               4261              JSR     BitTst2
0000431C  2604                    4262              MOVE.L  D4,D3       * reset D3
0000431E  0C06 0000               4263              CMPI.B  #%00,D6
00004322  6700 0072               4264              BEQ     _AsB        * arithmetic shift
00004326  0C06 0001               4265              CMPI.B  #%01,D6
0000432A  6700 00CA               4266              BEQ     _LsB        * logical shift
0000432E  0C06 0002               4267              CMPI.B  #%10,D6
00004332  6700 0122               4268              BEQ     _RoxB       * roll extend
00004336                          4269              * roll 
00004336                          4270              
00004336  0803 0008               4271              BTST.L  #$08,D3 * test 8th bit for direction
0000433A  6700 002E               4272              BEQ     _RorB   * if bit is 0, it is right
0000433E                          4273              * it is left
0000433E                          4274  * ROL.B ----------------------
0000433E  14FC 0052               4275              MOVE.B  #'R',(A2)+ * add "ROL.B" to A2 string
00004342  14FC 004F               4276              MOVE.B  #'O',(A2)+
00004346  14FC 004C               4277              MOVE.B  #'L',(A2)+
0000434A  14FC 002E               4278              MOVE.B  #'.',(A2)+
0000434E  14FC 0042               4279              MOVE.B  #'B',(A2)+
00004352  14FC 0020               4280              MOVE.B  #' ',(A2)+
00004356  14FC 0020               4281              MOVE.B  #' ',(A2)+
0000435A  14FC 0020               4282              MOVE.B  #' ',(A2)+
0000435E  14FC 0020               4283              MOVE.B  #' ',(A2)+
00004362  14FC 0020               4284              MOVE.B  #' ',(A2)+
00004366  6000 0492               4285              BRA     _ShiftEA    * branch to shift EA to finish
0000436A                          4286              
0000436A                          4287  * ROR.B ----------------------            
0000436A  14FC 0052               4288  _RorB       MOVE.B  #'R',(A2)+ * add "ROR.B" to A2 string
0000436E  14FC 004F               4289              MOVE.B  #'O',(A2)+
00004372  14FC 0052               4290              MOVE.B  #'R',(A2)+
00004376  14FC 002E               4291              MOVE.B  #'.',(A2)+
0000437A  14FC 0042               4292              MOVE.B  #'B',(A2)+
0000437E  14FC 0020               4293              MOVE.B  #' ',(A2)+
00004382  14FC 0020               4294              MOVE.B  #' ',(A2)+
00004386  14FC 0020               4295              MOVE.B  #' ',(A2)+
0000438A  14FC 0020               4296              MOVE.B  #' ',(A2)+
0000438E  14FC 0020               4297              MOVE.B  #' ',(A2)+
00004392  6000 0466               4298              BRA     _ShiftEA    * branch to shift EA to finish
00004396                          4299  
00004396  0803 0008               4300  _AsB        BTST.L  #$08,D3 * test 8th bit for direction
0000439A  6700 002E               4301              BEQ     _AsrB   * if bit is 0, it is right
0000439E                          4302              * it is left
0000439E                          4303  * ASL.B ----------------------
0000439E  14FC 0041               4304              MOVE.B  #'A',(A2)+ * add "ASL.B" to A2 string
000043A2  14FC 0053               4305              MOVE.B  #'S',(A2)+
000043A6  14FC 004C               4306              MOVE.B  #'L',(A2)+
000043AA  14FC 002E               4307              MOVE.B  #'.',(A2)+
000043AE  14FC 0042               4308              MOVE.B  #'B',(A2)+
000043B2  14FC 0020               4309              MOVE.B  #' ',(A2)+
000043B6  14FC 0020               4310              MOVE.B  #' ',(A2)+
000043BA  14FC 0020               4311              MOVE.B  #' ',(A2)+
000043BE  14FC 0020               4312              MOVE.B  #' ',(A2)+
000043C2  14FC 0020               4313              MOVE.B  #' ',(A2)+
000043C6  6000 0432               4314              BRA     _ShiftEA    * branch to shift EA to finish
000043CA                          4315  
000043CA                          4316  * ASR.B ----------------------
000043CA  14FC 0041               4317  _AsrB       MOVE.B  #'A',(A2)+ * add "ASR.B" to A2 string
000043CE  14FC 0053               4318              MOVE.B  #'S',(A2)+
000043D2  14FC 0052               4319              MOVE.B  #'R',(A2)+
000043D6  14FC 002E               4320              MOVE.B  #'.',(A2)+
000043DA  14FC 0042               4321              MOVE.B  #'B',(A2)+
000043DE  14FC 0020               4322              MOVE.B  #' ',(A2)+
000043E2  14FC 0020               4323              MOVE.B  #' ',(A2)+
000043E6  14FC 0020               4324              MOVE.B  #' ',(A2)+
000043EA  14FC 0020               4325              MOVE.B  #' ',(A2)+
000043EE  14FC 0020               4326              MOVE.B  #' ',(A2)+
000043F2  6000 0406               4327              BRA     _ShiftEA    * branch to shift EA to finish
000043F6                          4328  
000043F6                          4329              
000043F6  0803 0008               4330  _LsB        BTST.L  #$08,D3 * test 8th bit for direction
000043FA  6700 002E               4331              BEQ     _LsrB   * if bit is 0, it is right
000043FE                          4332              * it is left
000043FE                          4333  * LSL.B ----------------------
000043FE  14FC 004C               4334              MOVE.B  #'L',(A2)+ * add "LSL.B" to A2 string
00004402  14FC 0053               4335              MOVE.B  #'S',(A2)+
00004406  14FC 004C               4336              MOVE.B  #'L',(A2)+
0000440A  14FC 002E               4337              MOVE.B  #'.',(A2)+
0000440E  14FC 0042               4338              MOVE.B  #'B',(A2)+
00004412  14FC 0020               4339              MOVE.B  #' ',(A2)+
00004416  14FC 0020               4340              MOVE.B  #' ',(A2)+
0000441A  14FC 0020               4341              MOVE.B  #' ',(A2)+
0000441E  14FC 0020               4342              MOVE.B  #' ',(A2)+
00004422  14FC 0020               4343              MOVE.B  #' ',(A2)+
00004426  6000 03D2               4344              BRA     _ShiftEA    * branch to shift EA to finish
0000442A                          4345              
0000442A                          4346  * LSR.B ----------------------            
0000442A  14FC 004C               4347  _LsrB       MOVE.B  #'L',(A2)+ * add "LSR.B" to A2 string
0000442E  14FC 0053               4348              MOVE.B  #'S',(A2)+
00004432  14FC 0052               4349              MOVE.B  #'R',(A2)+
00004436  14FC 002E               4350              MOVE.B  #'.',(A2)+
0000443A  14FC 0042               4351              MOVE.B  #'B',(A2)+
0000443E  14FC 0020               4352              MOVE.B  #' ',(A2)+
00004442  14FC 0020               4353              MOVE.B  #' ',(A2)+
00004446  14FC 0020               4354              MOVE.B  #' ',(A2)+
0000444A  14FC 0020               4355              MOVE.B  #' ',(A2)+
0000444E  14FC 0020               4356              MOVE.B  #' ',(A2)+
00004452  6000 03A6               4357              BRA     _ShiftEA    * branch to shift EA to finish
00004456                          4358  
00004456  0803 0008               4359  _RoxB       BTST.L  #$08,D3 * test 8th bit for direction
0000445A  6700 002E               4360              BEQ     _RoxrB  * if bit is 0, it is right
0000445E                          4361              * it is left
0000445E                          4362  * ROXL.B ----------------------
0000445E  14FC 0052               4363              MOVE.B  #'R',(A2)+ * add "ROXL.B" to A2 string
00004462  14FC 004F               4364              MOVE.B  #'O',(A2)+
00004466  14FC 0058               4365              MOVE.B  #'X',(A2)+
0000446A  14FC 004C               4366              MOVE.B  #'L',(A2)+
0000446E  14FC 002E               4367              MOVE.B  #'.',(A2)+
00004472  14FC 0042               4368              MOVE.B  #'B',(A2)+
00004476  14FC 0020               4369              MOVE.B  #' ',(A2)+
0000447A  14FC 0020               4370              MOVE.B  #' ',(A2)+
0000447E  14FC 0020               4371              MOVE.B  #' ',(A2)+
00004482  14FC 0020               4372              MOVE.B  #' ',(A2)+
00004486  6000 0372               4373              BRA     _ShiftEA    * branch to shift EA to finish
0000448A                          4374              
0000448A                          4375  * ROXR.B ---------------------            
0000448A  14FC 0052               4376  _RoxrB      MOVE.B  #'R',(A2)+ * add "ROXR.B" to A2 string
0000448E  14FC 004F               4377              MOVE.B  #'O',(A2)+
00004492  14FC 0058               4378              MOVE.B  #'X',(A2)+
00004496  14FC 0052               4379              MOVE.B  #'R',(A2)+
0000449A  14FC 002E               4380              MOVE.B  #'.',(A2)+
0000449E  14FC 0042               4381              MOVE.B  #'B',(A2)+
000044A2  14FC 0020               4382              MOVE.B  #' ',(A2)+
000044A6  14FC 0020               4383              MOVE.B  #' ',(A2)+
000044AA  14FC 0020               4384              MOVE.B  #' ',(A2)+
000044AE  14FC 0020               4385              MOVE.B  #' ',(A2)+
000044B2  6000 0346               4386              BRA     _ShiftEA    * branch to shift EA to finish
000044B6                          4387              
000044B6                          4388  
000044B6                          4389  _wordShift
000044B6                          4390              * determine type of shift
000044B6  E18B                    4391              LSL.L   #8,D3
000044B8  E78B                    4392              LSL.L   #3,D3
000044BA  4EB8 1582               4393              JSR     BitTst2
000044BE  2604                    4394              MOVE.L  D4,D3   * reset D3
000044C0  0C06 0000               4395              CMPI.B  #%00,D6
000044C4  6700 0072               4396              BEQ     _AsW    * arithmetic shift
000044C8  0C06 0001               4397              CMPI.B  #%01,D6
000044CC  6700 00CA               4398              BEQ     _LsW    * logical shift
000044D0  0C06 0002               4399              CMPI.B  #%10,D6
000044D4  6700 0122               4400              BEQ     _RoxW   * roll extend
000044D8                          4401              * roll
000044D8  0803 0008               4402              BTST.L  #$08,D3 * test 8th bit for direction
000044DC  6700 002E               4403              BEQ     _RorW   * if bit is 0, it is right
000044E0                          4404              * it is left
000044E0                          4405  * ROL.W ----------------------
000044E0  14FC 0052               4406              MOVE.B  #'R',(A2)+ * add "ROL.W" to A2 string
000044E4  14FC 004F               4407              MOVE.B  #'O',(A2)+
000044E8  14FC 004C               4408              MOVE.B  #'L',(A2)+
000044EC  14FC 002E               4409              MOVE.B  #'.',(A2)+
000044F0  14FC 0057               4410              MOVE.B  #'W',(A2)+
000044F4  14FC 0020               4411              MOVE.B  #' ',(A2)+
000044F8  14FC 0020               4412              MOVE.B  #' ',(A2)+
000044FC  14FC 0020               4413              MOVE.B  #' ',(A2)+
00004500  14FC 0020               4414              MOVE.B  #' ',(A2)+
00004504  14FC 0020               4415              MOVE.B  #' ',(A2)+
00004508  6000 02F0               4416              BRA     _ShiftEA    * branch to shift EA to finish
0000450C                          4417              
0000450C                          4418  * ROR.W ----------------------            
0000450C  14FC 0052               4419  _RorW       MOVE.B  #'R',(A2)+ * add "ROR.W" to A2 string
00004510  14FC 004F               4420              MOVE.B  #'O',(A2)+
00004514  14FC 0052               4421              MOVE.B  #'R',(A2)+
00004518  14FC 002E               4422              MOVE.B  #'.',(A2)+
0000451C  14FC 0057               4423              MOVE.B  #'W',(A2)+
00004520  14FC 0020               4424              MOVE.B  #' ',(A2)+
00004524  14FC 0020               4425              MOVE.B  #' ',(A2)+
00004528  14FC 0020               4426              MOVE.B  #' ',(A2)+
0000452C  14FC 0020               4427              MOVE.B  #' ',(A2)+
00004530  14FC 0020               4428              MOVE.B  #' ',(A2)+
00004534  6000 02C4               4429              BRA     _ShiftEA    * branch to shift EA to finish
00004538                          4430              
00004538  0803 0008               4431  _AsW        BTST.L  #$08,D3 * test 8th bit for direction
0000453C  6700 002E               4432              BEQ     _AsrW   * if bit is 0, it is right
00004540                          4433              * it is left
00004540                          4434  * ASL.W ----------------------
00004540  14FC 0041               4435              MOVE.B  #'A',(A2)+ * add "ASL.W" to A2 string
00004544  14FC 0053               4436              MOVE.B  #'S',(A2)+
00004548  14FC 004C               4437              MOVE.B  #'L',(A2)+
0000454C  14FC 002E               4438              MOVE.B  #'.',(A2)+
00004550  14FC 0057               4439              MOVE.B  #'W',(A2)+
00004554  14FC 0020               4440              MOVE.B  #' ',(A2)+
00004558  14FC 0020               4441              MOVE.B  #' ',(A2)+
0000455C  14FC 0020               4442              MOVE.B  #' ',(A2)+
00004560  14FC 0020               4443              MOVE.B  #' ',(A2)+
00004564  14FC 0020               4444              MOVE.B  #' ',(A2)+
00004568  6000 0290               4445              BRA     _ShiftEA    * branch to shift EA to finish
0000456C                          4446              
0000456C                          4447  * ASR.W ----------------------            
0000456C  14FC 0041               4448  _AsrW       MOVE.B  #'A',(A2)+ * add "ASR.W" to A2 string
00004570  14FC 0053               4449              MOVE.B  #'S',(A2)+
00004574  14FC 0052               4450              MOVE.B  #'R',(A2)+
00004578  14FC 002E               4451              MOVE.B  #'.',(A2)+
0000457C  14FC 0057               4452              MOVE.B  #'W',(A2)+
00004580  14FC 0020               4453              MOVE.B  #' ',(A2)+
00004584  14FC 0020               4454              MOVE.B  #' ',(A2)+
00004588  14FC 0020               4455              MOVE.B  #' ',(A2)+
0000458C  14FC 0020               4456              MOVE.B  #' ',(A2)+
00004590  14FC 0020               4457              MOVE.B  #' ',(A2)+
00004594  6000 0264               4458              BRA     _ShiftEA    * branch to shift EA to finish
00004598                          4459  
00004598  0803 0008               4460  _LsW        BTST.L  #$08,D3 * test 8th bit for direction
0000459C  6700 002E               4461              BEQ     _LsrW   * if bit is 0, it is right
000045A0                          4462              * it is left
000045A0                          4463  * LSL.W ----------------------
000045A0  14FC 004C               4464              MOVE.B  #'L',(A2)+ * add "LSL.W" to A2 string
000045A4  14FC 0053               4465              MOVE.B  #'S',(A2)+
000045A8  14FC 004C               4466              MOVE.B  #'L',(A2)+
000045AC  14FC 002E               4467              MOVE.B  #'.',(A2)+
000045B0  14FC 0057               4468              MOVE.B  #'W',(A2)+
000045B4  14FC 0020               4469              MOVE.B  #' ',(A2)+
000045B8  14FC 0020               4470              MOVE.B  #' ',(A2)+
000045BC  14FC 0020               4471              MOVE.B  #' ',(A2)+
000045C0  14FC 0020               4472              MOVE.B  #' ',(A2)+
000045C4  14FC 0020               4473              MOVE.B  #' ',(A2)+
000045C8  6000 0230               4474              BRA     _ShiftEA    * branch to shift EA to finish
000045CC                          4475              
000045CC                          4476  * LSR.W ----------------------            
000045CC  14FC 004C               4477  _LsrW       MOVE.B  #'L',(A2)+ * add "LSR.W" to A2 string
000045D0  14FC 0053               4478              MOVE.B  #'S',(A2)+
000045D4  14FC 0052               4479              MOVE.B  #'R',(A2)+
000045D8  14FC 002E               4480              MOVE.B  #'.',(A2)+
000045DC  14FC 0057               4481              MOVE.B  #'W',(A2)+
000045E0  14FC 0020               4482              MOVE.B  #' ',(A2)+
000045E4  14FC 0020               4483              MOVE.B  #' ',(A2)+
000045E8  14FC 0020               4484              MOVE.B  #' ',(A2)+
000045EC  14FC 0020               4485              MOVE.B  #' ',(A2)+
000045F0  14FC 0020               4486              MOVE.B  #' ',(A2)+
000045F4  6000 0204               4487              BRA     _ShiftEA    * branch to shift EA to finish
000045F8                          4488  
000045F8  0803 0008               4489  _RoxW       BTST.L  #$08,D3 * test 8th bit for direction
000045FC  6700 002E               4490              BEQ     _RoxrW  * if bit is 0, it is right
00004600                          4491              * it is left
00004600                          4492  * ROXL.W ---------------------
00004600  14FC 0052               4493              MOVE.B  #'R',(A2)+ * add "ROXL.W" to A2 string
00004604  14FC 004F               4494              MOVE.B  #'O',(A2)+
00004608  14FC 0058               4495              MOVE.B  #'X',(A2)+
0000460C  14FC 004C               4496              MOVE.B  #'L',(A2)+
00004610  14FC 002E               4497              MOVE.B  #'.',(A2)+
00004614  14FC 0057               4498              MOVE.B  #'W',(A2)+
00004618  14FC 0020               4499              MOVE.B  #' ',(A2)+
0000461C  14FC 0020               4500              MOVE.B  #' ',(A2)+
00004620  14FC 0020               4501              MOVE.B  #' ',(A2)+
00004624  14FC 0020               4502              MOVE.B  #' ',(A2)+
00004628  6000 01D0               4503              BRA     _ShiftEA    * branch to shift EA to finish
0000462C                          4504              
0000462C                          4505  * ROXR.W ---------------------            
0000462C  14FC 0052               4506  _RoxrW      MOVE.B  #'R',(A2)+ * add "ROXR.W" to A2 string
00004630  14FC 004F               4507              MOVE.B  #'O',(A2)+
00004634  14FC 0058               4508              MOVE.B  #'X',(A2)+
00004638  14FC 0052               4509              MOVE.B  #'R',(A2)+
0000463C  14FC 002E               4510              MOVE.B  #'.',(A2)+
00004640  14FC 0057               4511              MOVE.B  #'W',(A2)+
00004644  14FC 0020               4512              MOVE.B  #' ',(A2)+
00004648  14FC 0020               4513              MOVE.B  #' ',(A2)+
0000464C  14FC 0020               4514              MOVE.B  #' ',(A2)+
00004650  14FC 0020               4515              MOVE.B  #' ',(A2)+
00004654  6000 01A4               4516              BRA     _ShiftEA    * branch to shift EA to finish
00004658                          4517  
00004658                          4518  _longShift
00004658                          4519              * determine type of shift
00004658  E18B                    4520              LSL.L   #8,D3
0000465A  E78B                    4521              LSL.L   #3,D3
0000465C  4EB8 1582               4522              JSR     BitTst2
00004660  2604                    4523              MOVE.L  D4,D3       * reset D3
00004662  0C06 0000               4524              CMPI.B  #%00,D6
00004666  6700 0072               4525              BEQ     _AsLong
0000466A  0C06 0001               4526              CMPI.B  #%01,D6
0000466E  6700 00CA               4527              BEQ     _LsLong
00004672  0C06 0002               4528              CMPI.B  #%10,D6
00004676  6700 0122               4529              BEQ     _RoxLong
0000467A                          4530              * roll
0000467A  0803 0008               4531              BTST.L  #$08,D3 * test 8th bit for direction
0000467E  6700 002E               4532              BEQ     _RorLong   * if bit is 0, it is right
00004682                          4533              * it is left
00004682                          4534  * ROL.L ----------------------
00004682  14FC 0052               4535              MOVE.B  #'R',(A2)+ * add "ROL.L" to A2 string
00004686  14FC 004F               4536              MOVE.B  #'O',(A2)+
0000468A  14FC 004C               4537              MOVE.B  #'L',(A2)+
0000468E  14FC 002E               4538              MOVE.B  #'.',(A2)+
00004692  14FC 004C               4539              MOVE.B  #'L',(A2)+
00004696  14FC 0020               4540              MOVE.B  #' ',(A2)+
0000469A  14FC 0020               4541              MOVE.B  #' ',(A2)+
0000469E  14FC 0020               4542              MOVE.B  #' ',(A2)+
000046A2  14FC 0020               4543              MOVE.B  #' ',(A2)+
000046A6  14FC 0020               4544              MOVE.B  #' ',(A2)+
000046AA  6000 014E               4545              BRA     _ShiftEA    * branch to shift EA to finish
000046AE                          4546              
000046AE                          4547  * ROR.L ----------------------            
000046AE  14FC 0052               4548  _RorLong    MOVE.B  #'R',(A2)+ * add "ROR.L" to A2 string
000046B2  14FC 004F               4549              MOVE.B  #'O',(A2)+
000046B6  14FC 0052               4550              MOVE.B  #'R',(A2)+
000046BA  14FC 002E               4551              MOVE.B  #'.',(A2)+
000046BE  14FC 004C               4552              MOVE.B  #'L',(A2)+
000046C2  14FC 0020               4553              MOVE.B  #' ',(A2)+
000046C6  14FC 0020               4554              MOVE.B  #' ',(A2)+
000046CA  14FC 0020               4555              MOVE.B  #' ',(A2)+
000046CE  14FC 0020               4556              MOVE.B  #' ',(A2)+
000046D2  14FC 0020               4557              MOVE.B  #' ',(A2)+
000046D6  6000 0122               4558              BRA     _ShiftEA    * branch to shift EA to finis
000046DA                          4559              
000046DA  0803 0008               4560  _AsLong     BTST.L  #$08,D3 * test 8th bit for direction
000046DE  6700 002E               4561              BEQ     _AsrLong   * if bit is 0, it is right
000046E2                          4562              * it is left
000046E2                          4563  * ASL.L ----------------------
000046E2  14FC 0041               4564              MOVE.B  #'A',(A2)+ * add "ASL.L" to A2 string
000046E6  14FC 0053               4565              MOVE.B  #'S',(A2)+
000046EA  14FC 004C               4566              MOVE.B  #'L',(A2)+
000046EE  14FC 002E               4567              MOVE.B  #'.',(A2)+
000046F2  14FC 004C               4568              MOVE.B  #'L',(A2)+
000046F6  14FC 0020               4569              MOVE.B  #' ',(A2)+
000046FA  14FC 0020               4570              MOVE.B  #' ',(A2)+
000046FE  14FC 0020               4571              MOVE.B  #' ',(A2)+
00004702  14FC 0020               4572              MOVE.B  #' ',(A2)+
00004706  14FC 0020               4573              MOVE.B  #' ',(A2)+
0000470A  6000 00EE               4574              BRA     _ShiftEA    * branch to shift EA to finish
0000470E                          4575              
0000470E                          4576  * ASR.L ----------------------           
0000470E  14FC 0041               4577  _AsrLong    MOVE.B  #'A',(A2)+ * add "ASR.L" to A2 string
00004712  14FC 0053               4578              MOVE.B  #'S',(A2)+
00004716  14FC 0052               4579              MOVE.B  #'R',(A2)+
0000471A  14FC 002E               4580              MOVE.B  #'.',(A2)+
0000471E  14FC 004C               4581              MOVE.B  #'L',(A2)+
00004722  14FC 0020               4582              MOVE.B  #' ',(A2)+
00004726  14FC 0020               4583              MOVE.B  #' ',(A2)+
0000472A  14FC 0020               4584              MOVE.B  #' ',(A2)+
0000472E  14FC 0020               4585              MOVE.B  #' ',(A2)+
00004732  14FC 0020               4586              MOVE.B  #' ',(A2)+
00004736  6000 00C2               4587              BRA     _ShiftEA    * branch to shift EA to finish
0000473A                          4588  
0000473A  0803 0008               4589  _LsLong     BTST.L  #$08,D3 * test 8th bit for direction
0000473E  6700 002E               4590              BEQ     _LsrLong   * if bit is 0, it is right
00004742                          4591              * it is left
00004742                          4592  * LSL.L ----------------------
00004742  14FC 004C               4593              MOVE.B  #'L',(A2)+ * add "LSL.L" to A2 string
00004746  14FC 0053               4594              MOVE.B  #'S',(A2)+
0000474A  14FC 004C               4595              MOVE.B  #'L',(A2)+
0000474E  14FC 002E               4596              MOVE.B  #'.',(A2)+
00004752  14FC 004C               4597              MOVE.B  #'L',(A2)+
00004756  14FC 0020               4598              MOVE.B  #' ',(A2)+
0000475A  14FC 0020               4599              MOVE.B  #' ',(A2)+
0000475E  14FC 0020               4600              MOVE.B  #' ',(A2)+
00004762  14FC 0020               4601              MOVE.B  #' ',(A2)+
00004766  14FC 0020               4602              MOVE.B  #' ',(A2)+
0000476A  6000 008E               4603              BRA     _ShiftEA    * branch to shift EA to finish
0000476E                          4604              
0000476E                          4605  * LSR.L ----------------------            
0000476E  14FC 004C               4606  _LsrLong    MOVE.B  #'L',(A2)+ * add "LSR.L" to A2 string
00004772  14FC 0053               4607              MOVE.B  #'S',(A2)+
00004776  14FC 0052               4608              MOVE.B  #'R',(A2)+
0000477A  14FC 002E               4609              MOVE.B  #'.',(A2)+
0000477E  14FC 004C               4610              MOVE.B  #'L',(A2)+
00004782  14FC 0020               4611              MOVE.B  #' ',(A2)+
00004786  14FC 0020               4612              MOVE.B  #' ',(A2)+
0000478A  14FC 0020               4613              MOVE.B  #' ',(A2)+
0000478E  14FC 0020               4614              MOVE.B  #' ',(A2)+
00004792  14FC 0020               4615              MOVE.B  #' ',(A2)+
00004796  6000 0062               4616              BRA     _ShiftEA    * branch to shift EA to finish
0000479A                          4617              
0000479A                          4618  
0000479A  0803 0008               4619  _RoxLong    BTST.L  #$08,D3 * test 8th bit for direction
0000479E  6700 002E               4620              BEQ     _RoxrLong  * if bit is 0, it is right
000047A2                          4621              * it is left
000047A2                          4622  * ROXL.L ---------------------
000047A2  14FC 0052               4623              MOVE.B  #'R',(A2)+ * add "ROXL.L" to A2 string
000047A6  14FC 004F               4624              MOVE.B  #'O',(A2)+
000047AA  14FC 0058               4625              MOVE.B  #'X',(A2)+
000047AE  14FC 004C               4626              MOVE.B  #'L',(A2)+
000047B2  14FC 002E               4627              MOVE.B  #'.',(A2)+
000047B6  14FC 004C               4628              MOVE.B  #'L',(A2)+
000047BA  14FC 0020               4629              MOVE.B  #' ',(A2)+
000047BE  14FC 0020               4630              MOVE.B  #' ',(A2)+
000047C2  14FC 0020               4631              MOVE.B  #' ',(A2)+
000047C6  14FC 0020               4632              MOVE.B  #' ',(A2)+
000047CA  6000 002E               4633              BRA     _ShiftEA    * branch to shift EA to finish
000047CE                          4634              
000047CE                          4635  * ROXR.L ---------------------            
000047CE  14FC 0052               4636  _RoxrLong   MOVE.B  #'R',(A2)+ * add "ROXR.L" to A2 string
000047D2  14FC 004F               4637              MOVE.B  #'O',(A2)+
000047D6  14FC 0058               4638              MOVE.B  #'X',(A2)+
000047DA  14FC 0052               4639              MOVE.B  #'R',(A2)+
000047DE  14FC 002E               4640              MOVE.B  #'.',(A2)+
000047E2  14FC 004C               4641              MOVE.B  #'L',(A2)+
000047E6  14FC 0020               4642              MOVE.B  #' ',(A2)+
000047EA  14FC 0020               4643              MOVE.B  #' ',(A2)+
000047EE  14FC 0020               4644              MOVE.B  #' ',(A2)+
000047F2  14FC 0020               4645              MOVE.B  #' ',(A2)+
000047F6  6000 0002               4646              BRA     _ShiftEA    * branch to shift EA to finish
000047FA                          4647              
000047FA                          4648  _ShiftEA    
000047FA  0803 0005               4649              BTST.L  #$05,D3     * determine if it is a shift using a register
000047FE  6700 0036               4650              BEQ     _shiftImm
00004802  14FC 0044               4651              MOVE.B  #'D',(A2)+
00004806  4843                    4652              SWAP    D3
00004808  E98B                    4653              LSL.L   #4,D3       * shift out opcode
0000480A  4EB8 1560               4654              JSR     BitTst3     * get next three bits for source reg number
0000480E  4DF9 00004A6E           4655              LEA     numTable,A6 * load num table
00004814  CCFC 0008               4656              MULU    #8,D6       * multiply for offset
00004818  4EB6 6000               4657              JSR     (A6,D6)     * jump to get number
0000481C                          4658              
0000481C  14FC 002C               4659  _shiftDest  MOVE.B  #',',(A2)+
00004820  14FC 0044               4660              MOVE.B  #'D',(A2)+
00004824  E18B                    4661              LSL.L   #8,D3       * shift out all bits but 0->2
00004826  E38B                    4662              LSL.L   #1,D3
00004828  4EB8 1560               4663              JSR     BitTst3     * test for data register
0000482C  CCFC 0008               4664              MULU    #8,D6       * multiply for offset
00004830  4EB6 6000               4665              JSR     (A6,D6)     * jump to get number
00004834  4E75                    4666              RTS
00004836                          4667  _shiftImm
00004836  14FC 0023               4668              MOVE.B  #'#',(A2)+
0000483A  4843                    4669              SWAP    D3
0000483C  E98B                    4670              LSL.L   #4,D3       * shift out opcode
0000483E  4EB8 1560               4671              JSR     BitTst3     * get next three bits for data value being shifted
00004842  0C06 0000               4672              CMPI.B  #%000,D6    * if it is 000, add 8 to D6
00004846  6600 0006               4673              BNE     _shftIM     * if not, continue to next part
0000484A  4EB8 2C0C               4674              JSR     Add8        * jump to subroutine to add 8 to D6
0000484E  4DF9 00004A6E           4675  _shftIM     LEA     numTable,A6 * load num table
00004854  CCFC 0008               4676              MULU    #8,D6       * multiply for offset
00004858  4EB6 6000               4677              JSR     (A6,D6)     * jump to get number
0000485C  60BE                    4678              BRA     _shiftDest  * get destination register
0000485E                          4679                             
0000485E                          4680  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
0000485E                          4681  *                          END OF OP CODES                                    *
0000485E                          4682  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
0000485E                          4683              
0000485E                          4684  *******************************************************************************
0000485E                          4685  * OPERROR - Used when data or an illegal instruction is encountered.
0000485E                          4686  * Resets A2 to the end of the PC to overwrite the new string.
0000485E                          4687  * Also could reset the current address, A4, if an EA has been read incorrectly.
0000485E                          4688  *******************************************************************************
0000485E                          4689  OPERROR     
0000485E  0C38 0001 0015          4690              CMPI.B  #1,EA_FLAG  * see if the ea flag has been set
00004864  6600 0004               4691              BNE     Next
00004868  2845                    4692              MOVEA.L D5,A4       * reset A4
0000486A  244B                    4693  Next        MOVEA.L A3,A2       * reset A2 to overwrite current string
0000486C  14FC 0044               4694              MOVE.B  #'D',(A2)+  * add DATA to A2 String
00004870  14FC 0041               4695              MOVE.B  #'A',(A2)+
00004874  14FC 0054               4696              MOVE.B  #'T',(A2)+
00004878  14FC 0041               4697              MOVE.B  #'A',(A2)+
0000487C  14FC 0020               4698              MOVE.B  #' ',(A2)+
00004880  14FC 0020               4699              MOVE.B  #' ',(A2)+
00004884  14FC 0020               4700              MOVE.B  #' ',(A2)+
00004888  14FC 0020               4701              MOVE.B  #' ',(A2)+
0000488C  14FC 0020               4702              MOVE.B  #' ',(A2)+
00004890  14FC 0020               4703              MOVE.B  #' ',(A2)+
00004894  14FC 0024               4704              MOVE.B  #'$',(A2)+
00004898  4EB9 000048A6           4705              JSR     printErrorData
0000489E  11FC 0000 0015          4706              MOVE.B  #0,EA_FLAG  * reset ea flag for next instruction
000048A4  4E75                    4707              RTS
000048A6                          4708  
000048A6                          4709  printErrorData
000048A6                          4710              
000048A6  4242                    4711              CLR     D2      * clear d2 for counter
000048A8  4DF9 00004A6E           4712              LEA     numTable,A6
000048AE  2604                    4713              MOVE.L  D4,D3
000048B0  4843                    4714              SWAP    D3
000048B2                          4715              
000048B2                          4716  printELoop  
000048B2  0C02 0004               4717              CMPI.B  #4,D2       * loop through 4 times,
000048B6  6700 0014               4718              BEQ     loopDone    * print done
000048BA  4EB8 1534               4719              JSR     BITTEST     * get leading 4 bits
000048BE  CCFC 0008               4720              MULU    #8,D6       * multiply by 8 for jump offset
000048C2  4EB6 6000               4721              JSR     (A6,D6)     * get number from table and add to A2 string
000048C6  E98B                    4722              LSL.L   #4,D3       * shift out 4 biths were done with
000048C8  5242                    4723              ADDQ    #1,D2       * increment loop counter
000048CA  60E6                    4724              BRA     printELoop  * branch back to loop
000048CC                          4725  
000048CC                          4726  loopDone    
000048CC  4E75                    4727              RTS
000048CE                          4728     
000048CE                          4729  
000048CE                          4730  * EA Jump Table ------------------------------------------------------
000048CE  4EB9 0000490E           4731  eaTable     JSR     ea000    * data register
000048D4  4E75                    4732              RTS             
000048D6  4EB9 0000492E           4733              JSR     ea001    * address register
000048DC  4E75                    4734              RTS             
000048DE  4EB9 0000495C           4735              JSR     ea010    * indirect address register
000048E4  4E75                    4736              RTS             
000048E6  4EB9 00004984           4737              JSR     ea011    * post increment address
000048EC  4E75                    4738              RTS             
000048EE  4EB9 000049B0           4739              JSR     ea100    * address pre decrement
000048F4  4E75                    4740              RTS             
000048F6  4EB9 000049DC           4741              JSR     ea101    * unsupported
000048FC  4E75                    4742              RTS             
000048FE  4EB9 000049E2           4743              JSR     ea110    * unsupported
00004904  4E75                    4744              RTS             
00004906  4EB9 000049E8           4745              JSR     ea111     * immediate/absolute address
0000490C  4E75                    4746              RTS             
0000490E                          4747              
0000490E                          4748              
0000490E                          4749  * Dn -----------------------------------------------------------------
0000490E                          4750  ea000
0000490E  14FC 0044               4751              MOVE.B  #'D',(A2)+  * add D to A2 string
00004912                          4752                  
00004912  2604                    4753              MOVE.L  D4,D3       * copy data to D3
00004914  4843                    4754              SWAP    D3
00004916  EB8B                    4755              LSL.L   #5,D3       * clear bits until register number
00004918  E18B                    4756              LSL.L   #8,D3       
0000491A                          4757              
0000491A  4EB8 1560               4758              JSR     BitTst3
0000491E                          4759              
0000491E  4DF9 00004A6E           4760              LEA     numTable,A6 ;load table
00004924  CCFC 0008               4761              MULU    #8,D6       ;get jump table to work
00004928  4EB6 6000               4762              JSR     (A6,D6)    ;print number
0000492C                          4763              
0000492C                          4764              
0000492C  4E75                    4765              RTS
0000492E                          4766  
0000492E                          4767              
0000492E                          4768  * An -----------------------------------------------------------------
0000492E                          4769  ea001
0000492E  BE3C 0001               4770              CMP.B   #1,D7       * cannot move Address with byte data
00004932  6700 0022               4771              BEQ     isByte     * error
00004936                          4772               
00004936                          4773              
00004936  14FC 0041               4774              MOVE.B  #'A',(A2)+  * print A
0000493A  2604                    4775              MOVE.L  D4,D3       * reset D3
0000493C  4843                    4776              SWAP    D3          * move bits to front
0000493E  E18B                    4777              LSL.L   #8,D3       * shift all bits out but 0-2
00004940  EB8B                    4778              LSL.L   #5,D3
00004942  4EB8 1560               4779              JSR     BitTst3     * test these three bits
00004946                          4780              
00004946  4DF9 00004A6E           4781              LEA     numTable,A6 * load table
0000494C  CCFC 0008               4782              MULU    #8,D6       * offset
00004950  4EB6 6000               4783              JSR     (A6,D6)     * print
00004954                          4784              
00004954  4E75                    4785              RTS
00004956                          4786              
00004956  1E3C 0004               4787  isByte      MOVE.B  #4,D7   * set error
0000495A  4E75                    4788              RTS
0000495C                          4789  
0000495C                          4790             
0000495C                          4791  * (An) ---------------------------------------------------------------
0000495C                          4792  ea010
0000495C                          4793  
0000495C  14FC 0028               4794              MOVE.B  #'(',(A2)+  * print (
00004960  14FC 0041               4795              MOVE.B  #'A',(A2)+  * print A
00004964                          4796              
00004964  2604                    4797              MOVE.L  D4,D3       * reset D3
00004966  4843                    4798              SWAP    D3          * move bits to front
00004968  E18B                    4799              LSL.L   #8,D3       * shift all bits out but 0-2
0000496A  EB8B                    4800              LSL.L   #5,D3
0000496C  4EB8 1560               4801              JSR     BitTst3     * test these three bits
00004970  4DF9 00004A6E           4802              LEA     numTable,A6 * load table
00004976  CCFC 0008               4803              MULU    #8,D6       * offset
0000497A  4EB6 6000               4804              JSR     (A6,D6)     * print number
0000497E                          4805              
0000497E  14FC 0029               4806              MOVE.B  #')',(A2)+  * print )
00004982                          4807              
00004982                          4808  
00004982  4E75                    4809              RTS
00004984                          4810  
00004984                          4811              
00004984                          4812  * (An)+ --------------------------------------------------------------
00004984                          4813  ea011
00004984                          4814  
00004984  14FC 0028               4815              MOVE.B  #'(',(A2)+  * print (
00004988  14FC 0041               4816              MOVE.B  #'A',(A2)+  * print A
0000498C                          4817              
0000498C  2604                    4818              MOVE.L  D4,D3       * reset D3
0000498E  4843                    4819              SWAP    D3          * move bits to front
00004990  E18B                    4820              LSL.L   #8,D3       * shift all bits out but 0-2
00004992  EB8B                    4821              LSL.L   #5,D3
00004994  4EB8 1560               4822              JSR     BitTst3     * test these three bits
00004998                          4823              
00004998  4DF9 00004A6E           4824              LEA     numTable,A6 * load table
0000499E  CCFC 0008               4825              MULU    #8,D6       * offset
000049A2  4EB6 6000               4826              JSR     (A6,D6)    * print number
000049A6                          4827              
000049A6  14FC 0029               4828              MOVE.B  #')',(A2)+  * print )
000049AA  14FC 002B               4829              MOVE.B  #'+',(A2)+  * print +
000049AE                          4830              
000049AE                          4831  
000049AE  4E75                    4832              RTS
000049B0                          4833  
000049B0                          4834              
000049B0                          4835  * -(An) --------------------------------------------------------------
000049B0                          4836  ea100
000049B0                          4837  
000049B0  14FC 002D               4838              MOVE.B  #'-',(A2)+  * print -
000049B4  14FC 0028               4839              MOVE.B  #'(',(A2)+  * print (
000049B8  14FC 0041               4840              MOVE.B  #'A',(A2)+  * print A
000049BC  2604                    4841              MOVE.L  D4,D3       * reset D3
000049BE  4843                    4842              SWAP    D3          * move bits to front
000049C0  E18B                    4843              LSL.L   #8,D3       * shift all bits out but 0-2
000049C2  EB8B                    4844              LSL.L   #5,D3
000049C4  4EB8 1560               4845              JSR     BitTst3     * test these three bits
000049C8                          4846              
000049C8  4DF9 00004A6E           4847              LEA     numTable,A6 ;load table
000049CE  CCFC 0008               4848              MULU    #8,D6       ;get jump table to work
000049D2  4EB6 6000               4849              JSR     (A6,D6)    ;print number
000049D6                          4850              
000049D6  14FC 0029               4851              MOVE.B  #')',(A2)+  ;print )
000049DA                          4852              
000049DA                          4853  
000049DA  4E75                    4854              RTS
000049DC                          4855  
000049DC                          4856              
000049DC                          4857  * Subroutine not supported ---------------------------------------------
000049DC                          4858  ea101
000049DC                          4859  
000049DC  1E3C 0004               4860              MOVE.B  #4,D7
000049E0  4E75                    4861              RTS
000049E2                          4862              
000049E2                          4863  
000049E2                          4864              
000049E2                          4865  * Subroutine not supported --------------------------------------------
000049E2                          4866  ea110
000049E2                          4867  
000049E2  1E3C 0004               4868              MOVE.B  #4,D7 * set error flag
000049E6  4E75                    4869              RTS      
000049E8                          4870              
000049E8                          4871  
000049E8                          4872             
000049E8                          4873  * Immediate and Absolute -----------------------------------------------
000049E8                          4874  ea111
000049E8  2604                    4875              MOVE.L  D4,D3       * reset D3
000049EA  4843                    4876              SWAP    D3          * move bits to front
000049EC  E18B                    4877              LSL.L   #8,D3       * shift all bits out but 0-2
000049EE  EB8B                    4878              LSL.L   #5,D3
000049F0  4EB8 1560               4879              JSR     BitTst3     * test these three bits
000049F4  0C06 0000               4880              CMPI.B  #%000,D6    * compare to absolute short
000049F8  6700 0060               4881              BEQ     shortAbs
000049FC  0C06 0001               4882              CMPI.B  #%001,D6    * compare to absolute long
00004A00  6700 0062               4883              BEQ     longAbs
00004A04  0C06 0004               4884              CMPI.B  #%100,D6    * compare to immediate
00004A08  6700 0008               4885              BEQ     immediate
00004A0C                          4886  
00004A0C  1E3C 0004               4887              MOVE.B  #4,D7   * set error
00004A10  4E75                    4888              RTS          
00004A12                          4889              
00004A12                          4890  immediate
00004A12  BE3C 0001               4891              CMP.B   #1,D7       * compare to byte
00004A16  6700 0018               4892              BEQ     _ByteData      
00004A1A  BE3C 0002               4893              CMP.B   #2,D7       * compare to word
00004A1E  6700 001E               4894              BEQ     _WordData
00004A22  BE3C 0003               4895              CMP.B   #3,D7       * compare to long
00004A26  6700 0024               4896              BEQ     _LongData
00004A2A                          4897  
00004A2A  1E3C 0004               4898              MOVE.B  #4,D7       * set error flag
00004A2E  4E75                    4899              RTS
00004A30                          4900                               
00004A30                          4901              
00004A30                          4902  _ByteData
00004A30  14FC 0023               4903              MOVE.B  #'#',(A2)+  * print #
00004A34  14FC 0024               4904              MOVE.B  #'$',(A2)+  * print $
00004A38  4EB8 15AA               4905              JSR     printByte
00004A3C  4E75                    4906              RTS                 
00004A3E                          4907              
00004A3E                          4908  _WordData
00004A3E  14FC 0023               4909              MOVE.B  #'#',(A2)+  * print #
00004A42  14FC 0024               4910              MOVE.B  #'$',(A2)+  * print $
00004A46  4EB8 15DA               4911              JSR     printWord
00004A4A  4E75                    4912              RTS                 
00004A4C                          4913              
00004A4C                          4914  _LongData
00004A4C  14FC 0023               4915              MOVE.B  #'#',(A2)+  * print #
00004A50  14FC 0024               4916              MOVE.B  #'$',(A2)+  * print $
00004A54  4EB8 1608               4917              JSR     printLong
00004A58  4E75                    4918              RTS                 
00004A5A                          4919  
00004A5A                          4920  shortAbs
00004A5A  14FC 0024               4921              MOVE.B  #'$',(A2)+  * print $
00004A5E  4EB8 15DA               4922              JSR     printWord   
00004A62  4E75                    4923              RTS                 
00004A64                          4924              
00004A64                          4925  longAbs
00004A64  14FC 0024               4926              MOVE.B  #'$',(A2)+  * print $
00004A68  4EB8 1608               4927              JSR     printLong
00004A6C  4E75                    4928              RTS                 
00004A6E                          4929              
00004A6E                          4930  
00004A6E                          4931  * Number Jump Table ----------------------------------------
00004A6E  4EB9 00004AEE           4932  numTable    JSR     n0   * 0
00004A74  4E75                    4933              RTS             
00004A76  4EB9 00004AF4           4934              JSR     n1   * 1
00004A7C  4E75                    4935              RTS             
00004A7E  4EB9 00004AFA           4936              JSR     n2   * 2
00004A84  4E75                    4937              RTS             
00004A86  4EB9 00004B00           4938              JSR     n3   * 3
00004A8C  4E75                    4939              RTS             
00004A8E  4EB9 00004B06           4940              JSR     n4   * 4
00004A94  4E75                    4941              RTS             
00004A96  4EB9 00004B0C           4942              JSR     n5   * 5
00004A9C  4E75                    4943              RTS             
00004A9E  4EB9 00004B12           4944              JSR     n6   * 6
00004AA4  4E75                    4945              RTS             
00004AA6  4EB9 00004B18           4946              JSR     n7   * 7
00004AAC  4E75                    4947              RTS             
00004AAE  4EB9 00004B1E           4948              JSR     n8   * 8
00004AB4  4E75                    4949              RTS             
00004AB6  4EB9 00004B24           4950              JSR     n9   * 9
00004ABC  4E75                    4951              RTS             
00004ABE  4EB9 00004B2A           4952              JSR     nA   * A
00004AC4  4E75                    4953              RTS             
00004AC6  4EB9 00004B30           4954              JSR     nB   * B
00004ACC  4E75                    4955              RTS             
00004ACE  4EB9 00004B36           4956              JSR     nC   * C
00004AD4  4E75                    4957              RTS             
00004AD6  4EB9 00004B3C           4958              JSR     nD   * D
00004ADC  4E75                    4959              RTS             
00004ADE  4EB9 00004B42           4960              JSR     nE   * E
00004AE4  4E75                    4961              RTS             
00004AE6  4EB9 00004B48           4962              JSR     nF   * F
00004AEC  4E75                    4963              RTS             
00004AEE                          4964  
00004AEE                          4965              
00004AEE                          4966  * Print 0 ------------------------------------------
00004AEE                          4967  n0
00004AEE  14FC 0030               4968              MOVE.B  #'0',(A2)+      * add 0 to string
00004AF2  4E75                    4969              RTS
00004AF4                          4970  
00004AF4                          4971            
00004AF4                          4972  * Print 1 ------------------------------------------
00004AF4                          4973  n1
00004AF4  14FC 0031               4974              MOVE.B  #'1',(A2)+      * add 1 to string
00004AF8  4E75                    4975              RTS
00004AFA                          4976  
00004AFA                          4977             
00004AFA                          4978  * Print 2 ------------------------------------------
00004AFA                          4979  n2
00004AFA  14FC 0032               4980              MOVE.B  #'2',(A2)+      * add 2 to string
00004AFE  4E75                    4981              RTS
00004B00                          4982   
00004B00                          4983              
00004B00                          4984  * Print 3 ------------------------------------------
00004B00                          4985  n3
00004B00  14FC 0033               4986              MOVE.B  #'3',(A2)+      * add 3 to string
00004B04  4E75                    4987              RTS
00004B06                          4988  
00004B06                          4989              
00004B06                          4990  * Print 4 ------------------------------------------
00004B06                          4991  n4
00004B06  14FC 0034               4992              MOVE.B  #'4',(A2)+      * add 4 to string
00004B0A  4E75                    4993              RTS
00004B0C                          4994  
00004B0C                          4995              
00004B0C                          4996  * Print 5 ------------------------------------------
00004B0C                          4997  n5
00004B0C  14FC 0035               4998              MOVE.B  #'5',(A2)+      * add 5 to string
00004B10  4E75                    4999              RTS
00004B12                          5000  
00004B12                          5001              
00004B12                          5002  * Print 6 ------------------------------------------
00004B12                          5003  n6
00004B12  14FC 0036               5004              MOVE.B  #'6',(A2)+      * add 6 to string
00004B16  4E75                    5005              RTS
00004B18                          5006              
00004B18                          5007              
00004B18                          5008  * Print 7 ------------------------------------------
00004B18                          5009  n7
00004B18  14FC 0037               5010              MOVE.B  #'7',(A2)+      * add 7 to string
00004B1C  4E75                    5011              RTS
00004B1E                          5012  
00004B1E                          5013   
00004B1E                          5014  * Print 8 ------------------------------------------
00004B1E                          5015  n8       
00004B1E  14FC 0038               5016              MOVE.B  #'8',(A2)+      * add 8 to string
00004B22  4E75                    5017              RTS
00004B24                          5018  
00004B24                          5019              
00004B24                          5020  * Print 9 ------------------------------------------
00004B24                          5021  n9   
00004B24  14FC 0039               5022              MOVE.B  #'9',(A2)+      * add 9 to string
00004B28  4E75                    5023              RTS
00004B2A                          5024  
00004B2A                          5025              
00004B2A                          5026  * Print A ------------------------------------------
00004B2A                          5027  nA   
00004B2A  14FC 0041               5028              MOVE.B  #'A',(A2)+      * add A to string
00004B2E  4E75                    5029              RTS
00004B30                          5030  
00004B30                          5031              
00004B30                          5032  * Print B ------------------------------------------
00004B30                          5033  nB   
00004B30  14FC 0042               5034              MOVE.B  #'B',(A2)+      * add B to string
00004B34  4E75                    5035              RTS
00004B36                          5036  
00004B36                          5037              
00004B36                          5038  * Print C ------------------------------------------
00004B36                          5039  nC   
00004B36  14FC 0043               5040              MOVE.B  #'C',(A2)+      * add C to string
00004B3A  4E75                    5041              RTS
00004B3C                          5042  
00004B3C                          5043             
00004B3C                          5044  * Print D ------------------------------------------
00004B3C                          5045  nD   
00004B3C  14FC 0044               5046              MOVE.B  #'D',(A2)+      * add D to string
00004B40  4E75                    5047              RTS
00004B42                          5048  
00004B42                          5049             
00004B42                          5050  * Print E ------------------------------------------
00004B42                          5051  nE  
00004B42  14FC 0045               5052              MOVE.B  #'E',(A2)+      * add E to string
00004B46  4E75                    5053              RTS
00004B48                          5054  
00004B48                          5055              
00004B48                          5056  * Print F ------------------------------------------
00004B48                          5057  nF   
00004B48  14FC 0046               5058              MOVE.B  #'F',(A2)+      * add F to string
00004B4C  4E75                    5059              RTS
00004B4E                          5060  
00004B4E                          5061  restart
00004B4E                          5062  
00004B4E  11FC 0000 0065          5063              MOVE.B  #$0,lines_flag  * initialize lines to 0
00004B54  11FC 0000 0014          5064              MOVE.B  #$0,start_flag  *initialize start flag to 0
00004B5A  11FC 0000 0015          5065              MOVE.B  #$0,EA_FLAG     * initialize ea flag to 0 
00004B60  287C 00000000           5066              MOVEA.L #0,A4           * clear current address
00004B66  2A7C 00000000           5067              MOVEA.L #0,A5           * clear ending address
00004B6C                          5068              
00004B6C  6000 C4B0               5069              BRA     GET_LOWER
00004B70                          5070              
00004B70                          5071  
00004B70                          5072  DONE
00004B70                          5073  
00004B70  4240                    5074          CLR     D0
00004B72  43F8 1453               5075          LEA     repeat,A1       * load message to ask if user wants to repeat
00004B76  103C 000E               5076          MOVE.B  #14,D0
00004B7A  4E4F                    5077          TRAP    #15
00004B7C                          5078          
00004B7C  43F8 00AB               5079          LEA     restart_in,A1   * capture the user input
00004B80  7002                    5080          MOVE.L  #2,D0
00004B82  4E4F                    5081          TRAP    #15
00004B84                          5082          
00004B84  1211                    5083          MOVE.B  (A1),D1         * place answer in D1
00004B86  0C01 0059               5084          CMPI.B  #$59,D1         * compare with upper case Y
00004B8A  67C2                    5085          BEQ     restart
00004B8C  0C01 0079               5086          CMPI.B  #$79,D1         * compare with lower case y
00004B90  67BC                    5087          BEQ     restart
00004B92                          5088          
00004B92  43F8 1483               5089          LEA     ending,A1       * chose not to restart, ending message
00004B96  103C 000E               5090          MOVE.B  #14,D0
00004B9A  4E4F                    5091          TRAP    #15
00004B9C                          5092  
00004B9C                          5093      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD0001             155C
ADD001              157E
ADD0010             1558
ADD01               1596
ADD010              157A
ADD0100             1554
ADD10               1592
ADD100              1576
ADD1000             1550
ADD8                2C0C
ADDQB               28EA
ADDQL               29FE
ADDQW               2974
ADDRBOUNDERR        12D1
BADCHAR             128F
BIT0                156E
BIT1                1568
BITTEST             1534
BITTST2             1582
BITTST3             1560
BOUNDSERR           10EE
BT1                 158A
BYTEDISPLP          2E94
CHARERROR           1108
CHECK_INPUT         1066
CHK_BOUNDS          1122
CR                  D
CTST                1548
DISPDONE            2EAE
DONE                4B70
DTST                1542
EA000               490E
EA001               492E
EA010               495C
EA011               4984
EA100               49B0
EA101               49DC
EA110               49E2
EA111               49E8
EATABLE             48CE
EA_FLAG             15
ENDADDR             121F
ENDERR              1361
ENDERROR            11D8
ENDING              1483
END_INPUT           6F
ETST                153C
GETINSTR            1654
GETMODE             1638
GETPC               14FC
GETPCDN             1532
GETPCLP             1516
GETSIZE             159A
GET_LOWER           101E
GET_UPPER           1040
HALT                143B
HALTDISPLAY         14EA
HIERR               13F2
HIERROR             11BE
IMMEDIATE           4A12
ISBYTE              4956
JUMPSR              209C
LF                  A
LINES_FLAG          65
LOERR               13AC
LOHEX               10C0
LONGABS             4A64
LOOPDONE            48CC
LOWERBOUND          1142
LOWERROR            1194
MAIN                14AC
MAINLOOP            14B0
MAXEND              FFFFE0
MINSTART            0
MOVEABS             202A
MOVEADDR            1F92
MOVEDN              1F74
MOVEIND             1FB0
MOVEPOST            1FD6
MOVEPRE             2000
N0                  4AEE
N1                  4AF4
N2                  4AFA
N3                  4B00
N4                  4B06
N5                  4B0C
N6                  4B12
N7                  4B18
N8                  4B1E
N9                  4B24
NA                  4B2A
NB                  4B30
NC                  4B36
ND                  4B3C
NE                  4B42
NEXT                486A
NF                  4B48
NOINPUT             10D4
NOOP                2114
NO_INPUT            1264
NUMTABLE            4A6E
ODDERR              1320
ODDERROR            117A
OP0000              16E8
OP0001              1D2C
OP0010              1DB0
OP0011              1E92
OP0100              204E
OP0101              2874
OP0110              2C10
OP0111              2EB0
OP1000              2F06
OP1001              3362
OP1011              36E2
OP1100              38AE
OP1101              3CBA
OP1110              4126
OPERROR             485E
PD_A1               2544
PD_A2               254C
PD_A3               2554
PD_A4               255C
PD_A5               2564
PD_A6               256C
PD_A7               2574
PD_D0               257C
PD_D1               2584
PD_D2               258C
PD_D3               2594
PD_D4               259C
PD_D5               25A4
PD_D6               25AC
PD_D7               25B4
PI_A0               23A4
PI_A1               23AC
PI_A2               23B4
PI_A3               23BC
PI_A4               23C4
PI_A5               23CC
PI_A6               23D4
PI_A7               23DC
PI_D1               236C
PI_D2               2374
PI_D3               237C
PI_D4               2384
PI_D5               238C
PI_D6               2394
PI_D7               239C
POSTINC             2362
PREDEC              253A
PRINTBLOOP          15C0
PRINTBYTE           15AA
PRINTCODE           83
PRINTDN             1636
PRINTELOOP          48B2
PRINTERRORDATA      48A6
PRINTLINE           1646
PRINTLLOOP          161C
PRINTLONG           1608
PRINTSLASH          2708
PRINTWLOOP          15EE
PRINTWORD           15DA
PRTSLASHDN          2714
READDONE            10D2
READNEXT            107A
REPEAT              1453
RESTART             4B4E
RESTART_IN          AB
RETURNSR            2106
SHORTABS            4A5A
START               1000
STARTADDR           11E6
START_FLAG          14
START_INPUT         0
SUBQB               2AB2
SUBQL               2BC6
SUBQW               2B3C
SUB_EA              352C
UPHEX               10A6
UPPERBOUND          115E
_A0                 2490
_A1                 24A6
_A2                 24BC
_A3                 24D2
_A4                 24E8
_A5                 24FE
_A6                 2514
_A7                 252A
_ADDA               404A
_ADDAW              40BC
_ADDB               3CF0
_ADDBEA             3EB8
_ADDEA              3E8E
_ADDI               1ABC
_ADDIB              1AE0
_ADDIL              1B98
_ADDIW              1B3C
_ADDL               3E04
_ADDLEA             3FC4
_ADDQB              28A6
_ADDQL              29BA
_ADDQW              2930
_ADDW               3D7A
_ADDWEA             3F3E
_AND                3932
_ANDB               3960
_ANDBEA             3B28
_ANDEA              3AFE
_ANDI               1854
_ANDIB              1878
_ANDIL              1928
_ANDIW              18CC
_ANDL               3A74
_ANDLEA             3C34
_ANDW               39EA
_ANDWEA             3BAE
_AS                 41B0
_ASB                4396
_ASLONG             46DA
_ASR                41E4
_ASRB               43CA
_ASRLONG            470E
_ASRW               456C
_ASW                4538
_BCC                2CA0
_BCS                2CE4
_BGE                2D6C
_BGT                2DF4
_BLE                2E38
_BLT                2DB0
_BNE                2D28
_BRA                2C5C
_BYTEDATA           4A30
_BYTEDISP           2E88
_BYTESHIFT          4314
_CLR                2716
_CLRB               2736
_CLRL               280A
_CLRW               27A0
_CMPB               3710
_CMPI               1BF4
_CMPIB              1C18
_CMPIL              1CD0
_CMPIW              1C74
_CMPL               3824
_CMPW               379A
_CONT               14C2
_D0                 23E6
_D1                 23F6
_D2                 240C
_D3                 2422
_D4                 2438
_D5                 244E
_D6                 2464
_D7                 247A
_DIVS               2F8C
_DIVU               2F22
_LEA                2122
_LONGDATA           4A4C
_LONGDISP           2E82
_LONGSHIFT          4658
_LS                 4210
_LSB                43F6
_LSLONG             473A
_LSR                4244
_LSRB               442A
_LSRLONG            476E
_LSRW               45CC
_LSW                4598
_MOVEAL             1E44
_MOVEAW             1F26
_MOVEM              21C4
_MOVEMAN            229E
_MOVEMANL           2304
_MOVEMDN            21DA
_MOVEMDNL           2240
_OR                 2FE0
_ORB                300E
_ORB_EA             31D0
_OREA               31AC
_ORI                171C
_ORIB               1740
_ORIL               17F8
_ORIW               179C
_ORL                3122
_ORL_EA             32DC
_ORW                3098
_ORW_EA             3256
_PDA0               265A
_PDA1               2670
_PDA2               2686
_PDA3               269C
_PDA4               26B2
_PDA5               26C8
_PDA6               26DE
_PDA7               26F4
_PDD0               25BE
_PDD1               25CC
_PDD2               25E0
_PDD3               25F4
_PDD4               2608
_PDD5               261C
_PDD6               2632
_PDD7               2648
_ROR                4184
_RORB               436A
_RORLONG            46AE
_RORW               450C
_ROX                4270
_ROXB               4456
_ROXLONG            479A
_ROXR               42A8
_ROXRB              448A
_ROXRLONG           47CE
_ROXRW              462C
_ROXW               45F8
_SHFTIM             484E
_SHFTMEMEA          42D8
_SHIFTDEST          481C
_SHIFTEA            47FA
_SHIFTIMM           4836
_SHIFTREG           42FC
_SUBB               338E
_SUBB_EA            3550
_SUBI               1984
_SUBIB              19A8
_SUBIL              1A60
_SUBIW              1A04
_SUBL               34A2
_SUBL_EA            365C
_SUBQ               2A44
_SUBQB              2A6E
_SUBQL              2B82
_SUBQW              2AF8
_SUBW               3418
_SUBW_EA            35D6
_WORDDATA           4A3E
_WORDDISP           2E7C
_WORDSHIFT          44B6
