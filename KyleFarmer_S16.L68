00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/5/2016 12:01:50 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Kyle Farmer
00000000                             4  * Date       : 5/11/2016
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000                             7  start_input DS.B       20   * address used to store user input for start address
00000014                             8  start_flag  DS.B       1    * used to determine if the start address has been entered
00000015                             9  EA_FLAG     DS.B       80   * set if an error in the instruction caused A4 to move beyond next instruction
00000065                            10  lines_flag  DS.B       10   * number of lines until the halt display needs to be called
0000006F                            11  end_input   DS.B       20   * address used to store user input for end address
00000083                            12  printCode   DS.B       40   * starting address to print each line of code
000000AB                            13  restart_in  DS.B       30   * get the user input for restart
000000C9                            14  
000000C9  =00000000                 15  minStart    EQU        $00000000
000000C9  =00FFFFE0                 16  maxEnd      EQU        $00FFFFE0
000000C9  =0000000D                 17  CR          EQU        $0D
000000C9  =0000000A                 18  LF          EQU        $0A
000000C9                            19  
00001000                            20      ORG    $1000
00001000                            21      
00001000                            22  START  
00001000  4C9A 0006                 23              MOVEM.W (A2)+,D1-D2
00001004  4C9A 000E                 24              MOVEM.W (A2)+,D1-D3
00001008  4C9A 0202                 25              MOVEM.W (A2)+,D1/A1
0000100C  48A7 07E0                 26              MOVEM.W A0/A1/A2/D5/D6/D7,-(SP)
00001010  11FC 0000 0065            27              MOVE.B  #$0,lines_flag  * initialize lines to 0
00001016  11FC 0000 0014            28              MOVE.B  #$0,start_flag  *initialize start flag to 0
0000101C  11FC 0000 0015            29              MOVE.B  #$0,EA_FLAG     * initialize ea flag to 0        
00001022                            30  * gather user input for starting address *
00001022  43F9 000011EA             31  GET_LOWER   LEA     startAddr,A1
00001028  700E                      32              MOVE.L  #14,D0
0000102A  4E4F                      33              TRAP    #15
0000102C  43F8 0000                 34              LEA     start_input,A1
00001030  7002                      35              MOVE.L  #2,D0
00001032  4E4F                      36              TRAP    #15
00001034  4244                      37              CLR     D4
00001036  4EB9 0000106A             38              JSR     CHECK_INPUT
0000103C  4EB9 00001126             39              JSR     CHK_BOUNDS
00001042  2844                      40              MOVE.L  D4,A4
00001044                            41  * gather user input for upper address            
00001044  43F9 00001223             42  GET_UPPER   LEA     endAddr,A1
0000104A  700E                      43              MOVE.L  #14,D0
0000104C  4E4F                      44              TRAP    #15
0000104E  43F8 006F                 45              LEA     end_input,A1
00001052  7002                      46              MOVE.L  #2,D0
00001054  4E4F                      47              TRAP    #15
00001056  4244                      48              CLR     D4
00001058  4EB9 0000106A             49              JSR     CHECK_INPUT
0000105E  4EB9 00001126             50              JSR     CHK_BOUNDS
00001064  2A44                      51              MOVE.L  D4,A5
00001066  6000 0448                 52              BRA     MAIN
0000106A                            53              
0000106A                            54  ****************************************************************
0000106A                            55  * CHECK_INPUT:                                               *
0000106A                            56  * Checks input for the entered string and convert ascii to hex *
0000106A                            57  * and determines if the address entered was valid              *
0000106A                            58  ****************************************************************
0000106A                            59  
0000106A                            60  CHECK_INPUT
0000106A  183C 0000                 61              MOVE.B  #$0,D4   * D4 will be register to hold resultant address
0000106E  B23C 0000                 62              CMP.B   #$0,D1
00001072  6700 0064                 63              BEQ     noInput  * check for no address entered
00001076  0C41 0008                 64              CMPI    #$8,D1  
0000107A  6E00 0076                 65              BGT     boundsErr  * check for too many chars entered
0000107E                            66         
0000107E  1419                      67  readNext    MOVE.B  (A1)+,D2    
00001080  0C02 0000                 68              CMPI.B   #$0,D2       * check for NULL, indicating finished
00001084  6700 0050                 69              BEQ     readDone
00001088                            70              * check upper and lower ASCII bounds: 0-f
00001088  0C02 0030                 71              CMPI.B   #$30,D2     * entered an ASCII less than 0
0000108C  6D00 007E                 72              BLT     charError
00001090  0C02 0066                 73              CMPI.B   #$66,D2     * entered an ASCII greater than 'f'
00001094  6E00 0076                 74              BGT     charError
00001098                            75              * within bounds so check for valid inputs
00001098  0C02 0039                 76              CMPI.B   #$39,D2     
0000109C  6E00 000C                 77              BGT     upHex       * entered an ASCII greater than 0-9
000010A0                            78              
000010A0                            79              * value is between 0-9, convert to decimal
000010A0  0402 0030                 80              SUBI.B  #$30,D2     * subtract $30 to get its dec representation
000010A4  E98C                      81              LSL.L   #4,D4       * shift resultant left 4 bits
000010A6  D802                      82              ADD.B   D2,D4       * add the next 4 bits to resultant
000010A8  60D4                      83              BRA     readNext
000010AA                            84              
000010AA                            85              * value is larger than decimal number, but within range
000010AA  0C02 0046                 86  upHex       CMPI.B  #$46,D2     * cmp value to 'F'
000010AE  6E00 0014                 87              BGT     loHex       * value is larger than uppercase hex
000010B2  B43C 0040                 88              CMP.B   #$40,D2     * cmp value to 'A'
000010B6  6D00 0054                 89              BLT     charError       * value is an unsupported character
000010BA                            90              
000010BA                            91              * value is not below A or above F, convert to hex and add to D6
000010BA  0402 0037                 92              SUBI.B  #$37,D2
000010BE  E98C                      93              LSL.L   #4,D4       * shift left 4 bits
000010C0  D802                      94              ADD.B   D2,D4       * add the next 4 bits
000010C2  60BA                      95              BRA     readNext
000010C4                            96              
000010C4                            97  loHex       * value is within bounds, but greater than 0-9 & A-F
000010C4  0C02 0061                 98              CMPI.B  #$61,D2     * cmp value to '`', 1 place below 'a'
000010C8  6D00 0042                 99              BLT     charError       * branch to error if this occurred 
000010CC                           100              * value is valid and is between a-f
000010CC  0402 0057                101              SUBI.B  #$57,D2
000010D0  E98C                     102              LSL.L   #4,D4
000010D2  D802                     103              ADD.B   D2,D4
000010D4  60A8                     104              BRA     readNext
000010D6                           105  
000010D6  4E75                     106  readDone    RTS
000010D8                           107  
000010D8  43F9 00001268            108  noInput     LEA     no_Input,A1     * load error message
000010DE  700E                     109              MOVE.L  #14,D0
000010E0  4E4F                     110              TRAP    #15
000010E2  1C38 0014                111              MOVE.B  start_flag,D6   * load start flag to D6
000010E6  BC3C 0000                112              CMP.B   #$0,D6          * check if the start addr has been entered correctly
000010EA  6D00 FF36                113              BLT     GET_LOWER       * get lower addr if not
000010EE  6000 FF54                114              BRA     GET_UPPER       * get upper
000010F2                           115              
000010F2  43F9 000012D5            116  boundsErr   LEA     addrBoundErr,A1 * load error message
000010F8  700E                     117              MOVE.L  #14,D0
000010FA  4E4F                     118              TRAP    #15
000010FC  1C38 0014                119              MOVE.B  start_flag,D6
00001100  BC3C 0000                120              CMP.B   #$0,D6
00001104  6D00 FF1C                121              BLT     GET_LOWER
00001108  6000 FF3A                122              BRA     GET_UPPER
0000110C                           123              
0000110C  43F9 00001293            124  charError   LEA     badChar,A1      * load error message
00001112  700E                     125              MOVE.L  #14,D0
00001114  4E4F                     126              TRAP    #15
00001116  1C38 0014                127              MOVE.B  start_flag,D6
0000111A  BC3C 0000                128              CMP.B   #$0,D6
0000111E                           129  
0000111E  6D00 FF02                130              BLT     GET_LOWER
00001122  6000 FF20                131              BRA     GET_UPPER 
00001126                           132              
00001126                           133  * CHECK_BOUNDS
00001126                           134  
00001126  4246                     135  CHK_BOUNDS  CLR     D6              * clear D6
00001128  3C04                     136              MOVE.W  D4,D6           * move user input address to D6
0000112A  0206 0001                137              ANDI.B  #$1,D6          * bit check if it is odd
0000112E  0C06 0001                138              CMPI.B  #$1,D6
00001132  6700 004A                139              BEQ     OddError        * odd, break and print error message
00001136  1C38 0014                140              MOVE.B  start_flag,D6   * move byte start flag to D6
0000113A  0C06 0000                141              CMPI.B  #$0,D6          * if starting address, check lower bounds
0000113E  6700 0006                142              BEQ     lowerBound
00001142  6000 001E                143              BRA     upperBound      * else check upper bounds
00001146                           144  
00001146  0C84 00000000            145  lowerBound  CMPI.L  #minStart,D4    * is the lower bound less than the start address bound?
0000114C  6D00 004A                146              BLT     lowError
00001150  0C84 00FFFFE0            147              CMPI.L  #maxEnd,D4      * is the lower bound greater than the end address bound?
00001156  6E00 006A                148              BGT     hiError
0000115A  11FC 0001 0014           149              MOVE.B  #$1,start_flag  * move 1 to starting flag, indicating the starting 
00001160                           150                                      * address has been successfully entered
00001160  4E75                     151              RTS 
00001162                           152  
00001162                           153  
00001162  0C84 00000000            154  upperBound  CMPI.L  #minStart,D4    * end address is smaller than starting bounds
00001168  6D00 002E                155              BLT     lowError
0000116C  0C84 00FFFFE0            156              CMPI.L  #maxEnd,D4      * ending address goes beyond bounds
00001172  6E00 004E                157              BGT     hiError
00001176  B88C                     158              CMP.L   A4,D4           * compare start address to end address
00001178  6D00 0062                159              BLT     endError        * branch to error if they are the same or end is lower
0000117C  4E75                     160              RTS 
0000117E                           161  
0000117E                           162              
0000117E  43F9 00001324            163  OddError    LEA     oddErr,A1   * load error message
00001184  700E                     164              MOVE.L  #14,D0
00001186  4E4F                     165              TRAP    #15
00001188  1C38 0014                166              MOVE.B  start_flag,D6   * check if the starting address is valid
0000118C  BC3C 0000                167              CMP.B   #$0,D6          * if flag has not been set to 1, return to starting address
00001190  6700 FE90                168              BEQ     GET_LOWER       
00001194  6000 FEAE                169              BRA     GET_UPPER 
00001198                           170              
00001198  E384                     171  lowError    ASL.L   #1,D4    * this covers the case of FFFFFFFE without this, 
0000119A                           172              * it will interpret FFFFFFFE as smaller than 00000000 and print low error
0000119A  6500 0026                173              BCS     hiError
0000119E  0C84 01000000            174              CMPI.L  #$1000000,D4 * covers the case of D4>00ffffe0
000011A4  6C00 001C                175              BGE     hiError         
000011A8  43F9 000013B0            176              LEA     loErr,A1    * load error message
000011AE  700E                     177              MOVE.L  #14,D0
000011B0  4E4F                     178              TRAP    #15
000011B2  1C38 0014                179              MOVE.B  start_flag,D6   * check if the starting address is valid
000011B6  BC3C 0000                180              CMP.B   #$0,D6
000011BA  6700 FE66                181              BEQ     GET_LOWER       
000011BE  6000 FE84                182              BRA     GET_UPPER 
000011C2                           183      
000011C2  43F9 000013F6            184  hiError     LEA     hiErr,A1        * load high error message
000011C8  700E                     185              MOVE.L  #14,D0
000011CA  4E4F                     186              TRAP    #15
000011CC  1C38 0014                187              MOVE.B  start_flag,D6   * check if the starting address is valid
000011D0  BC3C 0000                188              CMP.B   #$0,D6
000011D4  6700 FE4C                189              BEQ     GET_LOWER       
000011D8  6000 FE6A                190              BRA     GET_UPPER 
000011DC                           191  
000011DC  43F9 00001365            192  endError    LEA     endErr,A1       * load starting larger than ending address error
000011E2  700E                     193              MOVE.L  #14,D0
000011E4  4E4F                     194              TRAP    #15
000011E6  6000 FE5C                195              BRA     GET_UPPER       * branch back to getting ending address
000011EA                           196              
000011EA= 45 6E 74 65 72 20 ...    197  startAddr   DC.B    'Enter a starting address from $00000000 to $00FFFFE0: ',CR,LF,0
00001223= 45 6E 74 65 72 20 ...    198  endAddr     DC.B    'Enter an ending address greater or equal to the starting address: ',CR,LF,0
00001268= 0D 0A 4E 6F 20 69 ...    199  no_Input    DC.B    CR,LF,'No input, please enter a valid address',CR,LF,0
00001293= 0D 0A 42 61 64 20 ...    200  badChar     DC.B    CR,LF,'Bad character entered in address, please re-enter the address',CR,LF,0
000012D5= 0D 0A 54 68 65 20 ...    201  addrBoundErr DC.B CR,LF,'The address entered contained too many characters, please re-enter address',CR,LF,0
00001324= 0D 0A 54 68 65 20 ...    202  oddErr      DC.B    CR,LF,'The address entered was odd, please re-enter a valid address',CR,LF,0 
00001365= 0D 0A 45 6E 64 69 ...    203  endErr      DC.B    CR,LF,'Ending address is lower than starting address, please re-enter address',CR,LF,0
000013B0= 0D 0A 41 64 64 72 ...    204  loErr       DC.B    CR,LF,'Address is smaller than specified bounds, please re-enter address',CR,LF,0
000013F6= 0D 0A 41 64 64 72 ...    205  hiErr       DC.B    CR,LF,'Address is larger than the specified bounds, please re-enter address',CR,LF,0
0000143F= 50 72 65 73 73 20 ...    206  halt        DC.B    'Press Enter to continue',0 
00001457= 57 6F 75 6C 64 20 ...    207  repeat     DC.B    'Would you like to load another program? (Y/N): ',0
00001487= 0D 0A 54 68 61 6E ...    208  ending      DC.B    CR,LF,'Thank you for using this disassembler',0
000014AF                           209  
000014B0  45F8 0083                210  MAIN        LEA     printCode,A2
000014B4                           211              
000014B4                           212  MAINLOOP    * IF start >= end, disassemble done
000014B4  B9CD                     213              CMPA.L   A5,A4
000014B6  6E00 36BC                214              BGT     DONE
000014BA                           215              * if screen full, halt display and continue
000014BA  1038 0065                216              MOVE.B  lines_flag,D0
000014BE  0C40 001E                217              CMPI.W  #30,D0      * 30 lines reached?
000014C2  6700 002A                218              BEQ     haltDisplay * halt display
000014C6                           219              * reset EA_FLAG
000014C6  11FC 0000 0015           220  _Cont       MOVE.B  #$0,EA_FLAG
000014CC  4285                     221              CLR.L   D5
000014CE  4207                     222              CLR.B   D7
000014D0  4EB9 00001500            223              JSR GetPC    * get PC
000014D6                           224  
000014D6  4EB9 00001658            225              JSR GetInstr * get instruction
000014DC                           226   
000014DC  4EB9 0000164A            227              JSR printLine * print the line
000014E2                           228              
000014E2  1038 0065                229              MOVE.B  lines_flag,D0   * increment the number of lines
000014E6  5240                     230              ADDQ    #1,D0
000014E8  11C0 0065                231              MOVE.B  D0,lines_flag
000014EC  60C6                     232              BRA     MAINLOOP  * branch back to beginning of loop
000014EE                           233              
000014EE                           234  haltDisplay
000014EE  43F8 143F                235              LEA     halt,A1
000014F2  700E                     236              MOVE.L  #14,D0
000014F4  4E4F                     237              TRAP    #15
000014F6  43F8 0000                238              LEA     start_input,A1
000014FA  7002                     239              MOVE.L  #2,D0
000014FC  4E4F                     240              TRAP    #15
000014FE                           241              
000014FE  60C6                     242              BRA _Cont
00001500                           243              
00001500                           244  ******************************************************************
00001500                           245  * GetPC
00001500                           246  ******************************************************************            
00001500  45F8 0083                247  GetPC       LEA     printCode,A2
00001504  4DF9 00004A72            248              LEA     numTable,A6
0000150A  4286                     249              CLR.L   D6
0000150C  4282                     250              CLR.L   D2
0000150E  260C                     251              MOVE.L  A4,D3      * move address into data r3
00001510                           252              * given since no address can be bigger than 00ffffe0
00001510  14FC 0030                253              MOVE.B  #'0',(A2)+ * add two zeros to the string
00001514  14FC 0030                254              MOVE.B  #'0',(A2)+
00001518  E98B                     255              LSL.L   #4,D3      * shift leading zeros out
0000151A                           256              
0000151A  E98B                     257  GetPClp     LSL.L   #4,D3   * shift 4 bits out   
0000151C  0C02 0006                258              CMPI.B  #6,D2   * if the loop has gone thru 6 times,
00001520  6700 0014                259              BEQ     GetPCDn * finish 
00001524  4EB9 00001538            260              JSR     BITTEST * get leading 4 bits hex representation
0000152A  CCFC 0008                261              MULU.W  #8,D6   * mult by 8 for jump offset
0000152E  4EB6 6000                262              JSR     (A6,D6) * jump to the table to add to string
00001532  5242                     263              ADDQ    #1,D2   * increment loop counter
00001534  60E4                     264              BRA     GetPClp
00001536  4E75                     265  GetPCDn     RTS
00001538                           266  
00001538                           267  **************************************************************
00001538                           268  * BITTEST-
00001538                           269  * Bit Test check for the leading 4 bits in D3. If a bit is 
00001538                           270  * marked, it is added to the resultant number held in D6.
00001538                           271  **************************************************************   
00001538  4286                     272  BITTEST     CLR.L   D6
0000153A  0803 001F                273              BTST.L  #$1F,D3
0000153E  6614                     274              BNE.S   add1000
00001540  0803 001E                275  eTst        BTST.L  #$1E,D3
00001544  6612                     276              BNE.S   add0100
00001546  0803 001D                277  dTst        BTST.L  #$1D,D3
0000154A  6610                     278              BNE.S   add0010
0000154C  0803 001C                279  cTst        BTST.L  #$1C,D3
00001550  660E                     280              BNE.S   add0001
00001552  4E75                     281              RTS
00001554                           282                   
00001554  5006                     283  add1000     ADDI.B  #%1000,D6
00001556  60E8                     284              BRA     eTst
00001558                           285              
00001558  5806                     286  add0100     ADDI.B  #%0100,D6
0000155A  60EA                     287              BRA     dTst
0000155C                           288  
0000155C  5406                     289  add0010     ADDI.B  #%0010,D6
0000155E  60EC                     290              BRA     cTst
00001560                           291  
00001560  5206                     292  add0001     ADDI.B  #%0001,D6
00001562  4E75                     293              RTS  
00001564                           294  
00001564                           295  **************************************************************
00001564                           296  * BitTst3- a variation of BITTEST -> used primarily for EA
00001564                           297  * Bit Test check for the leading 3 bits in D3. If a bit is 
00001564                           298  * marked, it is added to the resultant number held in D6.
00001564                           299  **************************************************************             
00001564                           300              
00001564  4286                     301  BitTst3     CLR.L   D6
00001566  0803 001F                302              BTST.L  #$1F,D3
0000156A  660E                     303              BNE.S   add100
0000156C  0803 001E                304  Bit1        BTST.L  #$1E,D3
00001570  660C                     305              BNE.S   add010
00001572  0803 001D                306  Bit0        BTST.L  #$1D,D3
00001576  660A                     307              BNE.S   add001
00001578  4E75                     308              RTS
0000157A                           309                   
0000157A  5806                     310  add100      ADDI.B  #%100,D6
0000157C  60EE                     311              BRA     Bit1
0000157E                           312              
0000157E  5406                     313  add010      ADDI.B  #%010,D6
00001580  60F0                     314              BRA     Bit0
00001582                           315  
00001582  5206                     316  add001      ADDI.B  #%001,D6
00001584  4E75                     317              RTS
00001586                           318  
00001586                           319  **************************************************************
00001586                           320  * BitTst2- a variation of BITTEST 
00001586                           321  * Bit Test check for the leading 2 bits in D3. If a bit is 
00001586                           322  * marked, it is added to the resultant number held in D6.
00001586                           323  ************************************************************** 
00001586                           324              
00001586  4286                     325  BitTst2     CLR.L   D6
00001588  0803 001F                326              BTST.L  #$1F,D3
0000158C  6608                     327              BNE.S   add10
0000158E  0803 001E                328  Bt1         BTST.L  #$1E,D3
00001592  6606                     329              BNE.S   add01
00001594  4E75                     330              RTS
00001596                           331              
00001596  5406                     332  add10       ADDI.B  #%10,D6
00001598  60F4                     333              BRA Bt1
0000159A                           334              
0000159A  5206                     335  add01       ADDI.B  #%01,D6
0000159C  4E75                     336              RTS
0000159E                           337              
0000159E                           338  *******************************************************************************
0000159E                           339  * getSize - 
0000159E                           340  * Subroutine used to get the size bits of a given instruction
0000159E                           341  *******************************************************************************
0000159E                           342  getSize   
0000159E  2604                     343              MOVE.L  D4,D3       * reset D3
000015A0  4843                     344              SWAP    D3          * push D3 to front
000015A2  E18B                     345              LSL.L   #8,D3       * move front 8 bits out
000015A4  4EB8 1586                346              JSR     BitTst2     * test two size bits, hold result in d6
000015A8  2604                     347              MOVE.L  D4,D3       * Reset d3
000015AA  4843                     348              SWAP    D3          * push d3 to front
000015AC  4E75                     349              RTS                 * return
000015AE                           350              
000015AE                           351  **********************************************************************
000015AE                           352  * PrintByte, PrintWord, PrintLong -  
000015AE                           353  * print functions for immediate/absolute numbers categorized by size
000015AE                           354  **********************************************************************            
000015AE                           355  printByte   
000015AE  4242                     356              CLR     D2          * clear d2 for counter
000015B0  4DF9 00004A72            357              LEA     numTable,A6 
000015B6  2A0C                     358              MOVE.L  A4,D5       * save current address in case of error
000015B8  361C                     359              MOVE.W  (A4)+,D3    * get the immediate word data
000015BA  4843                     360              SWAP    D3          * swap to front
000015BC  E18B                     361              LSL.L   #8,D3       * shift out leading 8 bits, dealing with 1 byte
000015BE  11FC 0001 0015           362              MOVE.B  #1,EA_FLAG  * set ea flag
000015C4                           363              
000015C4                           364  printBLoop  
000015C4  0C02 0002                365              CMPI.B  #2,D2       * loop through twice,
000015C8  6700 0070                366              BEQ     printDn     * print done
000015CC  4EB8 1538                367              JSR     BITTEST     * get leading 4 bits
000015D0  CCFC 0008                368              MULU    #8,D6       * multiply by 8 for jump offset 
000015D4  4EB6 6000                369              JSR     (A6,D6)     * get number from table and add to A2 string
000015D8  E98B                     370              LSL.L   #4,D3       * shift out the 4 bits were done with
000015DA  5242                     371              ADDQ    #1,D2       * increment loop counter
000015DC  60E6                     372              BRA     printBLoop
000015DE                           373              
000015DE                           374  
000015DE                           375  printWord
000015DE  4242                     376              CLR     D2      * clear d2 for counter
000015E0  4DF9 00004A72            377              LEA     numTable,A6
000015E6  2A0C                     378              MOVE.L  A4,D5       * save current address in case of error
000015E8  361C                     379              MOVE.W  (A4)+,D3    * get the immediate word data
000015EA  4843                     380              SWAP    D3          * swap to front
000015EC  11FC 0001 0015           381              MOVE.B  #1,EA_FLAG  * set ea flag
000015F2                           382              
000015F2                           383  printWLoop  
000015F2  0C02 0004                384              CMPI.B  #4,D2       * loop through 4 times,
000015F6  6700 0042                385              BEQ     printDn     * print done
000015FA  4EB8 1538                386              JSR     BITTEST     * get leading 4 bits
000015FE  CCFC 0008                387              MULU    #8,D6       * multiply by 8 for jump offset
00001602  4EB6 6000                388              JSR     (A6,D6)     * get number from table and add to A2 string
00001606  E98B                     389              LSL.L   #4,D3       * shift out 4 biths were done with
00001608  5242                     390              ADDQ    #1,D2       * increment loop counter
0000160A  60E6                     391              BRA     printWLoop  * branch back to loop
0000160C                           392  
0000160C                           393  printLong
0000160C  4242                     394              CLR     D2      * clear d2 for counter
0000160E  4DF9 00004A72            395              LEA     numTable,A6
00001614  2A0C                     396              MOVE.L  A4,D5       * save current address in case of error
00001616  5485                     397              ADDI.L  #$2,D5      * increment D5 to the next instruction
00001618  261C                     398              MOVE.L  (A4)+,D3    * get the immediate long data into D3
0000161A                           399              * no swapping necessary, already longword
0000161A  11FC 0001 0015           400              MOVE.B  #1,EA_FLAG  * set ea flag
00001620                           401              
00001620                           402  printLLoop
00001620  0C02 0008                403              CMPI.B  #8,D2       * loop through 8 times,
00001624  6700 0014                404              BEQ     printDn     * finish
00001628  4EB8 1538                405              JSR     BITTEST     * get leading 4 bits
0000162C  CCFC 0008                406              MULU    #8,D6       * multiply number by 8 for jump offset
00001630  4EB6 6000                407              JSR     (A6,D6)     * get number from table and add to A2 string
00001634  E98B                     408              LSL.L   #4,D3       * shift out 4 bits already used
00001636  5242                     409              ADDQ    #1,D2       * increment loop counter
00001638  60E6                     410              BRA     printLLoop  * branch back to loop beginning
0000163A                           411  
0000163A  4E75                     412  printDn     RTS
0000163C                           413  
0000163C                           414  *************************************************************
0000163C                           415  * getMode
0000163C                           416  *************************************************************
0000163C  2604                     417  getMode     MOVE.L  D4,D3       * reset D3
0000163E  4843                     418              SWAP    D3
00001640  E18B                     419              LSL.L   #8,D3       * shift out leading 10 bits to check 3-5
00001642  E58B                     420              LSL.L   #2,D3
00001644  4EB8 1564                421              JSR     BitTst3     * test 3 bits, hold result in D6
00001648  4E75                     422              RTS                 * return
0000164A                           423              
0000164A                           424  **************************************************************
0000164A                           425  * printLine
0000164A                           426  **************************************************************
0000164A                           427  printLine       
0000164A  14BC 0000                428                  MOVE.B  #$00,(A2)   * add null terminator to string
0000164E  43F8 0083                429                  LEA     printCode,A1
00001652  700D                     430                  MOVEQ   #13,D0
00001654  4E4F                     431                  TRAP    #15
00001656                           432                  
00001656  4E75                     433                  RTS
00001658                           434              
00001658                           435  
00001658                           436  **********************************************
00001658                           437  * Get Instruction         
00001658                           438  **********************************************
00001658                           439  
00001658                           440  GetInstr    * print spaces before instruction
00001658  14FC 0020                441              MOVE.B  #' ',(A2)+
0000165C  14FC 0020                442              MOVE.B  #' ',(A2)+
00001660  14FC 0020                443              MOVE.B  #' ',(A2)+
00001664  14FC 0020                444              MOVE.B  #' ',(A2)+
00001668  264A                     445              MOVEA.L     A2,A3   * save current string location
0000166A                           446              * clr current D3 contents
0000166A  4283                     447              CLR.L   D3
0000166C  361C                     448              MOVE.W (A4)+,D3 * move instruction word into d3
0000166E  2803                     449              MOVE.L  D3,D4   * save D3
00001670  4843                     450              SWAP    D3      * swap d3 to upper 16 bits for BITTEST
00001672                           451              * bit test check for the op code
00001672  4EB8 1538                452              JSR     BITTEST
00001676  4843                     453              SWAP    D3      * swap d3 back for comparisons in op codes
00001678                           454              * begin comparisons with different op codes
00001678  0C06 0000                455              CMPI.B  #%0000,D6   * ADDI,ANDI,CMPI,ORI
0000167C  6700 006E                456              BEQ     op0000
00001680  0C06 0001                457              CMPI.B  #%0001,D6   * MOVE.B
00001684  6700 06AA                458              BEQ     op0001
00001688  0C06 0002                459              CMPI.B  #%0010,D6   * MOVE.L/MOVEA.L
0000168C  6700 0726                460              BEQ     op0010
00001690  0C06 0003                461              CMPI.B  #%0011,D6   * MOVE.W/MOVEA.W
00001694  6700 0800                462              BEQ     op0011
00001698  0C06 0004                463              CMPI.B  #%0100,D6   * MOVEM/LEA/CLR/JSR/RTS/NOP
0000169C  6700 09B4                464              BEQ     op0100
000016A0  0C06 0005                465              CMPI.B  #%0101,D6   * ADDQ/SUBQ
000016A4  6700 11D2                466              BEQ     op0101
000016A8  0C06 0006                467              CMPI.B  #%0110,D6   * Bcc (BRA,BCC,BLT,BGE)
000016AC  6700 1566                468              BEQ     op0110
000016B0  0C06 0007                469              CMPI.B  #%0111,D6   * MOVEQ
000016B4  6700 17FE                470              BEQ     op0111
000016B8  0C06 0008                471              CMPI.B  #%1000,D6   * DIVU/DIVS/OR
000016BC  6700 184C                472              BEQ     op1000
000016C0  0C06 0009                473              CMPI.B  #%1001,D6   * SUB
000016C4  6700 1CA0                474              BEQ     op1001
000016C8  0C06 000B                475              CMPI.B  #%1011,D6   * CMP
000016CC  6700 2018                476              BEQ     op1011
000016D0  0C06 000C                477              CMPI.B  #%1100,D6   * MULS/MULU/AND
000016D4  6700 21DC                478              BEQ     op1100
000016D8  0C06 000D                479              CMPI.B  #%1101,D6   * ADD/ADDA
000016DC  6700 25E0                480              BEQ     op1101
000016E0  0C06 000E                481              CMPI.B  #%1110,D6   * LSL/LSR/ASL/ASR/ROL/ROR
000016E4  6700 2A44                482              BEQ     op1110
000016E8                           483              * if no op code found, print op error/not supported
000016E8                           484              
000016E8  6000 3178                485              BRA     OPERROR
000016EC                           486  
000016EC                           487  * ADDI, ANDI, CMPI, ORI, SUBI ------------------------------------
000016EC                           488  op0000
000016EC  4843                     489              SWAP    D3
000016EE  E98B                     490              LSL.L   #4,D3   * shift out opcode
000016F0  4EB8 1538                491              JSR     BITTEST * test next four bits
000016F4  0C06 0000                492              CMPI.B  #%0000,D6
000016F8  6700 0026                493              BEQ     _OrI    * go to ORI
000016FC  0C06 0002                494              CMPI.B  #%0010,D6
00001700  6700 0156                495              BEQ     _AndI   * go to ANDI
00001704  0C06 0004                496              CMPI.B  #%0100,D6
00001708  6700 027E                497              BEQ     _SubI   * go to SUBI
0000170C  0C06 0006                498              CMPI.B  #%0110,D6
00001710  6700 03AE                499              BEQ     _AddI   * go to ADDI
00001714  0C06 000C                500              CMPI.B  #%1100,D6
00001718  6700 04DE                501              BEQ     _CmpI   * go to CMPI
0000171C                           502              
0000171C                           503              * if none of these, unsupported/error
0000171C  6000 3144                504              BRA     OPERROR
00001720                           505              
00001720                           506  * ORI --------------------------------------------------------------------------------
00001720                           507  
00001720  E98B                     508  _OrI        LSL.L   #4,D3   * shift next 4 bits to check for size
00001722  4EB8 1586                509              JSR     BitTst2 * check the size bits
00001726  EB8B                     510              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
00001728  0C06 0000                511              CMPI.B  #%00,D6 * branch to appropriate size label
0000172C  6700 0016                512              BEQ     _OrIb   * ORI.B
00001730  0C06 0001                513              CMPI.B  #%01,D6
00001734  6700 006A                514              BEQ     _OrIw   * ORI.W
00001738  0C06 0002                515              CMPI.B  #%10,D6
0000173C  6700 00BE                516              BEQ     _OrIl   * ORI.L
00001740                           517              * something unexpected
00001740  6000 3120                518              BRA     OPERROR
00001744                           519  * ORI.B ---------------------            
00001744                           520  _OrIb
00001744                           521              
00001744  14FC 004F                522              MOVE.B  #'O',(A2)+
00001748  14FC 0052                523              MOVE.B  #'R',(A2)+
0000174C  14FC 0049                524              MOVE.B  #'I',(A2)+
00001750  14FC 002E                525              MOVE.B  #'.',(A2)+ 
00001754  14FC 0042                526              MOVE.B  #'B',(A2)+ 
00001758  14FC 0020                527              MOVE.B  #' ',(A2)+ 
0000175C  14FC 0020                528              MOVE.B  #' ',(A2)+ 
00001760  14FC 0020                529              MOVE.B  #' ',(A2)+ 
00001764  14FC 0020                530              MOVE.B  #' ',(A2)+ 
00001768  14FC 0020                531              MOVE.B  #' ',(A2)+
0000176C  14FC 0023                532              MOVE.B  #'#',(A2)+
00001770  14FC 0024                533              MOVE.B  #'$',(A2)+
00001774  4EB8 15AE                534              JSR     printByte
00001778  14FC 002C                535              MOVE.B  #',',(A2)+
0000177C                           536              
0000177C  4EB8 163C                537              JSR     getMode
00001780  BC3C 0001                538              CMP.B   #%001,D6    * compare with Ar
00001784  6700 30DC                539              BEQ     OPERROR     * error
00001788                           540              
00001788  4DF9 000048D2            541              LEA     eaTable,A6
0000178E  CCFC 0008                542              MULU    #8,D6
00001792  4EB6 6000                543              JSR     (A6,D6)
00001796                           544              * check for error in EA
00001796  0C07 0004                545              CMPI.B  #4,D7
0000179A  6700 30C6                546              BEQ     OPERROR
0000179E                           547              
0000179E                           548              
0000179E  4E75                     549              RTS            
000017A0                           550  * ORI.W ----------------------
000017A0                           551  _OrIw       
000017A0                           552             
000017A0  14FC 004F                553              MOVE.B  #'O',(A2)+
000017A4  14FC 0052                554              MOVE.B  #'R',(A2)+
000017A8  14FC 0049                555              MOVE.B  #'I',(A2)+
000017AC  14FC 002E                556              MOVE.B  #'.',(A2)+ 
000017B0  14FC 0057                557              MOVE.B  #'W',(A2)+ 
000017B4  14FC 0020                558              MOVE.B  #' ',(A2)+ 
000017B8  14FC 0020                559              MOVE.B  #' ',(A2)+ 
000017BC  14FC 0020                560              MOVE.B  #' ',(A2)+ 
000017C0  14FC 0020                561              MOVE.B  #' ',(A2)+ 
000017C4  14FC 0020                562              MOVE.B  #' ',(A2)+
000017C8  14FC 0023                563              MOVE.B  #'#',(A2)+
000017CC  14FC 0024                564              MOVE.B  #'$',(A2)+
000017D0  4EB8 15DE                565              JSR     printWord
000017D4  14FC 002C                566              MOVE.B  #',',(A2)+
000017D8                           567              
000017D8  4EB8 163C                568              JSR     getMode
000017DC  BC3C 0001                569              CMP.B   #%001,D6    * compare with Ar
000017E0  6700 3080                570              BEQ     OPERROR     * error
000017E4  4DF9 000048D2            571              LEA     eaTable,A6   * load ea table
000017EA  CCFC 0008                572              MULU    #8,D6       * multiply for offset
000017EE  4EB6 6000                573              JSR     (A6,D6)     * jump to offset
000017F2                           574              * check for error in EA
000017F2  0C07 0004                575              CMPI.B  #4,D7
000017F6  6700 306A                576              BEQ     OPERROR
000017FA                           577               
000017FA  4E75                     578              RTS  
000017FC                           579  * ORI.L ----------------------
000017FC                           580  _OrIl       
000017FC  14FC 004F                581              MOVE.B  #'O',(A2)+
00001800  14FC 0052                582              MOVE.B  #'R',(A2)+
00001804  14FC 0049                583              MOVE.B  #'I',(A2)+
00001808  14FC 002E                584              MOVE.B  #'.',(A2)+ 
0000180C  14FC 004C                585              MOVE.B  #'L',(A2)+ 
00001810  14FC 0020                586              MOVE.B  #' ',(A2)+ 
00001814  14FC 0020                587              MOVE.B  #' ',(A2)+ 
00001818  14FC 0020                588              MOVE.B  #' ',(A2)+ 
0000181C  14FC 0020                589              MOVE.B  #' ',(A2)+ 
00001820  14FC 0020                590              MOVE.B  #' ',(A2)+
00001824  14FC 0023                591              MOVE.B  #'#',(A2)+
00001828  14FC 0024                592              MOVE.B  #'$',(A2)+
0000182C  4EB8 160C                593              JSR     printLong
00001830  14FC 002C                594              MOVE.B  #',',(A2)+
00001834                           595              
00001834  4EB8 163C                596              JSR     getMode
00001838  BC3C 0001                597              CMP.B   #%001,D6    * compare with Ar
0000183C  6700 3024                598              BEQ     OPERROR     * error
00001840  4DF9 000048D2            599              LEA     eaTable,A6   
00001846  CCFC 0008                600              MULU    #8,D6
0000184A  4EB6 6000                601              JSR     (A6,D6)
0000184E                           602              * check for error in EA
0000184E  0C07 0004                603              CMPI.B  #4,D7
00001852  6700 300E                604              BEQ     OPERROR
00001856                           605              
00001856  4E75                     606              RTS  
00001858                           607              
00001858                           608  * ANDI ------------------------------------------------------------------------------
00001858  E98B                     609  _AndI       LSL.L   #4,D3
0000185A  4EB8 1586                610              JSR     BitTst2
0000185E  EB8B                     611              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
00001860  0C06 0000                612              CMPI.B  #%00,D6 * branch to appropriate size label
00001864  6700 0016                613              BEQ     _AndIb   * ANDI.B
00001868  0C06 0001                614              CMPI.B  #%01,D6
0000186C  6700 0062                615              BEQ     _AndIw  * ANDI.W
00001870  0C06 0002                616              CMPI.B  #%10,D6
00001874  6700 00B6                617              BEQ     _AndIl   * ANDI.L
00001878                           618              * something unexpected
00001878  6000 2FE8                619              BRA     OPERROR
0000187C                           620              
0000187C                           621  * ANDI.B ---------------------
0000187C                           622  _AndIb      
0000187C  14FC 0041                623              MOVE.B  #'A',(A2)+
00001880  14FC 004E                624              MOVE.B  #'N',(A2)+
00001884  14FC 0044                625              MOVE.B  #'D',(A2)+
00001888  14FC 0049                626              MOVE.B  #'I',(A2)+ 
0000188C  14FC 002E                627              MOVE.B  #'.',(A2)+ 
00001890  14FC 0042                628              MOVE.B  #'B',(A2)+ 
00001894  14FC 0020                629              MOVE.B  #' ',(A2)+ 
00001898  14FC 0020                630              MOVE.B  #' ',(A2)+ 
0000189C  14FC 0020                631              MOVE.B  #' ',(A2)+ 
000018A0  14FC 0020                632              MOVE.B  #' ',(A2)+
000018A4  14FC 0023                633              MOVE.B  #'#',(A2)+
000018A8  14FC 0024                634              MOVE.B  #'$',(A2)+
000018AC  4EB8 15AE                635              JSR     printByte
000018B0  14FC 002C                636              MOVE.B  #',',(A2)+
000018B4  4EB8 163C                637              JSR     getMode
000018B8  BC3C 0001                638              CMP.B   #%001,D6    * compare with Ar
000018BC  6700 2FA4                639              BEQ     OPERROR     * error
000018C0                           640              
000018C0  4DF9 000048D2            641              LEA     eaTable,A6
000018C6  CCFC 0008                642              MULU    #8,D6
000018CA  4EB6 6000                643              JSR     (A6,D6)
000018CE                           644              
000018CE  4E75                     645              RTS 
000018D0                           646  
000018D0                           647  * ANDI.W ---------------------
000018D0                           648  _AndIw      
000018D0  14FC 0041                649              MOVE.B  #'A',(A2)+
000018D4  14FC 004E                650              MOVE.B  #'N',(A2)+
000018D8  14FC 0044                651              MOVE.B  #'D',(A2)+
000018DC  14FC 0049                652              MOVE.B  #'I',(A2)+ 
000018E0  14FC 002E                653              MOVE.B  #'.',(A2)+ 
000018E4  14FC 0057                654              MOVE.B  #'W',(A2)+ 
000018E8  14FC 0020                655              MOVE.B  #' ',(A2)+ 
000018EC  14FC 0020                656              MOVE.B  #' ',(A2)+ 
000018F0  14FC 0020                657              MOVE.B  #' ',(A2)+ 
000018F4  14FC 0020                658              MOVE.B  #' ',(A2)+
000018F8  14FC 0023                659              MOVE.B  #'#',(A2)+
000018FC  14FC 0024                660              MOVE.B  #'$',(A2)+
00001900  4EB8 15DE                661              JSR     printWord
00001904  14FC 002C                662              MOVE.B  #',',(A2)+
00001908  4EB8 163C                663              JSR     getMode
0000190C  BC3C 0001                664              CMP.B   #%001,D6    * compare with Ar
00001910  6700 2F50                665              BEQ     OPERROR     * error
00001914                           666              
00001914  4DF9 000048D2            667              LEA     eaTable,A6
0000191A  CCFC 0008                668              MULU    #8,D6
0000191E  4EB6 6000                669              JSR     (A6,D6)
00001922                           670              * check for error in EA
00001922  0C07 0004                671              CMPI.B  #4,D7
00001926  6700 2F3A                672              BEQ     OPERROR
0000192A                           673  
0000192A  4E75                     674              RTS 
0000192C                           675  * ANDI.L ---------------------
0000192C                           676  _AndIl      
0000192C  14FC 0041                677              MOVE.B  #'A',(A2)+
00001930  14FC 004E                678              MOVE.B  #'N',(A2)+
00001934  14FC 0044                679              MOVE.B  #'D',(A2)+
00001938  14FC 0049                680              MOVE.B  #'I',(A2)+ 
0000193C  14FC 002E                681              MOVE.B  #'.',(A2)+ 
00001940  14FC 004C                682              MOVE.B  #'L',(A2)+ 
00001944  14FC 0020                683              MOVE.B  #' ',(A2)+ 
00001948  14FC 0020                684              MOVE.B  #' ',(A2)+ 
0000194C  14FC 0020                685              MOVE.B  #' ',(A2)+ 
00001950  14FC 0020                686              MOVE.B  #' ',(A2)+
00001954  14FC 0023                687              MOVE.B  #'#',(A2)+
00001958  14FC 0024                688              MOVE.B  #'$',(A2)+
0000195C  4EB8 160C                689              JSR     printLong
00001960  14FC 002C                690              MOVE.B  #',',(A2)+
00001964  4EB8 163C                691              JSR     getMode
00001968  BC3C 0001                692              CMP.B   #%001,D6    * compare with Ar
0000196C  6700 2EF4                693              BEQ     OPERROR     * error
00001970                           694              
00001970  4DF9 000048D2            695              LEA     eaTable,A6
00001976  CCFC 0008                696              MULU    #8,D6
0000197A  4EB6 6000                697              JSR     (A6,D6)
0000197E                           698              * check for error in EA
0000197E  0C07 0004                699              CMPI.B  #4,D7
00001982  6700 2EDE                700              BEQ     OPERROR
00001986                           701  
00001986  4E75                     702              RTS 
00001988                           703  
00001988                           704  * SUBI ------------------------------------------------------------------------------
00001988  E98B                     705  _SubI       LSL.L   #4,D3
0000198A  4EB8 1586                706              JSR     BitTst2
0000198E  EB8B                     707              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
00001990  0C06 0000                708              CMPI.B  #%00,D6 * branch to appropriate size label
00001994  6700 0016                709              BEQ     _SubIb   * SUBI.B
00001998  0C06 0001                710              CMPI.B  #%01,D6
0000199C  6700 006A                711              BEQ     _SubIw   * SUBI.W
000019A0  0C06 0002                712              CMPI.B  #%10,D6
000019A4  6700 00BE                713              BEQ     _SubIl   * SUBI.L
000019A8                           714              * something unexpected
000019A8  6000 2EB8                715              BRA     OPERROR
000019AC                           716  
000019AC                           717  * SUBI.B ---------------------            
000019AC                           718  _SubIb      
000019AC  14FC 0053                719              MOVE.B  #'S',(A2)+
000019B0  14FC 0055                720              MOVE.B  #'U',(A2)+
000019B4  14FC 0042                721              MOVE.B  #'B',(A2)+
000019B8  14FC 0049                722              MOVE.B  #'I',(A2)+ 
000019BC  14FC 002E                723              MOVE.B  #'.',(A2)+ 
000019C0  14FC 0042                724              MOVE.B  #'B',(A2)+ 
000019C4  14FC 0020                725              MOVE.B  #' ',(A2)+ 
000019C8  14FC 0020                726              MOVE.B  #' ',(A2)+ 
000019CC  14FC 0020                727              MOVE.B  #' ',(A2)+ 
000019D0  14FC 0020                728              MOVE.B  #' ',(A2)+
000019D4  14FC 0023                729              MOVE.B  #'#',(A2)+
000019D8  14FC 0024                730              MOVE.B  #'$',(A2)+
000019DC  4EB8 15AE                731              JSR     printByte
000019E0  14FC 002C                732              MOVE.B  #',',(A2)+
000019E4  4EB8 163C                733              JSR     getMode
000019E8  BC3C 0001                734              CMP.B   #%001,D6    * compare with Ar
000019EC  6700 2E74                735              BEQ     OPERROR     * error
000019F0                           736              
000019F0  4DF9 000048D2            737              LEA     eaTable,A6
000019F6  CCFC 0008                738              MULU    #8,D6
000019FA  4EB6 6000                739              JSR     (A6,D6)
000019FE                           740              * check for error in EA
000019FE  0C07 0004                741              CMPI.B  #4,D7
00001A02  6700 2E5E                742              BEQ     OPERROR
00001A06                           743  
00001A06  4E75                     744              RTS 
00001A08                           745  * SUBI.W ---------------------
00001A08                           746  _SubIw      
00001A08  14FC 0053                747              MOVE.B  #'S',(A2)+
00001A0C  14FC 0055                748              MOVE.B  #'U',(A2)+
00001A10  14FC 0042                749              MOVE.B  #'B',(A2)+
00001A14  14FC 0049                750              MOVE.B  #'I',(A2)+ 
00001A18  14FC 002E                751              MOVE.B  #'.',(A2)+ 
00001A1C  14FC 0057                752              MOVE.B  #'W',(A2)+ 
00001A20  14FC 0020                753              MOVE.B  #' ',(A2)+ 
00001A24  14FC 0020                754              MOVE.B  #' ',(A2)+ 
00001A28  14FC 0020                755              MOVE.B  #' ',(A2)+ 
00001A2C  14FC 0020                756              MOVE.B  #' ',(A2)+
00001A30  14FC 0023                757              MOVE.B  #'#',(A2)+
00001A34  14FC 0024                758              MOVE.B  #'$',(A2)+
00001A38  4EB8 15DE                759              JSR     printWord
00001A3C  14FC 002C                760              MOVE.B  #',',(A2)+
00001A40  4EB8 163C                761              JSR     getMode
00001A44  BC3C 0001                762              CMP.B   #%001,D6    * compare with Ar
00001A48  6700 2E18                763              BEQ     OPERROR     * error
00001A4C                           764              
00001A4C  4DF9 000048D2            765              LEA     eaTable,A6
00001A52  CCFC 0008                766              MULU    #8,D6
00001A56  4EB6 6000                767              JSR     (A6,D6)
00001A5A                           768              * check for error in EA
00001A5A  0C07 0004                769              CMPI.B  #4,D7
00001A5E  6700 2E02                770              BEQ     OPERROR
00001A62                           771  
00001A62  4E75                     772              RTS 
00001A64                           773  
00001A64                           774  * SUBI.L ---------------------
00001A64                           775  _SubIl      
00001A64  14FC 0053                776              MOVE.B  #'S',(A2)+
00001A68  14FC 0055                777              MOVE.B  #'U',(A2)+
00001A6C  14FC 0042                778              MOVE.B  #'B',(A2)+
00001A70  14FC 0049                779              MOVE.B  #'I',(A2)+ 
00001A74  14FC 002E                780              MOVE.B  #'.',(A2)+ 
00001A78  14FC 004C                781              MOVE.B  #'L',(A2)+ 
00001A7C  14FC 0020                782              MOVE.B  #' ',(A2)+ 
00001A80  14FC 0020                783              MOVE.B  #' ',(A2)+ 
00001A84  14FC 0020                784              MOVE.B  #' ',(A2)+ 
00001A88  14FC 0020                785              MOVE.B  #' ',(A2)+
00001A8C  14FC 0023                786              MOVE.B  #'#',(A2)+
00001A90  14FC 0024                787              MOVE.B  #'$',(A2)+
00001A94  4EB8 160C                788              JSR     printLong
00001A98  14FC 002C                789              MOVE.B  #',',(A2)+
00001A9C  4EB8 163C                790              JSR     getMode
00001AA0  BC3C 0001                791              CMP.B   #%001,D6    * compare with Ar
00001AA4  6700 2DBC                792              BEQ     OPERROR     * error
00001AA8                           793              
00001AA8  4DF9 000048D2            794              LEA     eaTable,A6
00001AAE  CCFC 0008                795              MULU    #8,D6
00001AB2  4EB6 6000                796              JSR     (A6,D6)
00001AB6                           797              * check for error in EA
00001AB6  0C07 0004                798              CMPI.B  #4,D7
00001ABA  6700 2DA6                799              BEQ     OPERROR
00001ABE                           800  
00001ABE  4E75                     801              RTS 
00001AC0                           802  
00001AC0                           803  * ADDI ------------------------------------------------------------------------------
00001AC0  E98B                     804  _AddI       LSL.L   #4,D3
00001AC2  4EB8 1586                805              JSR     BitTst2
00001AC6  EB8B                     806              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
00001AC8  0C06 0000                807              CMPI.B  #%00,D6 * branch to appropriate size label
00001ACC  6700 0016                808              BEQ     _AddIb   * ADDI.B
00001AD0  0C06 0001                809              CMPI.B  #%01,D6
00001AD4  6700 006A                810              BEQ     _AddIw   * ADDI.W
00001AD8  0C06 0002                811              CMPI.B  #%10,D6
00001ADC  6700 00BE                812              BEQ     _AddIl   * ADDI.L
00001AE0                           813              * something unexpected
00001AE0  6000 2D80                814              BRA     OPERROR
00001AE4                           815              
00001AE4                           816  * ADDI.B ---------------------            
00001AE4                           817  _AddIb      
00001AE4  14FC 0041                818              MOVE.B  #'A',(A2)+
00001AE8  14FC 0044                819              MOVE.B  #'D',(A2)+
00001AEC  14FC 0044                820              MOVE.B  #'D',(A2)+
00001AF0  14FC 0049                821              MOVE.B  #'I',(A2)+ 
00001AF4  14FC 002E                822              MOVE.B  #'.',(A2)+ 
00001AF8  14FC 0042                823              MOVE.B  #'B',(A2)+ 
00001AFC  14FC 0020                824              MOVE.B  #' ',(A2)+ 
00001B00  14FC 0020                825              MOVE.B  #' ',(A2)+ 
00001B04  14FC 0020                826              MOVE.B  #' ',(A2)+ 
00001B08  14FC 0020                827              MOVE.B  #' ',(A2)+
00001B0C  14FC 0023                828              MOVE.B  #'#',(A2)+
00001B10  14FC 0024                829              MOVE.B  #'$',(A2)+
00001B14  4EB8 15AE                830              JSR     printByte
00001B18  14FC 002C                831              MOVE.B  #',',(A2)+
00001B1C  4EB8 163C                832              JSR     getMode
00001B20  BC3C 0001                833              CMP.B   #%001,D6    * compare with Ar
00001B24  6700 2D3C                834              BEQ     OPERROR     * error
00001B28                           835              
00001B28  4DF9 000048D2            836              LEA     eaTable,A6
00001B2E  CCFC 0008                837              MULU    #8,D6
00001B32  4EB6 6000                838              JSR     (A6,D6)
00001B36                           839              * check for error in EA
00001B36  0C07 0004                840              CMPI.B  #4,D7
00001B3A  6700 2D26                841              BEQ     OPERROR
00001B3E                           842  
00001B3E  4E75                     843              RTS 
00001B40                           844  
00001B40                           845  * ADDI.W ---------------------
00001B40                           846  _AddIw      
00001B40  14FC 0041                847              MOVE.B  #'A',(A2)+
00001B44  14FC 0044                848              MOVE.B  #'D',(A2)+
00001B48  14FC 0044                849              MOVE.B  #'D',(A2)+
00001B4C  14FC 0049                850              MOVE.B  #'I',(A2)+ 
00001B50  14FC 002E                851              MOVE.B  #'.',(A2)+ 
00001B54  14FC 0057                852              MOVE.B  #'W',(A2)+ 
00001B58  14FC 0020                853              MOVE.B  #' ',(A2)+ 
00001B5C  14FC 0020                854              MOVE.B  #' ',(A2)+ 
00001B60  14FC 0020                855              MOVE.B  #' ',(A2)+ 
00001B64  14FC 0020                856              MOVE.B  #' ',(A2)+
00001B68  14FC 0023                857              MOVE.B  #'#',(A2)+
00001B6C  14FC 0024                858              MOVE.B  #'$',(A2)+
00001B70  4EB8 15DE                859              JSR     printWord
00001B74  14FC 002C                860              MOVE.B  #',',(A2)+
00001B78  4EB8 163C                861              JSR     getMode
00001B7C  BC3C 0001                862              CMP.B   #%001,D6    * compare with Ar
00001B80  6700 2CE0                863              BEQ     OPERROR     * error
00001B84                           864              
00001B84  4DF9 000048D2            865              LEA     eaTable,A6
00001B8A  CCFC 0008                866              MULU    #8,D6
00001B8E  4EB6 6000                867              JSR     (A6,D6)
00001B92                           868              * check for error in EA
00001B92  0C07 0004                869              CMPI.B  #4,D7
00001B96  6700 2CCA                870              BEQ     OPERROR
00001B9A                           871  
00001B9A  4E75                     872              RTS 
00001B9C                           873  * ADDI.L ---------------------
00001B9C                           874  _AddIl      
00001B9C  14FC 0041                875              MOVE.B  #'A',(A2)+
00001BA0  14FC 0044                876              MOVE.B  #'D',(A2)+
00001BA4  14FC 0044                877              MOVE.B  #'D',(A2)+
00001BA8  14FC 0049                878              MOVE.B  #'I',(A2)+ 
00001BAC  14FC 002E                879              MOVE.B  #'.',(A2)+ 
00001BB0  14FC 004C                880              MOVE.B  #'L',(A2)+ 
00001BB4  14FC 0020                881              MOVE.B  #' ',(A2)+ 
00001BB8  14FC 0020                882              MOVE.B  #' ',(A2)+ 
00001BBC  14FC 0020                883              MOVE.B  #' ',(A2)+ 
00001BC0  14FC 0020                884              MOVE.B  #' ',(A2)+
00001BC4  14FC 0023                885              MOVE.B  #'#',(A2)+
00001BC8  14FC 0024                886              MOVE.B  #'$',(A2)+
00001BCC  4EB8 160C                887              JSR     printLong
00001BD0  14FC 002C                888              MOVE.B  #',',(A2)+
00001BD4  4EB8 163C                889              JSR     getMode
00001BD8  BC3C 0001                890              CMP.B   #%001,D6    * compare with Ar
00001BDC  6700 2C84                891              BEQ     OPERROR     * error
00001BE0                           892              
00001BE0  4DF9 000048D2            893              LEA     eaTable,A6
00001BE6  CCFC 0008                894              MULU    #8,D6
00001BEA  4EB6 6000                895              JSR     (A6,D6)
00001BEE                           896              * check for error in EA
00001BEE  0C07 0004                897              CMPI.B  #4,D7
00001BF2  6700 2C6E                898              BEQ     OPERROR
00001BF6                           899  
00001BF6  4E75                     900              RTS 
00001BF8                           901  
00001BF8                           902  * CMPI ------------------------------------------------------------------------------
00001BF8  E98B                     903  _CmpI       LSL.L   #4,D3
00001BFA  4EB8 1586                904              JSR     BitTst2
00001BFE  EB8B                     905              LSL.L   #5,D3   * shift 5 bits out for immediate destination data check
00001C00  0C06 0000                906              CMPI.B  #%00,D6 * branch to appropriate size label
00001C04  6700 0016                907              BEQ     _CmpIb   * CMPI.B
00001C08  0C06 0001                908              CMPI.B  #%01,D6
00001C0C  6700 006A                909              BEQ     _CmpIw   * CMPI.W
00001C10  0C06 0002                910              CMPI.B  #%10,D6
00001C14  6700 00BE                911              BEQ     _CmpIl   * CMPI.L
00001C18                           912              * something unexpected
00001C18  6000 2C48                913              BRA     OPERROR
00001C1C                           914              
00001C1C                           915  * CMPI.B --------------------            
00001C1C                           916  _CmpIb      
00001C1C  14FC 0043                917              MOVE.B  #'C',(A2)+
00001C20  14FC 004D                918              MOVE.B  #'M',(A2)+
00001C24  14FC 0050                919              MOVE.B  #'P',(A2)+
00001C28  14FC 0049                920              MOVE.B  #'I',(A2)+ 
00001C2C  14FC 002E                921              MOVE.B  #'.',(A2)+ 
00001C30  14FC 0042                922              MOVE.B  #'B',(A2)+ 
00001C34  14FC 0020                923              MOVE.B  #' ',(A2)+ 
00001C38  14FC 0020                924              MOVE.B  #' ',(A2)+ 
00001C3C  14FC 0020                925              MOVE.B  #' ',(A2)+ 
00001C40  14FC 0020                926              MOVE.B  #' ',(A2)+
00001C44  14FC 0023                927              MOVE.B  #'#',(A2)+
00001C48  14FC 0024                928              MOVE.B  #'$',(A2)+
00001C4C  4EB8 15AE                929              JSR     printByte
00001C50  14FC 002C                930              MOVE.B  #',',(A2)+
00001C54  4EB8 163C                931              JSR     getMode
00001C58  BC3C 0001                932              CMP.B   #%001,D6    * compare with Ar
00001C5C  6700 2C04                933              BEQ     OPERROR     * error
00001C60                           934              
00001C60  4DF9 000048D2            935              LEA     eaTable,A6
00001C66  CCFC 0008                936              MULU    #8,D6
00001C6A  4EB6 6000                937              JSR     (A6,D6)
00001C6E                           938              * check for error in EA
00001C6E  0C07 0004                939              CMPI.B  #4,D7
00001C72  6700 2BEE                940              BEQ     OPERROR
00001C76                           941  
00001C76  4E75                     942              RTS 
00001C78                           943  * CMPI.W ---------------------
00001C78                           944  _CmpIw      
00001C78  14FC 0043                945              MOVE.B  #'C',(A2)+
00001C7C  14FC 004D                946              MOVE.B  #'M',(A2)+
00001C80  14FC 0050                947              MOVE.B  #'P',(A2)+
00001C84  14FC 0049                948              MOVE.B  #'I',(A2)+ 
00001C88  14FC 002E                949              MOVE.B  #'.',(A2)+ 
00001C8C  14FC 0042                950              MOVE.B  #'B',(A2)+ 
00001C90  14FC 0020                951              MOVE.B  #' ',(A2)+ 
00001C94  14FC 0020                952              MOVE.B  #' ',(A2)+ 
00001C98  14FC 0020                953              MOVE.B  #' ',(A2)+ 
00001C9C  14FC 0020                954              MOVE.B  #' ',(A2)+
00001CA0  14FC 0023                955              MOVE.B  #'#',(A2)+
00001CA4  14FC 0024                956              MOVE.B  #'$',(A2)+
00001CA8  4EB8 15DE                957              JSR     printWord
00001CAC  14FC 002C                958              MOVE.B  #',',(A2)+
00001CB0  4EB8 163C                959              JSR     getMode
00001CB4  BC3C 0001                960              CMP.B   #%001,D6    * compare with Ar
00001CB8  6700 2BA8                961              BEQ     OPERROR     * error
00001CBC                           962              
00001CBC  4DF9 000048D2            963              LEA     eaTable,A6
00001CC2  CCFC 0008                964              MULU    #8,D6
00001CC6  4EB6 6000                965              JSR     (A6,D6)
00001CCA                           966              * check for error in EA
00001CCA  0C07 0004                967              CMPI.B  #4,D7
00001CCE  6700 2B92                968              BEQ     OPERROR
00001CD2                           969  
00001CD2  4E75                     970              RTS 
00001CD4                           971  * CMPI.L ---------------------
00001CD4                           972  _CmpIl      
00001CD4  14FC 0043                973              MOVE.B  #'C',(A2)+
00001CD8  14FC 004D                974              MOVE.B  #'M',(A2)+
00001CDC  14FC 0050                975              MOVE.B  #'P',(A2)+
00001CE0  14FC 0049                976              MOVE.B  #'I',(A2)+ 
00001CE4  14FC 002E                977              MOVE.B  #'.',(A2)+ 
00001CE8  14FC 0042                978              MOVE.B  #'B',(A2)+ 
00001CEC  14FC 0020                979              MOVE.B  #' ',(A2)+ 
00001CF0  14FC 0020                980              MOVE.B  #' ',(A2)+ 
00001CF4  14FC 0020                981              MOVE.B  #' ',(A2)+ 
00001CF8  14FC 0020                982              MOVE.B  #' ',(A2)+
00001CFC  14FC 0023                983              MOVE.B  #'#',(A2)+
00001D00  14FC 0024                984              MOVE.B  #'$',(A2)+
00001D04  4EB8 160C                985              JSR     printLong
00001D08  14FC 002C                986              MOVE.B  #',',(A2)+
00001D0C  4EB8 163C                987              JSR     getMode
00001D10  BC3C 0001                988              CMP.B   #%001,D6    * compare with Ar
00001D14  6700 2B4C                989              BEQ     OPERROR     * error
00001D18                           990              
00001D18  4DF9 000048D2            991              LEA     eaTable,A6
00001D1E  CCFC 0008                992              MULU    #8,D6
00001D22  4EB6 6000                993              JSR     (A6,D6)
00001D26                           994              * check for error in EA
00001D26  0C07 0004                995              CMPI.B  #4,D7
00001D2A  6700 2B36                996              BEQ     OPERROR
00001D2E                           997  
00001D2E  4E75                     998              RTS 
00001D30                           999              
00001D30                          1000              
00001D30                          1001              
00001D30                          1002  * MOVE.B -------------------------------------------------
00001D30                          1003  op0001          
00001D30                          1004     
00001D30  1E3C 0001               1005              MOVE.B  #1,D7       * move 1 into d7 to indicate byte
00001D34  264A                    1006              MOVEA.L A2,A3       * copy current address of A2 string to A3
00001D36                          1007              * store MOVE.B into the A2 string
00001D36  14FC 004D               1008              MOVE.B  #'M',(A2)+
00001D3A  14FC 004F               1009              MOVE.B  #'O',(A2)+
00001D3E  14FC 0056               1010              MOVE.B  #'V',(A2)+
00001D42  14FC 0045               1011              MOVE.B  #'E',(A2)+ 
00001D46  14FC 002E               1012              MOVE.B  #'.',(A2)+ 
00001D4A  14FC 0042               1013              MOVE.B  #'B',(A2)+ 
00001D4E  14FC 0020               1014              MOVE.B  #' ',(A2)+ 
00001D52  14FC 0020               1015              MOVE.B  #' ',(A2)+ 
00001D56  14FC 0020               1016              MOVE.B  #' ',(A2)+ 
00001D5A  14FC 0020               1017              MOVE.B  #' ',(A2)+
00001D5E                          1018              
00001D5E                          1019              * get EA for source
00001D5E  4EB8 163C               1020              JSR     getMode
00001D62  4DF9 000048D2           1021              LEA     eaTable,A6
00001D68  CCFC 0008               1022              MULU    #8,D6
00001D6C  4EB6 6000               1023              JSR     (A6,D6)
00001D70                          1024              * check for error in EA
00001D70  0C07 0004               1025              CMPI.B  #4,D7
00001D74  6700 2AEC               1026              BEQ     OPERROR
00001D78                          1027              
00001D78  14FC 002C               1028              MOVE.B  #',',(A2)+
00001D7C                          1029              
00001D7C                          1030              * look at destination
00001D7C  2604                    1031              MOVE.L  D4,D3   * reset D3
00001D7E  4843                    1032              SWAP    D3
00001D80  EF8B                    1033              LSL.L   #7,D3   * shift 7 leading bits out
00001D82  4EB8 1564               1034              JSR     BitTst3 * test destination mode
00001D86  0C06 0000               1035              CMPI.B  #%000,D6
00001D8A  6700 01EC               1036              BEQ     moveDn          * move to data register
00001D8E  0C06 0002               1037              CMPI.B  #%010,D6
00001D92  6700 0220               1038              BEQ     moveInd         * move to indirect address
00001D96  0C06 0003               1039              CMPI.B  #%011,D6
00001D9A  6700 023E               1040              BEQ     movePost        * move to indirect address with post increment
00001D9E  0C06 0004               1041              CMPI.B  #%100,D6
00001DA2  6700 0260               1042              BEQ     movePre         * move to indirect address with pre decrement
00001DA6  0C06 0007               1043              CMPI.B  #%111,D6
00001DAA  6700 0282               1044              BEQ     moveAbs         * move to absolute address
00001DAE                          1045  
00001DAE  6000 2AB2               1046              BRA     OPERROR 
00001DB2                          1047              
00001DB2  4E75                    1048              RTS
00001DB4                          1049  
00001DB4                          1050              
00001DB4                          1051  * MOVE.L/MOVEA.L ----------------------------------------
00001DB4                          1052  op0010   
00001DB4  4843                    1053              SWAP    D3          * swap D3 bits to top for bit checking subroutine
00001DB6  EF8B                    1054              LSL.L   #7,D3       * shift out op code and dest register
00001DB8  1E3C 0003               1055              MOVE.B  #3,D7       * move 3 into d7 to indicate long
00001DBC  4EB8 1564               1056              JSR     BitTst3     
00001DC0  0C06 0001               1057              CMPI.B  #%001,D6    * if dest mode is address reg, branch to MOVEA
00001DC4  6700 0082               1058              BEQ     _MoveAl     * go to MOVEA.L
00001DC8                          1059              
00001DC8  264A                    1060              MOVEA.L A2,A3       * copy current address of A2 string to A3
00001DCA                          1061              * store MOVE.B into the A2 string
00001DCA  14FC 004D               1062              MOVE.B  #'M',(A2)+
00001DCE  14FC 004F               1063              MOVE.B  #'O',(A2)+
00001DD2  14FC 0056               1064              MOVE.B  #'V',(A2)+
00001DD6  14FC 0045               1065              MOVE.B  #'E',(A2)+ 
00001DDA  14FC 002E               1066              MOVE.B  #'.',(A2)+ 
00001DDE  14FC 004C               1067              MOVE.B  #'L',(A2)+ 
00001DE2  14FC 0020               1068              MOVE.B  #' ',(A2)+ 
00001DE6  14FC 0020               1069              MOVE.B  #' ',(A2)+ 
00001DEA  14FC 0020               1070              MOVE.B  #' ',(A2)+ 
00001DEE  14FC 0020               1071              MOVE.B  #' ',(A2)+
00001DF2                          1072              
00001DF2                          1073              * get EA for source
00001DF2  4EB8 163C               1074              JSR     getMode
00001DF6  4DF9 000048D2           1075              LEA     eaTable,A6
00001DFC  CCFC 0008               1076              MULU    #8,D6
00001E00  4EB6 6000               1077              JSR     (A6,D6)
00001E04                          1078              * check for error in EA
00001E04  0C07 0004               1079              CMPI.B  #4,D7
00001E08  6700 2A58               1080              BEQ     OPERROR
00001E0C                          1081              
00001E0C  14FC 002C               1082              MOVE.B  #',',(A2)+
00001E10                          1083              * look at destination
00001E10  2604                    1084              MOVE.L  D4,D3   * reset D3
00001E12  4843                    1085              SWAP    D3
00001E14  EF8B                    1086              LSL.L   #7,D3   * shift 7 leading bits out
00001E16  4EB8 1564               1087              JSR     BitTst3 * test destination mode
00001E1A  0C06 0000               1088              CMPI.B  #%000,D6
00001E1E  6700 0158               1089              BEQ     moveDn          * move to data register
00001E22  0C06 0002               1090              CMPI.B  #%010,D6
00001E26  6700 018C               1091              BEQ     moveInd         * move to indirect address
00001E2A  0C06 0003               1092              CMPI.B  #%011,D6
00001E2E  6700 01AA               1093              BEQ     movePost        * move to indirect address with post increment
00001E32  0C06 0004               1094              CMPI.B  #%100,D6
00001E36  6700 01CC               1095              BEQ     movePre         * move to indirect address with pre decrement
00001E3A  0C06 0007               1096              CMPI.B  #%111,D6
00001E3E  6700 01EE               1097              BEQ     moveAbs         * move to absolute address
00001E42                          1098  
00001E42  6000 2A1E               1099              BRA     OPERROR 
00001E46                          1100              
00001E46  4E75                    1101              RTS
00001E48                          1102              
00001E48  264A                    1103  _MoveAl     MOVEA.L A2,A3       * copy current address of A2 string to A3
00001E4A                          1104              * store MOVE.B into the A2 string
00001E4A  14FC 004D               1105              MOVE.B  #'M',(A2)+
00001E4E  14FC 004F               1106              MOVE.B  #'O',(A2)+
00001E52  14FC 0056               1107              MOVE.B  #'V',(A2)+
00001E56  14FC 0045               1108              MOVE.B  #'E',(A2)+ 
00001E5A  14FC 0041               1109              MOVE.B  #'A',(A2)+ 
00001E5E  14FC 002E               1110              MOVE.B  #'.',(A2)+ 
00001E62  14FC 004C               1111              MOVE.B  #'L',(A2)+ 
00001E66  14FC 0020               1112              MOVE.B  #' ',(A2)+ 
00001E6A  14FC 0020               1113              MOVE.B  #' ',(A2)+ 
00001E6E  14FC 0020               1114              MOVE.B  #' ',(A2)+
00001E72                          1115              
00001E72                          1116  
00001E72                          1117              * get EA for source
00001E72  4EB8 163C               1118              JSR     getMode
00001E76  4DF9 000048D2           1119              LEA     eaTable,A6
00001E7C  CCFC 0008               1120              MULU    #8,D6
00001E80  4EB6 6000               1121              JSR     (A6,D6)
00001E84                          1122              * check for error in EA
00001E84  0C07 0004               1123              CMPI.B  #4,D7
00001E88  6700 29D8               1124              BEQ     OPERROR
00001E8C                          1125              
00001E8C  14FC 002C               1126              MOVE.B  #',',(A2)+
00001E90                          1127              * get destination register
00001E90  6000 0104               1128              BRA     moveAddr
00001E94                          1129              
00001E94  4E75                    1130              RTS
00001E96                          1131  
00001E96                          1132  * MOVE.W/MOVEA.W ----------------------------------------
00001E96                          1133  
00001E96                          1134  op0011
00001E96                          1135              
00001E96  4843                    1136              SWAP    D3
00001E98  EF8B                    1137              LSL.L   #7,D3       * shift out op code and dest register
00001E9A  1E3C 0002               1138              MOVE.B  #2,D7       * move 2 into d7 to indicate word
00001E9E  4EB8 1564               1139              JSR     BitTst3     
00001EA2  0C06 0001               1140              CMPI.B  #%001,D6    * if dest mode is address, branch to MOVEA
00001EA6  6700 0082               1141              BEQ     _MoveAw     * go to MOVEA.W
00001EAA  264A                    1142              MOVEA.L A2,A3       * copy current address of A2 string to A3
00001EAC                          1143              * store MOVE.B into the A2 string
00001EAC  14FC 004D               1144              MOVE.B  #'M',(A2)+
00001EB0  14FC 004F               1145              MOVE.B  #'O',(A2)+
00001EB4  14FC 0056               1146              MOVE.B  #'V',(A2)+
00001EB8  14FC 0045               1147              MOVE.B  #'E',(A2)+ 
00001EBC  14FC 002E               1148              MOVE.B  #'.',(A2)+ 
00001EC0  14FC 0057               1149              MOVE.B  #'W',(A2)+ 
00001EC4  14FC 0020               1150              MOVE.B  #' ',(A2)+ 
00001EC8  14FC 0020               1151              MOVE.B  #' ',(A2)+ 
00001ECC  14FC 0020               1152              MOVE.B  #' ',(A2)+ 
00001ED0  14FC 0020               1153              MOVE.B  #' ',(A2)+
00001ED4                          1154              
00001ED4                          1155              * get EA for source
00001ED4  4EB8 163C               1156              JSR     getMode
00001ED8  4DF9 000048D2           1157              LEA     eaTable,A6
00001EDE  CCFC 0008               1158              MULU    #8,D6
00001EE2  4EB6 6000               1159              JSR     (A6,D6)
00001EE6                          1160              * check for error in EA
00001EE6  0C07 0004               1161              CMPI.B  #4,D7
00001EEA  6700 2976               1162              BEQ     OPERROR
00001EEE                          1163              
00001EEE  14FC 002C               1164              MOVE.B  #',',(A2)+
00001EF2                          1165              * look at destination
00001EF2  2604                    1166              MOVE.L  D4,D3   * reset D3
00001EF4  4843                    1167              SWAP    D3
00001EF6  EF8B                    1168              LSL.L   #7,D3   * shift 7 leading bits out
00001EF8  4EB8 1564               1169              JSR     BitTst3 * test destination mode
00001EFC  0C06 0000               1170              CMPI.B  #%000,D6
00001F00  6700 0076               1171              BEQ     moveDn          * move to data register
00001F04  0C06 0002               1172              CMPI.B  #%010,D6
00001F08  6700 00AA               1173              BEQ     moveInd         * move to indirect address
00001F0C  0C06 0003               1174              CMPI.B  #%011,D6
00001F10  6700 00C8               1175              BEQ     movePost        * move to indirect address with post increment
00001F14  0C06 0004               1176              CMPI.B  #%100,D6
00001F18  6700 00EA               1177              BEQ     movePre         * move to indirect address with pre decrement
00001F1C  0C06 0007               1178              CMPI.B  #%111,D6
00001F20  6700 010C               1179              BEQ     moveAbs         * move to absolute address
00001F24                          1180  
00001F24  6000 293C               1181              BRA     OPERROR 
00001F28                          1182  
00001F28  4E75                    1183              RTS
00001F2A                          1184              
00001F2A  264A                    1185  _MoveAw     MOVEA.L A2,A3       * copy current address of A2 string to A3
00001F2C  14FC 004D               1186              MOVE.B  #'M',(A2)+
00001F30  14FC 004F               1187              MOVE.B  #'O',(A2)+
00001F34  14FC 0056               1188              MOVE.B  #'V',(A2)+
00001F38  14FC 0045               1189              MOVE.B  #'E',(A2)+ 
00001F3C  14FC 0041               1190              MOVE.B  #'A',(A2)+ 
00001F40  14FC 002E               1191              MOVE.B  #'.',(A2)+ 
00001F44  14FC 0057               1192              MOVE.B  #'W',(A2)+ 
00001F48  14FC 0020               1193              MOVE.B  #' ',(A2)+ 
00001F4C  14FC 0020               1194              MOVE.B  #' ',(A2)+ 
00001F50  14FC 0020               1195              MOVE.B  #' ',(A2)+
00001F54                          1196              
00001F54                          1197              * get EA for source
00001F54  4EB8 163C               1198              JSR     getMode
00001F58  4DF9 000048D2           1199              LEA     eaTable,A6
00001F5E  CCFC 0008               1200              MULU    #8,D6
00001F62  4EB6 6000               1201              JSR     (A6,D6)
00001F66                          1202              * check for error in EA
00001F66  0C07 0004               1203              CMPI.B  #4,D7
00001F6A  6700 28F6               1204              BEQ     OPERROR
00001F6E  14FC 002C               1205              MOVE.B  #',',(A2)+
00001F72  6000 0022               1206              BRA     moveAddr
00001F76                          1207  
00001F76  4E75                    1208              RTS
00001F78                          1209  
00001F78                          1210  *********************************************************************************
00001F78                          1211  * MOVE destination functions
00001F78                          1212  *********************************************************************************
00001F78                          1213  
00001F78                          1214  * Move to data register ----------------
00001F78                          1215  moveDn
00001F78  14FC 0044               1216              MOVE.B  #'D',(A2)+      * print D
00001F7C                          1217                  
00001F7C  2604                    1218              MOVE.L  D4,D3           * reset D3
00001F7E  4843                    1219              SWAP    D3              * swap to front
00001F80  E98B                    1220              LSL.L   #4,D3           * shift out opcode
00001F82  4EB8 1564               1221              JSR     BitTst3         * get register number
00001F86                          1222              
00001F86  4DF9 00004A72           1223              LEA     numTable,A6     * load num table
00001F8C  CCFC 0008               1224              MULU    #8,D6           * offset for table
00001F90  4EB6 6000               1225              JSR     (A6,D6)         * print the data
00001F94                          1226              
00001F94  4E75                    1227              RTS
00001F96                          1228              
00001F96                          1229  * Move to address register -------------
00001F96                          1230  moveAddr
00001F96  14FC 0041               1231              MOVE.B  #'A',(A2)+      * print A
00001F9A                          1232              
00001F9A  2604                    1233              MOVE.L  D4,D3           * reset D3
00001F9C  4843                    1234              SWAP    D3              * swap to front
00001F9E  E98B                    1235              LSL.L   #4,D3           * shift out opcode
00001FA0  4EB8 1564               1236              JSR     BitTst3         * get register number
00001FA4                          1237              
00001FA4  4DF9 00004A72           1238              LEA     numTable,A6     * load num table
00001FAA  CCFC 0008               1239              MULU    #8,D6           * offset for table
00001FAE  4EB6 6000               1240              JSR     (A6,D6)         * add data to A2 string
00001FB2                          1241              
00001FB2  4E75                    1242              RTS
00001FB4                          1243              
00001FB4                          1244  * Move to address register indirect ----
00001FB4                          1245  moveInd     
00001FB4  14FC 0028               1246              MOVE.B  #'(',(A2)+  * print (A
00001FB8  14FC 0041               1247              MOVE.B  #'A',(A2)+
00001FBC                          1248              
00001FBC  2604                    1249              MOVE.L  D4,D3       * reset D3
00001FBE  4843                    1250              SWAP    D3          * swap to front
00001FC0  E98B                    1251              LSL.L   #4,D3       * shift out opcode
00001FC2  4EB8 1564               1252              JSR     BitTst3     * get register number
00001FC6                          1253              
00001FC6  4DF9 00004A72           1254              LEA     numTable,A6 * load num table
00001FCC  CCFC 0008               1255              MULU    #8,D6       * offset for table
00001FD0  4EB6 6000               1256              JSR     (A6,D6)     * print data
00001FD4                          1257              
00001FD4  14FC 0029               1258              MOVE.B  #')',(A2)+  * finish with )
00001FD8                          1259              
00001FD8  4E75                    1260              RTS
00001FDA                          1261              
00001FDA                          1262  * Move to address post increment -------
00001FDA                          1263  movePost    
00001FDA  14FC 0028               1264              MOVE.B  #'(',(A2)+
00001FDE  14FC 0041               1265              MOVE.B  #'A',(A2)+
00001FE2                          1266              
00001FE2  2604                    1267              MOVE.L  D4,D3
00001FE4  4843                    1268              SWAP    D3
00001FE6  E98B                    1269              LSL.L   #4,D3
00001FE8  4EB8 1564               1270              JSR     BitTst3
00001FEC                          1271              
00001FEC  4DF9 00004A72           1272              LEA     numTable,A6
00001FF2  CCFC 0008               1273              MULU    #8,D6
00001FF6  4EB6 6000               1274              JSR     (A6,D6)
00001FFA                          1275              
00001FFA  14FC 0029               1276              MOVE.B  #')',(A2)+
00001FFE  14FC 002B               1277              MOVE.B  #'+',(A2)+
00002002                          1278              
00002002  4E75                    1279              RTS
00002004                          1280  
00002004                          1281  * Move to address pre decrement --------
00002004                          1282  movePre
00002004  14FC 002D               1283              MOVE.B  #'-',(A2)+
00002008  14FC 0028               1284              MOVE.B  #'(',(A2)+
0000200C  14FC 0041               1285              MOVE.B  #'A',(A2)+
00002010                          1286              
00002010  2604                    1287              MOVE.L  D4,D3
00002012  4843                    1288              SWAP    D3
00002014  E98B                    1289              LSL.L   #4,D3
00002016  4EB8 1564               1290              JSR     BitTst3
0000201A                          1291              
0000201A  4DF9 00004A72           1292              LEA     numTable,A6
00002020  CCFC 0008               1293              MULU    #8,D6
00002024  4EB6 6000               1294              JSR     (A6,D6)
00002028                          1295              
00002028  14FC 0029               1296              MOVE.B  #')',(A2)+
0000202C                          1297              
0000202C  4E75                    1298              RTS
0000202E                          1299  * Move to absolute address -------------
0000202E                          1300  moveAbs     
0000202E  14FC 0024               1301              MOVE.B  #'$',(A2)+  * add $ to A2 string
00002032  2604                    1302              MOVE.L  D4,D3
00002034  4843                    1303              SWAP    D3
00002036  E98B                    1304              LSL.L   #4,D3   * shift out opcode
00002038  4EB8 1564               1305              JSR     BitTst3 * check next three bits
0000203C                          1306              
0000203C  0C06 0000               1307              CMPI.B  #%000,D6
00002040  6700 F59C               1308              BEQ     printWord
00002044  0C06 0001               1309              CMPI.B  #%001,D6
00002048  6700 F5C2               1310              BEQ     printLong
0000204C                          1311  
0000204C  4EB9 00004862           1312              JSR     OPERROR       
00002052                          1313              
00002052                          1314   * MOVEM, LEA, CLR, JSR, RTS, NOP ------------------------------------------------------
00002052                          1315  op0100 
00002052  B67C 4EB9               1316              CMP.W   #$4EB9,D3   * compare to JSR code
00002056  6700 0048               1317              BEQ     jumpSR
0000205A  B67C 4E75               1318              CMP.W   #$4E75,D3   * compare to RTS code
0000205E  6700 00AA               1319              BEQ     returnSR
00002062  B67C 4E71               1320              CMP.W   #$4E71,D3   * compare to NOP code
00002066  6700 00B0               1321              BEQ     noOp
0000206A  4843                    1322              SWAP    D3          * swap D3 to check for bits
0000206C  EF8B                    1323              LSL.L   #7,D3       * shift 7 bits out to check for lea/movem instruction
0000206E                          1324              *LEA has the form |opcode|An|111|...
0000206E  4EB8 1564               1325              JSR     BitTst3
00002072  BC3C 0007               1326              CMP.B   #%111,D6    * if the next 3 bits match 111,
00002076  6700 00AE               1327              BEQ     _lea        * branch to lea
0000207A                          1328              
0000207A  2604                    1329              MOVE.L  D4,D3   * reset D3
0000207C  4843                    1330              SWAP    D3
0000207E  E98B                    1331              LSL.L   #4,D3   * shift out op code
00002080  4EB8 1538               1332              JSR     BITTEST
00002084                          1333              *MOVEM has form |opcode|1D0|01S|.. where S = size
00002084  BC3C 0008               1334              CMP.B   #%1000,D6    * if next 4 bits match 1000, it is a MOVEM
00002088  6700 013E               1335              BEQ     _MoveM
0000208C  BC3C 000C               1336              CMP.B   #%1100,D6    * if next 4 bits match 1100, it is a MOVEM
00002090  6700 0136               1337              BEQ     _MoveM
00002094                          1338              
00002094  BC3C 0002               1339              CMP.B   #%0010,D6 * if 0010, it is a clear instruction,
00002098  6700 0680               1340              BEQ     _clr      * since lea/movem/jsr/rts have been handled
0000209C                          1341              
0000209C  6000 27C4               1342              BRA     OPERROR
000020A0                          1343              * if it isnt any of these == error/not supported           
000020A0                          1344  
000020A0                          1345  * JSR ------------------------------------------------------------------------------
000020A0                          1346  jumpSR
000020A0  264A                    1347              MOVEA.L A2,A3       * copy current address of A2 string to A3
000020A2  1E3C 0003               1348              MOVE.B  #3,D7       * indicate long word instruction
000020A6  14FC 004A               1349              MOVE.B  #'J',(A2)+
000020AA  14FC 0053               1350              MOVE.B  #'S',(A2)+
000020AE  14FC 0052               1351              MOVE.B  #'R',(A2)+
000020B2  14FC 0020               1352              MOVE.B  #' ',(A2)+
000020B6  14FC 0020               1353              MOVE.B  #' ',(A2)+
000020BA  14FC 0020               1354              MOVE.B  #' ',(A2)+
000020BE  14FC 0020               1355              MOVE.B  #' ',(A2)+
000020C2  14FC 0020               1356              MOVE.B  #' ',(A2)+
000020C6  14FC 0020               1357              MOVE.B  #' ',(A2)+
000020CA  14FC 0020               1358              MOVE.B  #' ',(A2)+
000020CE                          1359              
000020CE  4EB8 163C               1360              JSR     getMode
000020D2  0C06 0006               1361              CMPI.B  #%110,D6    * addressing with index which isnt supported
000020D6  6700 278A               1362              BEQ     OPERROR
000020DA                          1363              
000020DA  E74E                    1364              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000020DC  1A06                    1365              MOVE.B  D6,D5       * hold destination mode bits in d5
000020DE  E78B                    1366              LSL.L   #3,D3       * shift destination mode bits out
000020E0  4EB8 1564               1367              JSR     BitTst3     * test the destination register bits
000020E4  DA46                    1368              ADD.W   D6,D5       * add these to the mode bits
000020E6  0C05 003C               1369              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000020EA  6700 2776               1370              BEQ     OPERROR     * immediate data, there is not allowed for dest, error
000020EE                          1371              
000020EE                          1372              * no errors
000020EE  4EB8 163C               1373              JSR     getMode
000020F2  4DF9 000048D2           1374              LEA     eaTable,A6
000020F8  CCFC 0008               1375              MULU    #8,D6
000020FC  4EB6 6000               1376              JSR     (A6,D6)
00002100                          1377              * check for error in EA
00002100  0C07 0004               1378              CMPI.B  #4,D7
00002104  6700 275C               1379              BEQ     OPERROR
00002108                          1380              
00002108  4E75                    1381              RTS
0000210A                          1382  
0000210A                          1383  * RTS ------------------------------------------------------------------------------            
0000210A  14FC 0052               1384  returnSR    MOVE.B  #'R',(A2)+
0000210E  14FC 0054               1385              MOVE.B  #'T',(A2)+
00002112  14FC 0053               1386              MOVE.B  #'S',(A2)+
00002116  4E75                    1387              RTS
00002118                          1388              
00002118                          1389  * NOP ------------------------------------------------------------------------------
00002118  14FC 004E               1390  noOp        MOVE.B  #'N',(A2)+
0000211C  14FC 004F               1391              MOVE.B  #'O',(A2)+
00002120  14FC 0050               1392              MOVE.B  #'P',(A2)+
00002124  4E75                    1393              RTS            
00002126                          1394              
00002126                          1395  * LEA ------------------------------------------------------------------------------
00002126                          1396  _lea
00002126  264A                    1397              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002128  1E3C 0003               1398              MOVE.B  #3,D7       * indicate longword instruction
0000212C  14FC 004C               1399              MOVE.B  #'L',(A2)+
00002130  14FC 0045               1400              MOVE.B  #'E',(A2)+
00002134  14FC 0041               1401              MOVE.B  #'A',(A2)+
00002138  14FC 0020               1402              MOVE.B  #' ',(A2)+
0000213C  14FC 0020               1403              MOVE.B  #' ',(A2)+
00002140  14FC 0020               1404              MOVE.B  #' ',(A2)+
00002144  14FC 0020               1405              MOVE.B  #' ',(A2)+
00002148  14FC 0020               1406              MOVE.B  #' ',(A2)+
0000214C  14FC 0020               1407              MOVE.B  #' ',(A2)+
00002150  14FC 0020               1408              MOVE.B  #' ',(A2)+
00002154                          1409              *get EA mode
00002154  4EB8 163C               1410              JSR     getMode
00002158                          1411              * modes not allowed: Dn, An, (An)+, -(An), #<data>
00002158  0C06 0000               1412              CMPI.B  #%000,D6
0000215C  6700 2704               1413              BEQ     OPERROR     * Dn
00002160  0C06 0001               1414              CMPI.B  #%001,D6
00002164  6700 26FC               1415              BEQ     OPERROR     * An
00002168  0C06 0003               1416              CMPI.B  #%011,D6
0000216C  6700 26F4               1417              BEQ     OPERROR     * (An)+
00002170  0C06 0004               1418              CMPI.B  #%100,D6
00002174  6700 26EC               1419              BEQ     OPERROR     * -(An)
00002178                          1420              
00002178  E74E                    1421              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000217A  1A06                    1422              MOVE.B  D6,D5       * hold destination mode bits in d5
0000217C  E78B                    1423              LSL.L   #3,D3       * shift destination mode bits out
0000217E  4EB8 1564               1424              JSR     BitTst3     * test the destination register bits
00002182  DA46                    1425              ADD.W   D6,D5       * add these to the mode bits
00002184  0C05 003C               1426              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002188  6700 26D8               1427              BEQ     OPERROR     * immediate data, there is not allowed for dest, error
0000218C                          1428              
0000218C                          1429              * no errors
0000218C  4EB8 163C               1430              JSR     getMode
00002190  4DF9 000048D2           1431              LEA     eaTable,A6
00002196  CCFC 0008               1432              MULU    #8,D6
0000219A  4EB6 6000               1433              JSR     (A6,D6)
0000219E                          1434              * check for error in EA
0000219E  0C07 0004               1435              CMPI.B  #4,D7
000021A2  6700 26BE               1436              BEQ     OPERROR
000021A6                          1437              
000021A6  14FC 002C               1438              MOVE.B  #',',(A2)+
000021AA  14FC 0041               1439              MOVE.B  #'A',(A2)+
000021AE  2604                    1440              MOVE.L  D4,D3       * reset D3
000021B0  4843                    1441              SWAP    D3          * set D3 to front
000021B2  E98B                    1442              LSL.L   #4,D3       * shift out opcode
000021B4  4EB8 1564               1443              JSR     BitTst3     * check 3 bits for register number
000021B8                          1444              
000021B8  CCFC 0008               1445              MULU    #8,D6       * offset
000021BC  4DF9 00004A72           1446              LEA     numTable,A6 * load num table
000021C2  4EB6 6000               1447              JSR     (A6,D6)     * get the number from table and print
000021C6                          1448                         
000021C6  4E75                    1449              RTS
000021C8                          1450  * MOVEM ------------------------------------------------------------------------------
000021C8                          1451  _MoveM     
000021C8  4EB8 1564               1452              JSR     BitTst3     * check bits 9-11 for mode of MOVEM
000021CC  2604                    1453              MOVE.L  D4,D3       * reset D3
000021CE  0C06 0004               1454              CMPI.B  #%100,D6    * 100 indicates reg to mem
000021D2  6700 000A               1455              BEQ     _MoveMDn
000021D6  0C06 0006               1456              CMPI.B  #%110,D6    * 110 indicates mem to reg
000021DA  6700 00C6               1457              BEQ     _MoveMAn
000021DE                          1458  
000021DE                          1459  _MoveMDn
000021DE                          1460              * test the size bit of MOVEM
000021DE  0803 0006               1461              BTST.L  #$06,D3
000021E2  6600 0060               1462              BNE     _MoveMDnL  * default to word size
000021E6                          1463  * MOVEM.W --------------------
000021E6  14FC 004D               1464              MOVE.B  #'M',(A2)+
000021EA  14FC 004F               1465              MOVE.B  #'O',(A2)+
000021EE  14FC 0056               1466              MOVE.B  #'V',(A2)+
000021F2  14FC 0045               1467              MOVE.B  #'E',(A2)+
000021F6  14FC 004D               1468              MOVE.B  #'M',(A2)+
000021FA  14FC 002E               1469              MOVE.B  #'.',(A2)+
000021FE  14FC 0057               1470              MOVE.B  #'W',(A2)+
00002202  14FC 0020               1471              MOVE.B  #' ',(A2)+
00002206  14FC 0020               1472              MOVE.B  #' ',(A2)+
0000220A  14FC 0020               1473              MOVE.B  #' ',(A2)+
0000220E                          1474              
0000220E  4EB9 0000253E           1475              JSR     PreDec  * print register list
00002214                          1476                         
00002214  14FC 002C               1477              MOVE.B  #',',(A2)+
00002218                          1478              
00002218  4EB8 163C               1479              JSR     getMode
0000221C  0C06 0001               1480              CMPI.B  #%001,D6
00002220  6F00 2640               1481              BLE     OPERROR     * Dn and An illegal
00002224  0C06 0003               1482              CMPI.B  #%011,D6
00002228  6700 2638               1483              BEQ     OPERROR     * (An)+ illegal with this mode
0000222C                          1484              
0000222C  4DF9 000048D2           1485              LEA     eaTable,A6
00002232  CCFC 0008               1486              MULU    #8,D6
00002236  4EB6 6000               1487              JSR     (A6,D6)
0000223A                          1488              * check for error in EA
0000223A  0C07 0004               1489              CMPI.B  #4,D7
0000223E  6700 2622               1490              BEQ     OPERROR
00002242                          1491           
00002242  4E75                    1492              RTS
00002244                          1493  
00002244                          1494  * MOVEM.L --------------------
00002244                          1495  _MoveMDnL   * it is long type
00002244  14FC 004D               1496              MOVE.B  #'M',(A2)+
00002248  14FC 004F               1497              MOVE.B  #'O',(A2)+
0000224C  14FC 0056               1498              MOVE.B  #'V',(A2)+
00002250  14FC 0045               1499              MOVE.B  #'E',(A2)+
00002254  14FC 004D               1500              MOVE.B  #'M',(A2)+
00002258  14FC 002E               1501              MOVE.B  #'.',(A2)+
0000225C  14FC 004C               1502              MOVE.B  #'L',(A2)+
00002260  14FC 0020               1503              MOVE.B  #' ',(A2)+
00002264  14FC 0020               1504              MOVE.B  #' ',(A2)+
00002268  14FC 0020               1505              MOVE.B  #' ',(A2)+
0000226C                          1506             
0000226C  4EB9 0000253E           1507              JSR     PreDec   * print register list 
00002272                          1508              
00002272  14FC 002C               1509              MOVE.B  #',',(A2)+
00002276                          1510              
00002276  4EB8 163C               1511              JSR     getMode
0000227A  0C06 0001               1512              CMPI.B  #%001,D6
0000227E  6F00 25E2               1513              BLE     OPERROR     * Dn and An illegal
00002282  0C06 0003               1514              CMPI.B  #%011,D6
00002286  6700 25DA               1515              BEQ     OPERROR     * (An)+ illegal with this mode
0000228A  4DF9 000048D2           1516              LEA     eaTable,A6
00002290  CCFC 0008               1517              MULU    #8,D6
00002294  4EB6 6000               1518              JSR     (A6,D6)
00002298                          1519              * check for error in EA
00002298  0C07 0004               1520              CMPI.B  #4,D7
0000229C  6700 25C4               1521              BEQ     OPERROR        
000022A0  4E75                    1522              RTS 
000022A2                          1523  
000022A2                          1524  _MoveMAn    * test the size bit of MOVEM
000022A2  0803 0006               1525              BTST.L  #$06,D3
000022A6  6600 0060               1526              BNE     _MoveMAnL
000022AA                          1527              * default to word size
000022AA                          1528  * MOVEM.W --------------------
000022AA  14FC 004D               1529              MOVE.B  #'M',(A2)+
000022AE  14FC 004F               1530              MOVE.B  #'O',(A2)+
000022B2  14FC 0056               1531              MOVE.B  #'V',(A2)+
000022B6  14FC 0045               1532              MOVE.B  #'E',(A2)+
000022BA  14FC 004D               1533              MOVE.B  #'M',(A2)+
000022BE  14FC 002E               1534              MOVE.B  #'.',(A2)+
000022C2  14FC 0057               1535              MOVE.B  #'W',(A2)+
000022C6  14FC 0020               1536              MOVE.B  #' ',(A2)+
000022CA  14FC 0020               1537              MOVE.B  #' ',(A2)+
000022CE  14FC 0020               1538              MOVE.B  #' ',(A2)+
000022D2                          1539              
000022D2  4EB9 00002366           1540              JSR     PostInc     * print list
000022D8                          1541              
000022D8  14FC 002C               1542              MOVE.B  #',',(A2)+
000022DC                          1543              
000022DC  4EB8 163C               1544              JSR     getMode
000022E0  0C06 0001               1545              CMPI.B  #%001,D6
000022E4  6F00 257C               1546              BLE     OPERROR     * Dn and An illegal
000022E8  0C06 0004               1547              CMPI.B  #%100,D6
000022EC  6700 2574               1548              BEQ     OPERROR     * -(An) illegal with this mode
000022F0                          1549              
000022F0  4DF9 000048D2           1550              LEA     eaTable,A6
000022F6  CCFC 0008               1551              MULU    #8,D6
000022FA  4EB6 6000               1552              JSR     (A6,D6)
000022FE                          1553              * check for error in EA
000022FE  0C07 0004               1554              CMPI.B  #4,D7
00002302  6700 255E               1555              BEQ     OPERROR
00002306                          1556              
00002306  4E75                    1557              RTS
00002308                          1558              
00002308                          1559  * MOVEM.L --------------------            
00002308                          1560  _MoveMAnL   
00002308  14FC 004D               1561              MOVE.B  #'M',(A2)+
0000230C  14FC 004F               1562              MOVE.B  #'O',(A2)+
00002310  14FC 0056               1563              MOVE.B  #'V',(A2)+
00002314  14FC 0045               1564              MOVE.B  #'E',(A2)+
00002318  14FC 004D               1565              MOVE.B  #'M',(A2)+
0000231C  14FC 002E               1566              MOVE.B  #'.',(A2)+
00002320  14FC 004C               1567              MOVE.B  #'L',(A2)+
00002324  14FC 0020               1568              MOVE.B  #' ',(A2)+
00002328  14FC 0020               1569              MOVE.B  #' ',(A2)+
0000232C  14FC 0020               1570              MOVE.B  #' ',(A2)+
00002330                          1571              
00002330  4EB9 00002366           1572              JSR     PostInc   * print list
00002336                          1573              
00002336  14FC 002C               1574              MOVE.B  #',',(A2)+
0000233A  4EB8 163C               1575              JSR     getMode
0000233E  0C06 0001               1576              CMPI.B  #%001,D6
00002342  6F00 251E               1577              BLE     OPERROR     * Dn and An illegal
00002346  0C06 0004               1578              CMPI.B  #%100,D6
0000234A  6700 2516               1579              BEQ     OPERROR     * -(An) illegal with this mode
0000234E                          1580              
0000234E  4DF9 000048D2           1581              LEA     eaTable,A6
00002354  CCFC 0008               1582              MULU    #8,D6
00002358  4EB6 6000               1583              JSR     (A6,D6)
0000235C                          1584              * check for error in EA
0000235C  0C07 0004               1585              CMPI.B  #4,D7
00002360  6700 2500               1586              BEQ     OPERROR
00002364                          1587              
00002364  4E75                    1588              RTS
00002366                          1589              
00002366                          1590  PostInc
00002366  3614                    1591              MOVE.W  (A4),D3     * move the next word into D3
00002368                          1592              
00002368  0803 0000               1593              BTST.L  #$00,D3     * D0
0000236C  6600 007C               1594              BNE     _d0
00002370                          1595              
00002370  0803 0001               1596  Pi_d1       BTST.L  #$01,D3     * D1
00002374  6600 0084               1597              BNE     _d1
00002378  0803 0002               1598  Pi_d2       BTST.L  #$02,D3     * D2
0000237C  6600 0092               1599              BNE     _d2
00002380  0803 0003               1600  Pi_d3       BTST.L  #$03,D3     * D3
00002384  6600 00A0               1601              BNE     _d3
00002388  0803 0004               1602  Pi_d4       BTST.L  #$04,D3     * D4
0000238C  6600 00AE               1603              BNE     _d4
00002390  0803 0005               1604  Pi_d5       BTST.L  #$05,D3     * D5
00002394  6600 00BC               1605              BNE     _d5
00002398  0803 0006               1606  Pi_d6       BTST.L  #$06,D3     * D6
0000239C  6600 00CA               1607              BNE     _d6
000023A0  0803 0007               1608  Pi_d7       BTST.L  #$07,D3     * D7
000023A4  6600 00D8               1609              BNE     _d7
000023A8  0803 0008               1610  Pi_a0       BTST.L  #$08,D3     * A0
000023AC  6600 00E6               1611              BNE     _a0
000023B0  0803 0009               1612  Pi_a1       BTST.L  #$09,D3     * A1
000023B4  6600 00F4               1613              BNE     _a1
000023B8  0803 000A               1614  Pi_a2       BTST.L  #$0A,D3     * A2
000023BC  6600 0102               1615              BNE     _a2
000023C0  0803 000B               1616  Pi_a3       BTST.L  #$0B,D3     * A3
000023C4  6600 0110               1617              BNE     _a3
000023C8  0803 000C               1618  Pi_a4       BTST.L  #$0C,D3     * A4
000023CC  6600 011E               1619              BNE     _a4
000023D0  0803 000D               1620  Pi_a5       BTST.L  #$0D,D3     * A5
000023D4  6600 012C               1621              BNE     _a5
000023D8  0803 000E               1622  Pi_a6       BTST.L  #$0E,D3     * A6
000023DC  6600 013A               1623              BNE     _a6
000023E0  0803 000F               1624  Pi_a7       BTST.L  #$0F,D3     * A7
000023E4  6600 0148               1625              BNE     _a7
000023E8                          1626  
000023E8  4E75                    1627              RTS
000023EA                          1628              
000023EA  14FC 0044               1629  _d0         MOVE.B  #'D',(A2)+
000023EE  14FC 0030               1630              MOVE.B  #'0',(A2)+
000023F2  103C 0001               1631              MOVE.B  #1,D0        * move flag for first register
000023F6  6000 FF78               1632              BRA     Pi_d1
000023FA                          1633  
000023FA  4EB9 0000270C           1634  _d1         JSR     printSlash
00002400  14FC 0044               1635              MOVE.B  #'D',(A2)+
00002404  14FC 0031               1636              MOVE.B  #'1',(A2)+
00002408  103C 0001               1637              MOVE.B  #1,D0        * move flag for first register
0000240C  6000 FF6A               1638              BRA     Pi_d2
00002410                          1639  
00002410  4EB9 0000270C           1640  _d2         JSR     printSlash
00002416  14FC 0044               1641              MOVE.B  #'D',(A2)+
0000241A  14FC 0032               1642              MOVE.B  #'2',(A2)+
0000241E  103C 0001               1643              MOVE.B  #1,D0        * move flag for first register
00002422  6000 FF5C               1644              BRA     Pi_d3
00002426                          1645  
00002426  4EB9 0000270C           1646  _d3         JSR     printSlash
0000242C  14FC 0044               1647              MOVE.B  #'D',(A2)+
00002430  14FC 0033               1648              MOVE.B  #'3',(A2)+
00002434  103C 0001               1649              MOVE.B  #1,D0        * move flag for first register
00002438  6000 FF4E               1650              BRA     Pi_d4
0000243C                          1651  
0000243C  4EB9 0000270C           1652  _d4         JSR     printSlash
00002442  14FC 0044               1653              MOVE.B  #'D',(A2)+
00002446  14FC 0034               1654              MOVE.B  #'4',(A2)+
0000244A  103C 0001               1655              MOVE.B  #1,D0        * move flag for first register
0000244E  6000 FF40               1656              BRA     Pi_d5
00002452                          1657  
00002452  4EB9 0000270C           1658  _d5         JSR     printSlash
00002458  14FC 0044               1659              MOVE.B  #'D',(A2)+
0000245C  14FC 0035               1660              MOVE.B  #'5',(A2)+
00002460  103C 0001               1661              MOVE.B  #1,D0        * move flag for first register
00002464  6000 FF32               1662              BRA     Pi_d6
00002468                          1663  
00002468  4EB9 0000270C           1664  _d6         JSR     printSlash
0000246E  14FC 0044               1665              MOVE.B  #'D',(A2)+
00002472  14FC 0036               1666              MOVE.B  #'6',(A2)+
00002476  103C 0001               1667              MOVE.B  #1,D0        * move flag for first register
0000247A  6000 FF24               1668              BRA     Pi_d7
0000247E                          1669  
0000247E  4EB9 0000270C           1670  _d7         JSR     printSlash
00002484  14FC 0044               1671              MOVE.B  #'D',(A2)+
00002488  14FC 0037               1672              MOVE.B  #'7',(A2)+
0000248C  103C 0001               1673              MOVE.B  #1,D0        * move flag for first register
00002490  6000 FF16               1674              BRA     Pi_a0
00002494                          1675  
00002494  4EB9 0000270C           1676  _a0         JSR     printSlash
0000249A  14FC 0041               1677              MOVE.B  #'A',(A2)+
0000249E  14FC 0030               1678              MOVE.B  #'0',(A2)+
000024A2  103C 0001               1679              MOVE.B  #1,D0        * move flag for first register
000024A6  6000 FF08               1680              BRA     Pi_a1
000024AA                          1681  
000024AA  4EB9 0000270C           1682  _a1         JSR     printSlash
000024B0  14FC 0041               1683              MOVE.B  #'A',(A2)+
000024B4  14FC 0031               1684              MOVE.B  #'1',(A2)+
000024B8  103C 0001               1685              MOVE.B  #1,D0        * move flag for first register
000024BC  6000 FEFA               1686              BRA     Pi_a2
000024C0                          1687  
000024C0  4EB9 0000270C           1688  _a2         JSR     printSlash
000024C6  14FC 0041               1689              MOVE.B  #'A',(A2)+
000024CA  14FC 0032               1690              MOVE.B  #'2',(A2)+
000024CE  103C 0001               1691              MOVE.B  #1,D0        * move flag for first register
000024D2  6000 FEEC               1692              BRA     Pi_a3
000024D6                          1693  
000024D6  4EB9 0000270C           1694  _a3         JSR     printSlash
000024DC  14FC 0041               1695              MOVE.B  #'A',(A2)+
000024E0  14FC 0033               1696              MOVE.B  #'3',(A2)+
000024E4  103C 0001               1697              MOVE.B  #1,D0        * move flag for first register
000024E8  6000 FEDE               1698              BRA     Pi_a4
000024EC                          1699  
000024EC  4EB9 0000270C           1700  _a4         JSR     printSlash
000024F2  14FC 0041               1701              MOVE.B  #'A',(A2)+
000024F6  14FC 0034               1702              MOVE.B  #'4',(A2)+
000024FA  103C 0001               1703              MOVE.B  #1,D0        * move flag for first register
000024FE  6000 FED0               1704              BRA     Pi_a5
00002502                          1705  
00002502  4EB9 0000270C           1706  _a5         JSR     printSlash
00002508  14FC 0041               1707              MOVE.B  #'A',(A2)+
0000250C  14FC 0035               1708              MOVE.B  #'5',(A2)+
00002510  103C 0001               1709              MOVE.B  #1,D0        * move flag for first register
00002514  6000 FEC2               1710              BRA     Pi_a6
00002518                          1711  
00002518  4EB9 0000270C           1712  _a6         JSR     printSlash
0000251E  14FC 0041               1713              MOVE.B  #'A',(A2)+
00002522  14FC 0036               1714              MOVE.B  #'6',(A2)+
00002526  103C 0001               1715              MOVE.B  #1,D0        * move flag for first register
0000252A  6000 FEB4               1716              BRA     Pi_a7
0000252E                          1717  
0000252E  4EB9 0000270C           1718  _a7         JSR     printSlash
00002534  14FC 0041               1719              MOVE.B  #'A',(A2)+
00002538  14FC 0037               1720              MOVE.B  #'7',(A2)+
0000253C  4E75                    1721              RTS
0000253E                          1722              
0000253E                          1723              
0000253E                          1724  PreDec
0000253E  3614                    1725              MOVE.W  (A4),D3     * move the next word into D3
00002540                          1726              
00002540  0803 0000               1727              BTST.L  #$00,D3     * A0
00002544  6600 0118               1728              BNE     _PDa0
00002548                          1729              
00002548  0803 0001               1730  Pd_a1       BTST.L  #$01,D3     * A1
0000254C  6600 0126               1731              BNE     _PDa1
00002550  0803 0002               1732  Pd_a2       BTST.L  #$02,D3     * A2
00002554  6600 0134               1733              BNE     _PDa2
00002558  0803 0003               1734  Pd_a3       BTST.L  #$03,D3     * A3
0000255C  6600 0142               1735              BNE     _PDa3
00002560  0803 0004               1736  Pd_a4       BTST.L  #$04,D3     * A4
00002564  6600 0150               1737              BNE     _PDa4
00002568  0803 0005               1738  Pd_a5       BTST.L  #$05,D3     * A5
0000256C  6600 015E               1739              BNE     _PDa5
00002570  0803 0006               1740  Pd_a6       BTST.L  #$06,D3     * A6
00002574  6600 016C               1741              BNE     _PDa6
00002578  0803 0007               1742  Pd_a7       BTST.L  #$07,D3     * A7
0000257C  6600 017A               1743              BNE     _PDa7
00002580  0803 0008               1744  Pd_d0       BTST.L  #$08,D3     * D0
00002584  6600 003C               1745              BNE     _PDd0
00002588  0803 0009               1746  Pd_d1       BTST.L  #$09,D3     * D1
0000258C  6600 0042               1747              BNE     _PDd1
00002590  0803 000A               1748  Pd_d2       BTST.L  #$0A,D3     * D2
00002594  6600 004E               1749              BNE     _PDd2
00002598  0803 000B               1750  Pd_d3       BTST.L  #$0B,D3     * D3
0000259C  6600 005A               1751              BNE     _PDd3
000025A0  0803 000C               1752  Pd_d4       BTST.L  #$0C,D3     * D4
000025A4  6600 0066               1753              BNE     _PDd4
000025A8  0803 000D               1754  Pd_d5       BTST.L  #$0D,D3     * D5
000025AC  6600 0072               1755              BNE     _PDd5
000025B0  0803 000E               1756  Pd_d6       BTST.L  #$0E,D3     * D6
000025B4  6600 0080               1757              BNE     _PDd6
000025B8  0803 000F               1758  Pd_d7       BTST.L  #$0F,D3     * D7
000025BC  6600 008E               1759              BNE     _PDd7
000025C0                          1760  
000025C0  4E75                    1761              RTS
000025C2                          1762              
000025C2                          1763              
000025C2  14FC 0044               1764  _PDd0         MOVE.B  #'D',(A2)+
000025C6  14FC 0030               1765              MOVE.B  #'0',(A2)+
000025CA  103C 0001               1766              MOVE.B  #1,D0        * move flag for first register
000025CE  60B8                    1767              BRA     Pd_d1
000025D0                          1768  
000025D0  4EB9 0000270C           1769  _PDd1         JSR     printSlash
000025D6  14FC 0044               1770              MOVE.B  #'D',(A2)+
000025DA  14FC 0031               1771              MOVE.B  #'1',(A2)+
000025DE  103C 0001               1772              MOVE.B  #1,D0        * move flag for first register
000025E2  60AC                    1773              BRA     Pd_d2
000025E4                          1774  
000025E4  4EB9 0000270C           1775  _PDd2         JSR     printSlash
000025EA  14FC 0044               1776              MOVE.B  #'D',(A2)+
000025EE  14FC 0032               1777              MOVE.B  #'2',(A2)+
000025F2  103C 0001               1778              MOVE.B  #1,D0        * move flag for first register
000025F6  60A0                    1779              BRA     Pd_d3
000025F8                          1780  
000025F8  4EB9 0000270C           1781  _PDd3         JSR     printSlash
000025FE  14FC 0044               1782              MOVE.B  #'D',(A2)+
00002602  14FC 0033               1783              MOVE.B  #'3',(A2)+
00002606  103C 0001               1784              MOVE.B  #1,D0        * move flag for first register
0000260A  6094                    1785              BRA     Pd_d4
0000260C                          1786  
0000260C  4EB9 0000270C           1787  _PDd4         JSR     printSlash
00002612  14FC 0044               1788              MOVE.B  #'D',(A2)+
00002616  14FC 0034               1789              MOVE.B  #'4',(A2)+
0000261A  103C 0001               1790              MOVE.B  #1,D0        * move flag for first register
0000261E  6088                    1791              BRA     Pd_d5
00002620                          1792  
00002620  4EB9 0000270C           1793  _PDd5         JSR     printSlash
00002626  14FC 0044               1794              MOVE.B  #'D',(A2)+
0000262A  14FC 0035               1795              MOVE.B  #'5',(A2)+
0000262E  103C 0001               1796              MOVE.B  #1,D0        * move flag for first register
00002632  6000 FF7C               1797              BRA     Pd_d6
00002636                          1798  
00002636  4EB9 0000270C           1799  _PDd6         JSR     printSlash
0000263C  14FC 0044               1800              MOVE.B  #'D',(A2)+
00002640  14FC 0036               1801              MOVE.B  #'6',(A2)+
00002644  103C 0001               1802              MOVE.B  #1,D0        * move flag for first register
00002648  6000 FF6E               1803              BRA     Pd_d7
0000264C                          1804  
0000264C  4EB9 0000270C           1805  _PDd7         JSR     printSlash
00002652  14FC 0044               1806              MOVE.B  #'D',(A2)+
00002656  14FC 0037               1807              MOVE.B  #'7',(A2)+
0000265A  103C 0001               1808              MOVE.B  #1,D0        * move flag for first register
0000265E                          1809              
0000265E                          1810  
0000265E  4EB9 0000270C           1811  _PDa0         JSR     printSlash
00002664  14FC 0041               1812              MOVE.B  #'A',(A2)+
00002668  14FC 0030               1813              MOVE.B  #'0',(A2)+
0000266C  103C 0001               1814              MOVE.B  #1,D0        * move flag for first register
00002670  6000 FED6               1815              BRA     Pd_a1
00002674                          1816  
00002674  4EB9 0000270C           1817  _PDa1         JSR     printSlash
0000267A  14FC 0041               1818              MOVE.B  #'A',(A2)+
0000267E  14FC 0031               1819              MOVE.B  #'1',(A2)+
00002682  103C 0001               1820              MOVE.B  #1,D0        * move flag for first register
00002686  6000 FEC8               1821              BRA     Pd_a2
0000268A                          1822  
0000268A  4EB9 0000270C           1823  _PDa2         JSR     printSlash
00002690  14FC 0041               1824              MOVE.B  #'A',(A2)+
00002694  14FC 0032               1825              MOVE.B  #'2',(A2)+
00002698  103C 0001               1826              MOVE.B  #1,D0        * move flag for first register
0000269C  6000 FEBA               1827              BRA     Pd_a3
000026A0                          1828  
000026A0  4EB9 0000270C           1829  _PDa3         JSR     printSlash
000026A6  14FC 0041               1830              MOVE.B  #'A',(A2)+
000026AA  14FC 0033               1831              MOVE.B  #'3',(A2)+
000026AE  103C 0001               1832              MOVE.B  #1,D0        * move flag for first register
000026B2  6000 FEAC               1833              BRA     Pd_a4
000026B6                          1834  
000026B6  4EB9 0000270C           1835  _PDa4         JSR     printSlash
000026BC  14FC 0041               1836              MOVE.B  #'A',(A2)+
000026C0  14FC 0034               1837              MOVE.B  #'4',(A2)+
000026C4  103C 0001               1838              MOVE.B  #1,D0        * move flag for first register
000026C8  6000 FE9E               1839              BRA     Pd_a5
000026CC                          1840  
000026CC  4EB9 0000270C           1841  _PDa5         JSR     printSlash
000026D2  14FC 0041               1842              MOVE.B  #'A',(A2)+
000026D6  14FC 0035               1843              MOVE.B  #'5',(A2)+
000026DA  103C 0001               1844              MOVE.B  #1,D0        * move flag for first register
000026DE  6000 FE90               1845              BRA     Pd_a6
000026E2                          1846  
000026E2  4EB9 0000270C           1847  _PDa6         JSR     printSlash
000026E8  14FC 0041               1848              MOVE.B  #'A',(A2)+
000026EC  14FC 0036               1849              MOVE.B  #'6',(A2)+
000026F0  103C 0001               1850              MOVE.B  #1,D0        * move flag for first register
000026F4  6000 FE82               1851              BRA     Pd_a7
000026F8                          1852  
000026F8  4EB9 0000270C           1853  _PDa7         JSR     printSlash
000026FE  14FC 0041               1854              MOVE.B  #'A',(A2)+
00002702  14FC 0037               1855              MOVE.B  #'7',(A2)+
00002706  6000 FEB0               1856              BRA     Pd_d7
0000270A  4E75                    1857              RTS
0000270C                          1858  
0000270C                          1859         
0000270C                          1860  printSlash
0000270C  0C00 0001               1861              CMPI.B  #1,D0       * see if a register has been added to the list
00002710  6600 0006               1862              BNE     prtSlashDn    * if not, do not add slash
00002714  14FC 002F               1863              MOVE.B  #'/',(A2)+      * else add slash
00002718  4E75                    1864  prtSlashDn  RTS
0000271A                          1865              
0000271A                          1866              
0000271A                          1867              
0000271A                          1868                                                 
0000271A                          1869  
0000271A                          1870  * CLR ------------------------------------------------------------------------------
0000271A  E98B                    1871  _clr        LSL.L   #4,D3   * shift out 4 bits to isolate size bit on the front
0000271C  4EB8 1586               1872              JSR     BitTst2
00002720  E58B                    1873              LSL.L   #2,D3   * shift out 2 size bits for error checking
00002722  0C06 0000               1874              CMPI.B  #%00,D6
00002726  6700 0012               1875              BEQ     _clrB   * CLR.B
0000272A  0C06 0001               1876              CMPI.B  #%01,D6
0000272E  6700 0074               1877              BEQ     _clrW   * CLR.W
00002732  0C06 0002               1878              CMPI.B  #%10,D6
00002736  6700 00D6               1879              BEQ     _clrL   * CLR.L
0000273A                          1880              
0000273A                          1881  * CLR.B ----------------------
0000273A                          1882  _clrB       
0000273A  1E3C 0001               1883              MOVE.B  #1,D7       * indicate a byte instruction
0000273E  264A                    1884              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002740  14FC 0043               1885              MOVE.B  #'C',(A2)+
00002744  14FC 004C               1886              MOVE.B  #'L',(A2)+
00002748  14FC 0052               1887              MOVE.B  #'R',(A2)+
0000274C  14FC 002E               1888              MOVE.B  #'.',(A2)+
00002750  14FC 0042               1889              MOVE.B  #'B',(A2)+
00002754  14FC 0020               1890              MOVE.B  #' ',(A2)+
00002758  14FC 0020               1891              MOVE.B  #' ',(A2)+
0000275C  14FC 0020               1892              MOVE.B  #' ',(A2)+
00002760  14FC 0020               1893              MOVE.B  #' ',(A2)+
00002764  14FC 0020               1894              MOVE.B  #' ',(A2)+
00002768                          1895              
00002768                          1896              * get EA 
00002768  4EB8 163C               1897              JSR     getMode
0000276C  0C06 0001               1898              CMPI.B  #%001,D6    * cant clear address registers
00002770  6700 20F0               1899              BEQ     OPERROR     * branch to error
00002774                          1900              
00002774  E74E                    1901              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002776  1A06                    1902              MOVE.B  D6,D5       * hold destination mode bits in d5
00002778  E78B                    1903              LSL.L   #3,D3       * shift destination mode bits out
0000277A  4EB8 1564               1904              JSR     BitTst3     * test the destination register bits
0000277E  DA46                    1905              ADD.W   D6,D5       * add these to the mode bits
00002780  0C05 003C               1906              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002784  6700 20DC               1907              BEQ     OPERROR     * immediate data, there is not allowed, error
00002788                          1908              
00002788                          1909              * no errors so get the mode again and load the EA table
00002788  4EB8 163C               1910              JSR     getMode
0000278C  4DF9 000048D2           1911              LEA     eaTable,A6
00002792  CCFC 0008               1912              MULU    #8,D6
00002796  4EB6 6000               1913              JSR     (A6,D6)
0000279A                          1914              * check for error in EA
0000279A  0C07 0004               1915              CMPI.B  #4,D7
0000279E  6700 20C2               1916              BEQ     OPERROR
000027A2  4E75                    1917              RTS
000027A4                          1918              
000027A4                          1919  * CLR.W ----------------------            
000027A4                          1920  _clrW       
000027A4  1E3C 0002               1921              MOVE.B  #2,D7       * indicate a word instruction
000027A8  264A                    1922              MOVEA.L A2,A3       * copy current address of A2 string to A3
000027AA  14FC 0043               1923              MOVE.B  #'C',(A2)+
000027AE  14FC 004C               1924              MOVE.B  #'L',(A2)+
000027B2  14FC 0052               1925              MOVE.B  #'R',(A2)+
000027B6  14FC 002E               1926              MOVE.B  #'.',(A2)+
000027BA  14FC 0057               1927              MOVE.B  #'W',(A2)+
000027BE  14FC 0020               1928              MOVE.B  #' ',(A2)+
000027C2  14FC 0020               1929              MOVE.B  #' ',(A2)+
000027C6  14FC 0020               1930              MOVE.B  #' ',(A2)+
000027CA  14FC 0020               1931              MOVE.B  #' ',(A2)+
000027CE  14FC 0020               1932              MOVE.B  #' ',(A2)+
000027D2                          1933              * get EA 
000027D2  4EB8 163C               1934              JSR     getMode
000027D6  0C06 0001               1935              CMPI.B  #%001,D6    * cant clear address registers
000027DA  6700 2086               1936              BEQ     OPERROR     * branch to error
000027DE                          1937              
000027DE  E74E                    1938              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000027E0  1A06                    1939              MOVE.B  D6,D5       * hold destination mode bits in d5
000027E2  E78B                    1940              LSL.L   #3,D3       * shift destination mode bits out
000027E4  4EB8 1564               1941              JSR     BitTst3     * test the destination register bits
000027E8  DA46                    1942              ADD.W   D6,D5       * add these to the mode bits
000027EA  0C05 003C               1943              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000027EE  6700 2072               1944              BEQ     OPERROR     * immediate data, there is not allowed, error
000027F2                          1945              
000027F2  4EB8 163C               1946              JSR     getMode
000027F6  4DF9 000048D2           1947              LEA     eaTable,A6
000027FC  CCFC 0008               1948              MULU    #8,D6
00002800  4EB6 6000               1949              JSR     (A6,D6)
00002804                          1950              * check for error in EA
00002804  0C07 0004               1951              CMPI.B  #4,D7
00002808  6700 2058               1952              BEQ     OPERROR
0000280C  4E75                    1953              RTS
0000280E                          1954              
0000280E                          1955  * CLR.L ----------------------            
0000280E                          1956  _clrL      
0000280E  1E3C 0003               1957              MOVE.B  #3,D7       * indicate a long instruction
00002812  264A                    1958              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002814  14FC 0043               1959              MOVE.B  #'C',(A2)+
00002818  14FC 004C               1960              MOVE.B  #'L',(A2)+
0000281C  14FC 0052               1961              MOVE.B  #'R',(A2)+
00002820  14FC 002E               1962              MOVE.B  #'.',(A2)+
00002824  14FC 004C               1963              MOVE.B  #'L',(A2)+
00002828  14FC 0020               1964              MOVE.B  #' ',(A2)+
0000282C  14FC 0020               1965              MOVE.B  #' ',(A2)+
00002830  14FC 0020               1966              MOVE.B  #' ',(A2)+
00002834  14FC 0020               1967              MOVE.B  #' ',(A2)+
00002838  14FC 0020               1968              MOVE.B  #' ',(A2)+
0000283C                          1969              * get EA 
0000283C  4EB8 163C               1970              JSR     getMode
00002840  0C06 0001               1971              CMPI.B  #%001,D6    * cant clear address registers
00002844  6700 201C               1972              BEQ     OPERROR     * branch to error
00002848                          1973              
00002848  E74E                    1974              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000284A  1A06                    1975              MOVE.B  D6,D5       * hold destination mode bits in d5
0000284C  E78B                    1976              LSL.L   #3,D3       * shift destination mode bits out
0000284E  4EB8 1564               1977              JSR     BitTst3     * test the destination register bits
00002852  DA46                    1978              ADD.W   D6,D5       * add these to the mode bits
00002854  0C05 003C               1979              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002858  6700 2008               1980              BEQ     OPERROR     * immediate data, there is not allowed, error
0000285C                          1981              
0000285C                          1982              * no errors so get the mode again and load the EA table
0000285C  4EB8 163C               1983              JSR     getMode
00002860  4DF9 000048D2           1984              LEA     eaTable,A6
00002866  CCFC 0008               1985              MULU    #8,D6
0000286A  4EB6 6000               1986              JSR     (A6,D6)
0000286E                          1987              * check for error in EA
0000286E  0C07 0004               1988              CMPI.B  #4,D7
00002872  6700 1FEE               1989              BEQ     OPERROR
00002876                          1990              
00002876  4E75                    1991              RTS
00002878                          1992  
00002878                          1993  * ADDQ, SUBQ --------------------------------------------------------------------
00002878                          1994  op0101      
00002878  0803 0008               1995              BTST.L  #$08,D3 * test the 8th bit to check for ADDQ or SUBQ
0000287C  6600 01CA               1996              BNE   _SubQ   * if 8th bit == 1, it is SUBQ instruction
00002880                          1997              * else proceed as if it is an ADDQ instruction
00002880  4843                    1998              SWAP    D3
00002882  E18B                    1999              LSL.L   #8,D3   * shift out opcode & data to check for size
00002884  4EB8 1586               2000              JSR     BitTst2
00002888  2604                    2001              MOVE.L  D4,D3   * reset D3
0000288A  4843                    2002              SWAP    D3      * send bits to front
0000288C  E98B                    2003              LSL.L   #4,D3   * shift out opcode
0000288E  0C06 0000               2004              CMPI.B  #%00,D6  * go to ADDQ.B
00002892  6700 0016               2005              BEQ     _AddQb
00002896  0C06 0001               2006              CMPI.B  #%01,D6  * go to ADDQ.W
0000289A  6700 0098               2007              BEQ     _AddQw
0000289E  0C06 0002               2008              CMPI.B  #%10,D6  * go to ADDQ.L
000028A2  6700 011A               2009              BEQ     _AddQl
000028A6                          2010              
000028A6                          2011              * something unexpected/unsupported
000028A6  6000 1FBA               2012              BRA     OPERROR
000028AA                          2013              
000028AA                          2014  _AddQb      
000028AA  1E3C 0001               2015              MOVE.B  #1,D7       * indicate a byte instruction
000028AE  264A                    2016              MOVEA.L A2,A3       * copy current address of A2 string to A3
000028B0  14FC 0041               2017              MOVE.B  #'A',(A2)+
000028B4  14FC 0044               2018              MOVE.B  #'D',(A2)+
000028B8  14FC 0044               2019              MOVE.B  #'D',(A2)+
000028BC  14FC 0051               2020              MOVE.B  #'Q',(A2)+
000028C0  14FC 002E               2021              MOVE.B  #'.',(A2)+
000028C4  14FC 0042               2022              MOVE.B  #'B',(A2)+
000028C8  14FC 0020               2023              MOVE.B  #' ',(A2)+
000028CC  14FC 0020               2024              MOVE.B  #' ',(A2)+
000028D0  14FC 0020               2025              MOVE.B  #' ',(A2)+
000028D4  14FC 0020               2026              MOVE.B  #' ',(A2)+
000028D8  14FC 0023               2027              MOVE.B  #'#',(A2)+
000028DC                          2028              
000028DC  4EB8 1564               2029              JSR     BitTst3     * get the data value
000028E0  0C06 0000               2030              CMPI.B  #%000,D6    * if it is 000, add 8
000028E4  6600 0008               2031              BNE     AddQb       * if not, continue to next part
000028E8  4EB9 00002C10           2032              JSR     Add8
000028EE  CCFC 0008               2033  AddQb       MULU    #8,D6       * multiply for offset
000028F2  4DF9 00004A72           2034              LEA     numTable,A6 * load num table
000028F8  4EB6 6000               2035              JSR     (A6,D6)     * jump to table
000028FC                          2036                  
000028FC  14FC 002C               2037              MOVE.B  #',',(A2)+  * print comma
00002900                          2038              
00002900  4EB8 163C               2039              JSR     getMode     * get EA mode
00002904                          2040              
00002904  E74E                    2041              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002906  1A06                    2042              MOVE.B  D6,D5       * hold destination mode bits in d5
00002908  E78B                    2043              LSL.L   #3,D3       * shift destination mode bits out
0000290A  4EB8 1564               2044              JSR     BitTst3     * test the destination register bits
0000290E  DA46                    2045              ADD.W   D6,D5       * add these to the mode bits
00002910  0C05 003C               2046              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002914  6700 1F4C               2047              BEQ     OPERROR     * immediate data, there is not allowed, error
00002918                          2048  
00002918  4EB8 163C               2049              JSR     getMode
0000291C  CCFC 0008               2050              MULU    #8,D6       * multiply for offset
00002920  4DF9 000048D2           2051              LEA     eaTable,A6  * load e table
00002926  4EB6 6000               2052              JSR     (A6,D6)     * jump to table
0000292A                          2053              * check for error in EA
0000292A  0C07 0004               2054              CMPI.B  #4,D7
0000292E  6700 1F32               2055              BEQ     OPERROR
00002932                          2056              
00002932  4E75                    2057              RTS
00002934                          2058  
00002934                          2059  _AddQw      
00002934  1E3C 0002               2060              MOVE.B  #2,D7       * indicate a word instruction
00002938  264A                    2061              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000293A  14FC 0041               2062              MOVE.B  #'A',(A2)+
0000293E  14FC 0044               2063              MOVE.B  #'D',(A2)+
00002942  14FC 0044               2064              MOVE.B  #'D',(A2)+
00002946  14FC 0051               2065              MOVE.B  #'Q',(A2)+
0000294A  14FC 002E               2066              MOVE.B  #'.',(A2)+
0000294E  14FC 0057               2067              MOVE.B  #'W',(A2)+
00002952  14FC 0020               2068              MOVE.B  #' ',(A2)+
00002956  14FC 0020               2069              MOVE.B  #' ',(A2)+
0000295A  14FC 0020               2070              MOVE.B  #' ',(A2)+
0000295E  14FC 0020               2071              MOVE.B  #' ',(A2)+
00002962  14FC 0023               2072              MOVE.B  #'#',(A2)+
00002966                          2073              
00002966  4EB8 1564               2074              JSR     BitTst3     * get the data value
0000296A  0C06 0000               2075              CMPI.B  #%000,D6    * if it is 000, add 8
0000296E  6600 0008               2076              BNE     AddQw       * if not, continue to next part
00002972  4EB9 00002C10           2077              JSR     Add8
00002978  CCFC 0008               2078  AddQw       MULU    #8,D6       * multiply for offset
0000297C  4DF9 00004A72           2079              LEA     numTable,A6 * load num table
00002982  4EB6 6000               2080              JSR     (A6,D6)     * jump to table
00002986                          2081                  
00002986  14FC 002C               2082              MOVE.B  #',',(A2)+  * print comma
0000298A                          2083              
0000298A  4EB8 163C               2084              JSR     getMode     * get EA mode
0000298E  E74E                    2085              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002990  1A06                    2086              MOVE.B  D6,D5       * hold destination mode bits in d5
00002992  E78B                    2087              LSL.L   #3,D3       * shift destination mode bits out
00002994  4EB8 1564               2088              JSR     BitTst3     * test the destination register bits
00002998  DA46                    2089              ADD.W   D6,D5       * add these to the mode bits
0000299A  0C05 003C               2090              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000299E  6700 1EC2               2091              BEQ     OPERROR     * immediate data, there is not allowed, error
000029A2                          2092              
000029A2  4EB8 163C               2093              JSR     getMode
000029A6  CCFC 0008               2094              MULU    #8,D6       * multiply for offset
000029AA  4DF9 000048D2           2095              LEA     eaTable,A6  * load e table
000029B0  4EB6 6000               2096              JSR     (A6,D6)     * jump to table
000029B4                          2097              * check for error in EA
000029B4  0C07 0004               2098              CMPI.B  #4,D7
000029B8  6700 1EA8               2099              BEQ     OPERROR
000029BC  4E75                    2100              RTS
000029BE                          2101              
000029BE                          2102  _AddQl      
000029BE  1E3C 0003               2103              MOVE.B  #3,D7       * indicate a long instruction
000029C2  264A                    2104              MOVEA.L A2,A3       * copy current address of A2 string to A3
000029C4  14FC 0041               2105              MOVE.B  #'A',(A2)+
000029C8  14FC 0044               2106              MOVE.B  #'D',(A2)+
000029CC  14FC 0044               2107              MOVE.B  #'D',(A2)+
000029D0  14FC 0051               2108              MOVE.B  #'Q',(A2)+
000029D4  14FC 002E               2109              MOVE.B  #'.',(A2)+
000029D8  14FC 004C               2110              MOVE.B  #'L',(A2)+
000029DC  14FC 0020               2111              MOVE.B  #' ',(A2)+
000029E0  14FC 0020               2112              MOVE.B  #' ',(A2)+
000029E4  14FC 0020               2113              MOVE.B  #' ',(A2)+
000029E8  14FC 0020               2114              MOVE.B  #' ',(A2)+
000029EC  14FC 0023               2115              MOVE.B  #'#',(A2)+
000029F0                          2116              
000029F0  4EB8 1564               2117              JSR     BitTst3     * get the data value
000029F4  0C06 0000               2118              CMPI.B  #%000,D6    * if it is 000, add 8
000029F8  6600 0008               2119              BNE     AddQl       * if not, continue to next part
000029FC  4EB9 00002C10           2120              JSR     Add8
00002A02  CCFC 0008               2121  AddQl       MULU    #8,D6       * multiply for offset
00002A06  4DF9 00004A72           2122              LEA     numTable,A6 * load num table
00002A0C  4EB6 6000               2123              JSR     (A6,D6)     * jump to table
00002A10                          2124                  
00002A10  14FC 002C               2125              MOVE.B  #',',(A2)+  * print comma
00002A14                          2126              
00002A14  4EB8 163C               2127              JSR     getMode     * get EA mode
00002A18                          2128              
00002A18  E74E                    2129              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002A1A  1A06                    2130              MOVE.B  D6,D5       * hold destination mode bits in d5
00002A1C  E78B                    2131              LSL.L   #3,D3       * shift destination mode bits out
00002A1E  4EB8 1564               2132              JSR     BitTst3     * test the destination register bits
00002A22  DA46                    2133              ADD.W   D6,D5       * add these to the mode bits
00002A24  0C05 003C               2134              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002A28  6700 1E38               2135              BEQ     OPERROR     * immediate data, there is not allowed, error
00002A2C                          2136              
00002A2C  4EB8 163C               2137              JSR     getMode
00002A30  CCFC 0008               2138              MULU    #8,D6       * multiply for offset
00002A34  4DF9 000048D2           2139              LEA     eaTable,A6  * load e table
00002A3A  4EB6 6000               2140              JSR     (A6,D6)     * jump to table
00002A3E                          2141              * check for error in EA
00002A3E  0C07 0004               2142              CMPI.B  #4,D7
00002A42  6700 1E1E               2143              BEQ     OPERROR
00002A46                          2144              
00002A46  4E75                    2145              RTS
00002A48                          2146              
00002A48                          2147  * SUBQ ------------------------------------------------------------------------------            
00002A48                          2148  _SubQ       
00002A48  4843                    2149              SWAP    D3
00002A4A  E18B                    2150              LSL.L   #8,D3   * shift out opcode & data to check for size
00002A4C  4EB8 1586               2151              JSR     BitTst2
00002A50  2604                    2152              MOVE.L  D4,D3   * reset D3
00002A52  4843                    2153              SWAP    D3
00002A54  E98B                    2154              LSL.L   #4,D3   * shift out opcode
00002A56  0C06 0000               2155              CMPI.B  #%00,D6  * go to SUBQ.B
00002A5A  6700 0016               2156              BEQ     _SubQb
00002A5E  0C06 0001               2157              CMPI.B  #%01,D6  * go to SUBQ.W
00002A62  6700 0098               2158              BEQ     _SubQw
00002A66  0C06 0002               2159              CMPI.B  #%10,D6  * go to SUBQ.L
00002A6A  6700 011A               2160              BEQ     _SubQl
00002A6E                          2161              
00002A6E                          2162              * something unexpected/unsupported
00002A6E  6000 1DF2               2163              BRA     OPERROR
00002A72                          2164              
00002A72                          2165  _SubQb      
00002A72  1E3C 0001               2166              MOVE.B  #1,D7       * indicate a byte instruction
00002A76  264A                    2167              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002A78  14FC 0053               2168              MOVE.B  #'S',(A2)+
00002A7C  14FC 0055               2169              MOVE.B  #'U',(A2)+
00002A80  14FC 0042               2170              MOVE.B  #'B',(A2)+
00002A84  14FC 0051               2171              MOVE.B  #'Q',(A2)+
00002A88  14FC 002E               2172              MOVE.B  #'.',(A2)+
00002A8C  14FC 0042               2173              MOVE.B  #'B',(A2)+
00002A90  14FC 0020               2174              MOVE.B  #' ',(A2)+
00002A94  14FC 0020               2175              MOVE.B  #' ',(A2)+
00002A98  14FC 0020               2176              MOVE.B  #' ',(A2)+
00002A9C  14FC 0020               2177              MOVE.B  #' ',(A2)+
00002AA0  14FC 0023               2178              MOVE.B  #'#',(A2)+
00002AA4                          2179              
00002AA4  4EB8 1564               2180              JSR     BitTst3     * get the data value
00002AA8  0C06 0000               2181              CMPI.B  #%000,D6    * if it is 000, add 8
00002AAC  6600 0008               2182              BNE     SubQb       * if not, continue to next part
00002AB0  4EB9 00002C10           2183              JSR     Add8
00002AB6  CCFC 0008               2184  SubQb       MULU    #8,D6       * multiply for offset
00002ABA  4DF9 00004A72           2185              LEA     numTable,A6 * load num table
00002AC0  4EB6 6000               2186              JSR     (A6,D6)     * jump to table
00002AC4                          2187                  
00002AC4  14FC 002C               2188              MOVE.B  #',',(A2)+  * print comma
00002AC8                          2189              
00002AC8  4EB8 163C               2190              JSR     getMode     * get EA mode
00002ACC  E74E                    2191              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002ACE  1A06                    2192              MOVE.B  D6,D5       * hold destination mode bits in d5
00002AD0  E78B                    2193              LSL.L   #3,D3       * shift destination mode bits out
00002AD2  4EB8 1564               2194              JSR     BitTst3     * test the destination register bits
00002AD6  DA46                    2195              ADD.W   D6,D5       * add these to the mode bits
00002AD8  0C05 003C               2196              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002ADC  6700 1D84               2197              BEQ     OPERROR     * immediate data, there is not allowed, error
00002AE0                          2198              
00002AE0  4EB8 163C               2199              JSR     getMode
00002AE4  CCFC 0008               2200              MULU    #8,D6       * multiply for offset
00002AE8  4DF9 000048D2           2201              LEA     eaTable,A6  * load e table
00002AEE  4EB6 6000               2202              JSR     (A6,D6)     * jump to table
00002AF2                          2203              * check for error in EA
00002AF2  0C07 0004               2204              CMPI.B  #4,D7
00002AF6  6700 1D6A               2205              BEQ     OPERROR
00002AFA  4E75                    2206              RTS
00002AFC                          2207  
00002AFC                          2208  _SubQw       
00002AFC  1E3C 0002               2209              MOVE.B  #2,D7       * indicate a word instruction
00002B00  264A                    2210              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002B02  14FC 0053               2211              MOVE.B  #'S',(A2)+
00002B06  14FC 0055               2212              MOVE.B  #'U',(A2)+
00002B0A  14FC 0042               2213              MOVE.B  #'B',(A2)+
00002B0E  14FC 0051               2214              MOVE.B  #'Q',(A2)+
00002B12  14FC 002E               2215              MOVE.B  #'.',(A2)+
00002B16  14FC 0057               2216              MOVE.B  #'W',(A2)+
00002B1A  14FC 0020               2217              MOVE.B  #' ',(A2)+
00002B1E  14FC 0020               2218              MOVE.B  #' ',(A2)+
00002B22  14FC 0020               2219              MOVE.B  #' ',(A2)+
00002B26  14FC 0020               2220              MOVE.B  #' ',(A2)+
00002B2A  14FC 0023               2221              MOVE.B  #'#',(A2)+
00002B2E  4EB8 1564               2222              JSR     BitTst3     * get the data value
00002B32  0C06 0000               2223              CMPI.B  #%000,D6    * if it is 000, add 8
00002B36  6600 0008               2224              BNE     SubQw       * if not, continue to next part
00002B3A  4EB9 00002C10           2225              JSR     Add8
00002B40  CCFC 0008               2226  SubQw       MULU    #8,D6       * multiply for offset
00002B44  4DF9 00004A72           2227              LEA     numTable,A6 * load num table
00002B4A  4EB6 6000               2228              JSR     (A6,D6)     * jump to table
00002B4E                          2229                  
00002B4E  14FC 002C               2230              MOVE.B  #',',(A2)+  * print comma
00002B52                          2231              
00002B52  4EB8 163C               2232              JSR     getMode     * get EA mode
00002B56  E74E                    2233              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002B58  1A06                    2234              MOVE.B  D6,D5       * hold destination mode bits in d5
00002B5A  E78B                    2235              LSL.L   #3,D3       * shift destination mode bits out
00002B5C  4EB8 1564               2236              JSR     BitTst3     * test the destination register bits
00002B60  DA46                    2237              ADD.W   D6,D5       * add these to the mode bits
00002B62  0C05 003C               2238              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002B66  6700 1CFA               2239              BEQ     OPERROR     * immediate data, there is not allowed, error
00002B6A                          2240      
00002B6A  4EB8 163C               2241              JSR     getMode
00002B6E  CCFC 0008               2242              MULU    #8,D6       * multiply for offset
00002B72  4DF9 000048D2           2243              LEA     eaTable,A6  * load e table
00002B78  4EB6 6000               2244              JSR     (A6,D6)     * jump to table
00002B7C                          2245              * check for error in EA
00002B7C  0C07 0004               2246              CMPI.B  #4,D7
00002B80  6700 1CE0               2247              BEQ     OPERROR
00002B84                          2248              
00002B84  4E75                    2249              RTS
00002B86                          2250  
00002B86                          2251  _SubQl      
00002B86  1E3C 0003               2252              MOVE.B  #3,D7       * indicate a long instruction
00002B8A  264A                    2253              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002B8C  14FC 0053               2254              MOVE.B  #'S',(A2)+
00002B90  14FC 0055               2255              MOVE.B  #'U',(A2)+
00002B94  14FC 0042               2256              MOVE.B  #'B',(A2)+
00002B98  14FC 0051               2257              MOVE.B  #'Q',(A2)+
00002B9C  14FC 002E               2258              MOVE.B  #'.',(A2)+
00002BA0  14FC 004C               2259              MOVE.B  #'L',(A2)+
00002BA4  14FC 0020               2260              MOVE.B  #' ',(A2)+
00002BA8  14FC 0020               2261              MOVE.B  #' ',(A2)+
00002BAC  14FC 0020               2262              MOVE.B  #' ',(A2)+
00002BB0  14FC 0020               2263              MOVE.B  #' ',(A2)+
00002BB4  14FC 0023               2264              MOVE.B  #'#',(A2)+
00002BB8                          2265              
00002BB8  4EB8 1564               2266              JSR     BitTst3     * get the data value
00002BBC  0C06 0000               2267              CMPI.B  #%000,D6    * if it is 000, add 8
00002BC0  6600 0008               2268              BNE     SubQl       * if not, continue to next part
00002BC4  4EB9 00002C10           2269              JSR     Add8
00002BCA  CCFC 0008               2270  SubQl       MULU    #8,D6       * multiply for offset
00002BCE  4DF9 00004A72           2271              LEA     numTable,A6 * load num table
00002BD4  4EB6 6000               2272              JSR     (A6,D6)     * jump to table
00002BD8                          2273                  
00002BD8  14FC 002C               2274              MOVE.B  #',',(A2)+  * print comma
00002BDC                          2275              
00002BDC  4EB8 163C               2276              JSR     getMode     * get EA mode
00002BE0  E74E                    2277              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00002BE2  1A06                    2278              MOVE.B  D6,D5       * hold destination mode bits in d5
00002BE4  E78B                    2279              LSL.L   #3,D3       * shift destination mode bits out
00002BE6  4EB8 1564               2280              JSR     BitTst3     * test the destination register bits
00002BEA  DA46                    2281              ADD.W   D6,D5       * add these to the mode bits
00002BEC  0C05 003C               2282              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00002BF0  6700 1C70               2283              BEQ     OPERROR     * immediate data, there is not allowed, error
00002BF4                          2284      
00002BF4  4EB8 163C               2285              JSR     getMode
00002BF8  CCFC 0008               2286              MULU    #8,D6       * multiply for offset
00002BFC  4DF9 000048D2           2287              LEA     eaTable,A6  * load e table
00002C02  4EB6 6000               2288              JSR     (A6,D6)     * jump to table
00002C06                          2289              * check for error in EA
00002C06  0C07 0004               2290              CMPI.B  #4,D7
00002C0A  6700 1C56               2291              BEQ     OPERROR
00002C0E                          2292              
00002C0E  4E75                    2293              RTS
00002C10                          2294  **************************************************************************************
00002C10                          2295  * Add 8 - subroutine that adds 8 if the data value in instruction code is 000.
00002C10                          2296  * Used for SUBQ and ADDQ.
00002C10                          2297  **************************************************************************************
00002C10                          2298  Add8        
00002C10  5006                    2299              ADDI.B  #8,D6   * add 8 to d6
00002C12  4E75                    2300              RTS             * return
00002C14                          2301   
00002C14                          2302  * Bcc (BRA/BCC/BLT/BGE) --------------------------------------------------------------
00002C14                          2303  op0110      
00002C14  4843                    2304              SWAP    D3
00002C16  E98B                    2305              LSL.L   #4,D3        * shift out opcode
00002C18  4EB8 1538               2306              JSR     BITTEST      * test next four bits for condition
00002C1C  0C06 0000               2307              CMPI.B  #%0000,D6
00002C20  6700 003E               2308              BEQ     _Bra         * check BRA condition
00002C24  0C06 0004               2309              CMPI.B  #%0100,D6
00002C28  6700 007A               2310              BEQ     _Bcc         * check BCC condition
00002C2C  0C06 0005               2311              CMPI.B  #%0101,D6
00002C30  6700 00B6               2312              BEQ     _Bcs         * check BCS condition
00002C34  0C06 0006               2313              CMPI.B  #%0110,D6
00002C38  6700 00F2               2314              BEQ     _Bne         * check BNE condition
00002C3C  0C06 000C               2315              CMPI.B  #%1100,D6
00002C40  6700 012E               2316              BEQ     _Bge         * check BGE condition
00002C44  0C06 000D               2317              CMPI.B  #%1101,D6
00002C48  6700 016A               2318              BEQ     _Blt         * check BLT condition
00002C4C  0C06 000E               2319              CMPI.B  #%1110,D6
00002C50  6700 01A6               2320              BEQ     _Bgt         * check BGT condition
00002C54  0C06 000F               2321              CMPI.B  #%1111,D6
00002C58  6700 01E2               2322              BEQ     _Ble         * check BLE condition
00002C5C                          2323              
00002C5C                          2324              * branch to unsupported/error
00002C5C  6000 1C04               2325              BRA     OPERROR
00002C60                          2326              
00002C60                          2327  * BRA ------------------------
00002C60  14FC 0042               2328  _Bra        MOVE.B  #'B',(A2)+      * add BRA to A2 string
00002C64  14FC 0052               2329              MOVE.B  #'R',(A2)+
00002C68  14FC 0041               2330              MOVE.B  #'A',(A2)+
00002C6C  14FC 0020               2331              MOVE.B  #' ',(A2)+
00002C70  14FC 0020               2332              MOVE.B  #' ',(A2)+
00002C74  14FC 0020               2333              MOVE.B  #' ',(A2)+
00002C78  14FC 0020               2334              MOVE.B  #' ',(A2)+
00002C7C  14FC 0020               2335              MOVE.B  #' ',(A2)+
00002C80  14FC 0020               2336              MOVE.B  #' ',(A2)+
00002C84  14FC 0020               2337              MOVE.B  #' ',(A2)+
00002C88  14FC 0024               2338              MOVE.B  #'$',(A2)+
00002C8C  4243                    2339              CLR     D3
00002C8E  1604                    2340              MOVE.B  D4,D3
00002C90  0C03 0000               2341              CMPI.B  #$00,D3     * branch of 16 bit offset
00002C94  6700 01EA               2342              BEQ     _WordDisp
00002C98  0C03 00FF               2343              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002C9C  6700 01E8               2344              BEQ     _LongDisp
00002CA0  6000 01EA               2345              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002CA4                          2346              
00002CA4                          2347  * BCC ------------------------
00002CA4  14FC 0042               2348  _Bcc        MOVE.B  #'B',(A2)+      * add BCC to A2 String
00002CA8  14FC 0043               2349              MOVE.B  #'C',(A2)+
00002CAC  14FC 0043               2350              MOVE.B  #'C',(A2)+
00002CB0  14FC 0020               2351              MOVE.B  #' ',(A2)+
00002CB4  14FC 0020               2352              MOVE.B  #' ',(A2)+
00002CB8  14FC 0020               2353              MOVE.B  #' ',(A2)+
00002CBC  14FC 0020               2354              MOVE.B  #' ',(A2)+
00002CC0  14FC 0020               2355              MOVE.B  #' ',(A2)+
00002CC4  14FC 0020               2356              MOVE.B  #' ',(A2)+
00002CC8  14FC 0020               2357              MOVE.B  #' ',(A2)+
00002CCC  14FC 0024               2358              MOVE.B  #'$',(A2)+
00002CD0  4243                    2359              CLR     D3
00002CD2  1604                    2360              MOVE.B  D4,D3
00002CD4  0C03 0000               2361              CMPI.B  #$00,D3     * branch of 16 bit offset
00002CD8  6700 01A6               2362              BEQ     _WordDisp
00002CDC  0C03 00FF               2363              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002CE0  6700 01A4               2364              BEQ     _LongDisp
00002CE4  6000 01A6               2365              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002CE8                          2366              
00002CE8                          2367  * BCS ------------------------
00002CE8                          2368  _Bcs
00002CE8  14FC 0042               2369              MOVE.B  #'B',(A2)+      * add BCS to A2 string
00002CEC  14FC 0043               2370              MOVE.B  #'C',(A2)+
00002CF0  14FC 0053               2371              MOVE.B  #'S',(A2)+
00002CF4  14FC 0020               2372              MOVE.B  #' ',(A2)+
00002CF8  14FC 0020               2373              MOVE.B  #' ',(A2)+
00002CFC  14FC 0020               2374              MOVE.B  #' ',(A2)+
00002D00  14FC 0020               2375              MOVE.B  #' ',(A2)+
00002D04  14FC 0020               2376              MOVE.B  #' ',(A2)+
00002D08  14FC 0020               2377              MOVE.B  #' ',(A2)+
00002D0C  14FC 0020               2378              MOVE.B  #' ',(A2)+
00002D10  14FC 0024               2379              MOVE.B  #'$',(A2)+
00002D14  4243                    2380              CLR     D3
00002D16  1604                    2381              MOVE.B  D4,D3
00002D18  0C03 0000               2382              CMPI.B  #$00,D3     * branch of 16 bit offset
00002D1C  6700 0162               2383              BEQ     _WordDisp
00002D20  0C03 00FF               2384              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002D24  6700 0160               2385              BEQ     _LongDisp
00002D28  6000 0162               2386              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002D2C                          2387              
00002D2C                          2388  * BNE ------------------------
00002D2C                          2389  _Bne  
00002D2C  14FC 0042               2390              MOVE.B  #'B',(A2)+      * add BNE to A2 string
00002D30  14FC 0052               2391              MOVE.B  #'R',(A2)+
00002D34  14FC 0041               2392              MOVE.B  #'A',(A2)+
00002D38  14FC 0020               2393              MOVE.B  #' ',(A2)+
00002D3C  14FC 0020               2394              MOVE.B  #' ',(A2)+
00002D40  14FC 0020               2395              MOVE.B  #' ',(A2)+
00002D44  14FC 0020               2396              MOVE.B  #' ',(A2)+
00002D48  14FC 0020               2397              MOVE.B  #' ',(A2)+
00002D4C  14FC 0020               2398              MOVE.B  #' ',(A2)+
00002D50  14FC 0020               2399              MOVE.B  #' ',(A2)+
00002D54  14FC 0024               2400              MOVE.B  #'$',(A2)+
00002D58  4243                    2401              CLR     D3
00002D5A  1604                    2402              MOVE.B  D4,D3
00002D5C  0C03 0000               2403              CMPI.B  #$00,D3     * branch of 16 bit offset
00002D60  6700 011E               2404              BEQ     _WordDisp
00002D64  0C03 00FF               2405              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002D68  6700 011C               2406              BEQ     _LongDisp
00002D6C  6000 011E               2407              BRA     _ByteDisp   * branch defaults to 8 bit offset 
00002D70                          2408              
00002D70                          2409  * BGE ------------------------
00002D70  14FC 0042               2410  _Bge        MOVE.B  #'B',(A2)+      * add BGE to A2 string
00002D74  14FC 0047               2411              MOVE.B  #'G',(A2)+
00002D78  14FC 0045               2412              MOVE.B  #'E',(A2)+
00002D7C  14FC 0020               2413              MOVE.B  #' ',(A2)+
00002D80  14FC 0020               2414              MOVE.B  #' ',(A2)+
00002D84  14FC 0020               2415              MOVE.B  #' ',(A2)+
00002D88  14FC 0020               2416              MOVE.B  #' ',(A2)+
00002D8C  14FC 0020               2417              MOVE.B  #' ',(A2)+
00002D90  14FC 0020               2418              MOVE.B  #' ',(A2)+
00002D94  14FC 0020               2419              MOVE.B  #' ',(A2)+
00002D98  14FC 0024               2420              MOVE.B  #'$',(A2)+
00002D9C  4243                    2421              CLR     D3
00002D9E  1604                    2422              MOVE.B  D4,D3
00002DA0  0C03 0000               2423              CMPI.B  #$00,D3     * branch of 16 bit offset
00002DA4  6700 00DA               2424              BEQ     _WordDisp
00002DA8  0C03 00FF               2425              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002DAC  6700 00D8               2426              BEQ     _LongDisp
00002DB0  6000 00DA               2427              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002DB4                          2428              
00002DB4                          2429              
00002DB4                          2430  * BLT ------------------------
00002DB4  14FC 0042               2431  _Blt        MOVE.B  #'B',(A2)+      * add BLT to A2 String
00002DB8  14FC 004C               2432              MOVE.B  #'L',(A2)+
00002DBC  14FC 0054               2433              MOVE.B  #'T',(A2)+
00002DC0  14FC 0020               2434              MOVE.B  #' ',(A2)+
00002DC4  14FC 0020               2435              MOVE.B  #' ',(A2)+
00002DC8  14FC 0020               2436              MOVE.B  #' ',(A2)+
00002DCC  14FC 0020               2437              MOVE.B  #' ',(A2)+
00002DD0  14FC 0020               2438              MOVE.B  #' ',(A2)+
00002DD4  14FC 0020               2439              MOVE.B  #' ',(A2)+
00002DD8  14FC 0020               2440              MOVE.B  #' ',(A2)+
00002DDC  14FC 0024               2441              MOVE.B  #'$',(A2)+
00002DE0  4243                    2442              CLR     D3
00002DE2  1604                    2443              MOVE.B  D4,D3
00002DE4  0C03 0000               2444              CMPI.B  #$00,D3     * branch of 16 bit offset
00002DE8  6700 0096               2445              BEQ     _WordDisp
00002DEC  0C03 00FF               2446              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002DF0  6700 0094               2447              BEQ     _LongDisp
00002DF4  6000 0096               2448              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002DF8                          2449              
00002DF8                          2450  * BGT -------------------------            
00002DF8                          2451  _Bgt
00002DF8  14FC 0042               2452              MOVE.B  #'B',(A2)+      * add BGT to A2 string
00002DFC  14FC 0052               2453              MOVE.B  #'R',(A2)+
00002E00  14FC 0041               2454              MOVE.B  #'A',(A2)+
00002E04  14FC 0020               2455              MOVE.B  #' ',(A2)+
00002E08  14FC 0020               2456              MOVE.B  #' ',(A2)+
00002E0C  14FC 0020               2457              MOVE.B  #' ',(A2)+
00002E10  14FC 0020               2458              MOVE.B  #' ',(A2)+
00002E14  14FC 0020               2459              MOVE.B  #' ',(A2)+
00002E18  14FC 0020               2460              MOVE.B  #' ',(A2)+
00002E1C  14FC 0020               2461              MOVE.B  #' ',(A2)+
00002E20  14FC 0024               2462              MOVE.B  #'$',(A2)+
00002E24  4243                    2463              CLR     D3
00002E26  1604                    2464              MOVE.B  D4,D3
00002E28  0C03 0000               2465              CMPI.B  #$00,D3     * branch of 16 bit offset
00002E2C  6700 0052               2466              BEQ     _WordDisp
00002E30  0C03 00FF               2467              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002E34  6700 0050               2468              BEQ     _LongDisp
00002E38  6000 0052               2469              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002E3C                          2470  * BLE -------------------------
00002E3C                          2471  _Ble
00002E3C  14FC 0042               2472              MOVE.B  #'B',(A2)+      * add BLE to A2 string
00002E40  14FC 004C               2473              MOVE.B  #'L',(A2)+
00002E44  14FC 0045               2474              MOVE.B  #'E',(A2)+
00002E48  14FC 0020               2475              MOVE.B  #' ',(A2)+
00002E4C  14FC 0020               2476              MOVE.B  #' ',(A2)+
00002E50  14FC 0020               2477              MOVE.B  #' ',(A2)+
00002E54  14FC 0020               2478              MOVE.B  #' ',(A2)+
00002E58  14FC 0020               2479              MOVE.B  #' ',(A2)+
00002E5C  14FC 0020               2480              MOVE.B  #' ',(A2)+
00002E60  14FC 0020               2481              MOVE.B  #' ',(A2)+
00002E64  14FC 0024               2482              MOVE.B  #'$',(A2)+
00002E68  4243                    2483              CLR     D3
00002E6A  1604                    2484              MOVE.B  D4,D3
00002E6C  0C03 0000               2485              CMPI.B  #$00,D3     * branch of 16 bit offset
00002E70  6700 000E               2486              BEQ     _WordDisp
00002E74  0C03 00FF               2487              CMPI.B  #$FF,D3     * branch of 32 bit offset
00002E78  6700 000C               2488              BEQ     _LongDisp
00002E7C  6000 000E               2489              BRA     _ByteDisp   * branch defaults to 8 bit offset
00002E80                          2490  
00002E80                          2491  **************************************************************************
00002E80                          2492  * Functions that handle the different types of displacements for a branch
00002E80                          2493  **************************************************************************
00002E80                          2494  * Displacement is a word length
00002E80                          2495  _WordDisp
00002E80  4EB8 15DE               2496              JSR     printWord
00002E84  4E75                    2497              RTS
00002E86                          2498  * Displacement is long length
00002E86                          2499  _LongDisp
00002E86  4EB8 160C               2500              JSR     printLong
00002E8A  4E75                    2501              RTS
00002E8C                          2502  * Displacement is byte length
00002E8C                          2503  _ByteDisp  
00002E8C  4242                    2504              CLR     D2
00002E8E  4DF9 00004A72           2505              LEA     numTable,A6
00002E94  4843                    2506              SWAP    D3
00002E96  E18B                    2507              LSL.L   #8,D3
00002E98                          2508              
00002E98  0C02 0002               2509  ByteDispLp  CMPI.B  #2,D2       * loop through twice,
00002E9C  6700 0014               2510              BEQ     dispDone    * print done
00002EA0  4EB8 1538               2511              JSR     BITTEST     * get leading 4 bits
00002EA4  CCFC 0008               2512              MULU    #8,D6       * multiply by 8 for jump offset 
00002EA8  4EB6 6000               2513              JSR     (A6,D6)     * get number from table and add to A2 string
00002EAC  E98B                    2514              LSL.L   #4,D3       * shift out the 4 bits were done with
00002EAE  5242                    2515              ADDQ    #1,D2       * increment loop counter
00002EB0  60E6                    2516              BRA     ByteDispLp  
00002EB2                          2517              
00002EB2  4E75                    2518  dispDone    RTS
00002EB4                          2519               
00002EB4                          2520  * MOVEQ ---------------------------------------------------------------------------
00002EB4                          2521  op0111      
00002EB4  14FC 004D               2522              MOVE.B  #'M',(A2)+      * add MOVEQ to A2 String
00002EB8  14FC 004F               2523              MOVE.B  #'O',(A2)+
00002EBC  14FC 0056               2524              MOVE.B  #'V',(A2)+
00002EC0  14FC 0045               2525              MOVE.B  #'E',(A2)+
00002EC4  14FC 0051               2526              MOVE.B  #'Q',(A2)+
00002EC8  14FC 0020               2527              MOVE.B  #' ',(A2)+
00002ECC  14FC 0020               2528              MOVE.B  #' ',(A2)+
00002ED0  14FC 0020               2529              MOVE.B  #' ',(A2)+
00002ED4  14FC 0020               2530              MOVE.B  #' ',(A2)+
00002ED8  14FC 0020               2531              MOVE.B  #' ',(A2)+
00002EDC  14FC 0023               2532              MOVE.B  #'#',(A2)+
00002EE0  14FC 0024               2533              MOVE.B  #'$',(A2)+
00002EE4  4EB8 2E8C               2534              JSR     _ByteDisp       * print byte data of MOVEQ instruction
00002EE8  14FC 002C               2535              MOVE.B  #',',(A2)+      * print comma
00002EEC  14FC 0044               2536              MOVE.B  #'D',(A2)+      * print D
00002EF0  2604                    2537              MOVE.L  D4,D3
00002EF2  4843                    2538              SWAP    D3
00002EF4  E98B                    2539              LSL.L   #4,D3           * shift out opcode
00002EF6  4EB8 1564               2540              JSR     BitTst3         * get bits 9->11 for data register
00002EFA  CCFC 0008               2541              MULU    #8,D6           * multiply for offset 
00002EFE  4DF9 00004A72           2542              LEA     numTable,A6     * load num table
00002F04  4EB6 6000               2543              JSR     (A6,D6)         * get number and print
00002F08  4E75                    2544              RTS 
00002F0A                          2545             
00002F0A                          2546  * DIVU, DIVS, OR ------------------------------------------------------------------
00002F0A                          2547  op1000      
00002F0A  4843                    2548              SWAP    D3  
00002F0C  EF8B                    2549              LSL.L   #7,D3   * shift out opcode & dest register
00002F0E  4EB8 1564               2550              JSR     BitTst3     * check the next three bits
00002F12  0C06 0003               2551              CMPI.B  #%011,D6    * they are fixed for divu/divs
00002F16  6700 000E               2552              BEQ     _DivU       * branch to divu if 011
00002F1A  0C06 0007               2553              CMPI.B  #%111,D6
00002F1E  6700 0070               2554              BEQ     _DivS       * branch to divs if 111
00002F22                          2555              
00002F22  6000 00C0               2556              BRA     _Or     * its either OR or an error
00002F26                          2557              
00002F26                          2558  * DIVU -----------------------            
00002F26                          2559  _DivU       
00002F26  1E3C 0002               2560              MOVE.B  #2,D7       * indicate a word instruction
00002F2A  264A                    2561              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002F2C  14FC 0044               2562              MOVE.B  #'D',(A2)+      * add DIVU to A2 String
00002F30  14FC 0049               2563              MOVE.B  #'I',(A2)+
00002F34  14FC 0056               2564              MOVE.B  #'V',(A2)+
00002F38  14FC 0055               2565              MOVE.B  #'U',(A2)+
00002F3C  14FC 0020               2566              MOVE.B  #' ',(A2)+
00002F40  14FC 0020               2567              MOVE.B  #' ',(A2)+
00002F44  14FC 0020               2568              MOVE.B  #' ',(A2)+
00002F48  14FC 0020               2569              MOVE.B  #' ',(A2)+
00002F4C  14FC 0020               2570              MOVE.B  #' ',(A2)+
00002F50  14FC 0020               2571              MOVE.B  #' ',(A2)+
00002F54                          2572              * get EA
00002F54  4EB8 163C               2573              JSR     getMode     * get mode bits
00002F58  4DF9 000048D2           2574              LEA     eaTable,A6   * load e table
00002F5E  CCFC 0008               2575              MULU    #8,D6       * offset
00002F62  4EB6 6000               2576              JSR     (A6,D6)     * get EA and print
00002F66                          2577              * check for error in EA
00002F66  0C07 0004               2578              CMPI.B  #4,D7
00002F6A  6700 18F6               2579              BEQ     OPERROR
00002F6E                          2580      
00002F6E  14FC 002C               2581              MOVE.B  #',',(A2)+  * print comma
00002F72  14FC 0044               2582              MOVE.B  #'D',(A2)+  * print D
00002F76  2604                    2583              MOVE.L  D4,D3       * reset D3
00002F78  4843                    2584              SWAP    D3          * push bits to front
00002F7A  E98B                    2585              LSL.L   #4,D3       * shift out opcode
00002F7C  4EB8 1564               2586              JSR     BitTst3     * get next three bits
00002F80                          2587              
00002F80  CCFC 0008               2588              MULU    #8,D6
00002F84  4DF9 00004A72           2589              LEA     numTable,A6
00002F8A  4EB6 6000               2590              JSR     (A6,D6)
00002F8E                          2591              
00002F8E  4E75                    2592              RTS
00002F90                          2593              
00002F90                          2594  * DIVS -----------------------
00002F90                          2595  _DivS       
00002F90  1E3C 0002               2596              MOVE.B  #2,D7       * indicate a word instruction
00002F94  264A                    2597              MOVEA.L A2,A3       * copy current address of A2 string to A3
00002F96  14FC 0044               2598              MOVE.B  #'D',(A2)+      * add DIVS to A2 String
00002F9A  14FC 0049               2599              MOVE.B  #'I',(A2)+
00002F9E  14FC 0056               2600              MOVE.B  #'V',(A2)+
00002FA2  14FC 0053               2601              MOVE.B  #'S',(A2)+
00002FA6  14FC 0020               2602              MOVE.B  #' ',(A2)+
00002FAA  14FC 0020               2603              MOVE.B  #' ',(A2)+
00002FAE  14FC 0020               2604              MOVE.B  #' ',(A2)+
00002FB2  14FC 0020               2605              MOVE.B  #' ',(A2)+
00002FB6  14FC 0020               2606              MOVE.B  #' ',(A2)+
00002FBA  14FC 0020               2607              MOVE.B  #' ',(A2)+
00002FBE                          2608              * get EA
00002FBE  4EB8 163C               2609              JSR     getMode 
00002FC2  14FC 002C               2610              MOVE.B  #',',(A2)+  * print comma
00002FC6  14FC 0044               2611              MOVE.B  #'D',(A2)+  * print D
00002FCA  2604                    2612              MOVE.L  D4,D3       * reset D3
00002FCC  4843                    2613              SWAP    D3
00002FCE  E98B                    2614              LSL.L   #4,D3       * shift out opcode
00002FD0  4EB8 1564               2615              JSR     BitTst3     * get next three bits
00002FD4                          2616              
00002FD4  CCFC 0008               2617              MULU    #8,D6
00002FD8  4DF9 00004A72           2618              LEA     numTable,A6
00002FDE  4EB6 6000               2619              JSR     (A6,D6)
00002FE2  4E75                    2620              RTS
00002FE4                          2621              
00002FE4                          2622  * OR -------------------------------------------------------------------------------
00002FE4                          2623  _Or         
00002FE4  2604                    2624              MOVE.L  D4,D3       * reset D3
00002FE6  0803 0008               2625              BTST.L  #$08,D3     * check 8th bit for ea mode
00002FEA  6600 01C4               2626              BNE     _OrEA
00002FEE  4843                    2627              SWAP    D3          * swap it forward
00002FF0  E18B                    2628              LSL.L   #8,D3       * shift out 8 bits so leading 2 bits are the size
00002FF2  4EB8 1586               2629              JSR     BitTst2     * get size bits in D6
00002FF6  0C06 0000               2630              CMPI.B  #%00,D6     * check the size bit of D6 from previous test
00002FFA  6700 0016               2631              BEQ     _OrB        * OR.B
00002FFE  0C06 0001               2632              CMPI.B  #%01,D6
00003002  6700 0098               2633              BEQ     _OrW        * OR.W
00003006  0C06 0002               2634              CMPI.B  #%10,D6
0000300A  6700 011A               2635              BEQ     _OrL        * OR.L
0000300E                          2636              
0000300E  6000 1852               2637              BRA     OPERROR
00003012                          2638  
00003012                          2639  * OR.B -----------------------            
00003012                          2640  _OrB        
00003012  1E3C 0001               2641              MOVE.B  #1,D7       * indicate a byte instruction
00003016  264A                    2642              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003018  14FC 004F               2643              MOVE.B  #'O',(A2)+      * add OR.B to A2 String
0000301C  14FC 0052               2644              MOVE.B  #'R',(A2)+
00003020  14FC 002E               2645              MOVE.B  #'.',(A2)+
00003024  14FC 0042               2646              MOVE.B  #'B',(A2)+
00003028  14FC 0020               2647              MOVE.B  #' ',(A2)+
0000302C  14FC 0020               2648              MOVE.B  #' ',(A2)+
00003030  14FC 0020               2649              MOVE.B  #' ',(A2)+
00003034  14FC 0020               2650              MOVE.B  #' ',(A2)+
00003038  14FC 0020               2651              MOVE.B  #' ',(A2)+
0000303C  14FC 0020               2652              MOVE.B  #' ',(A2)+
00003040                          2653              * get EA
00003040  4EB8 163C               2654              JSR     getMode
00003044  0C06 0001               2655              CMPI.B  #%001,D6    * source cannot be An
00003048  6700 1818               2656              BEQ     OPERROR
0000304C  E74E                    2657              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000304E  1A06                    2658              MOVE.B  D6,D5       * hold destination mode bits in d5
00003050  E78B                    2659              LSL.L   #3,D3       * shift destination mode bits out
00003052  4EB8 1564               2660              JSR     BitTst3     * test the destination register bits
00003056  DA46                    2661              ADD.W   D6,D5       * add these to the mode bits
00003058  0C05 003C               2662              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000305C  6700 1804               2663              BEQ     OPERROR     * immediate data, there is not allowed, error
00003060                          2664             
00003060                          2665              * no errors
00003060  4EB8 163C               2666              JSR     getMode 
00003064  4DF9 000048D2           2667              LEA     eaTable,A6
0000306A  CCFC 0008               2668              MULU    #8,D6
0000306E  4EB6 6000               2669              JSR     (A6,D6)
00003072                          2670              * check for error in EA
00003072  0C07 0004               2671              CMPI.B  #4,D7
00003076  6700 17EA               2672              BEQ     OPERROR
0000307A                          2673              * destination must be data register
0000307A  14FC 002C               2674              MOVE.B  #',',(A2)+
0000307E  14FC 0044               2675              MOVE.B  #'D',(A2)+
00003082  2604                    2676              MOVE.L  D4,D3   * reset D3
00003084  4843                    2677              SWAP    D3
00003086  E98B                    2678              LSL.L   #4,D3   * shift out opcode
00003088  4EB8 1564               2679              JSR     BitTst3 * get data register number
0000308C  CCFC 0008               2680              MULU    #8,D6   * multiply for offset
00003090  4DF9 00004A72           2681              LEA     numTable,A6 * load num table
00003096  4EB6 6000               2682              JSR     (A6,D6)     * get number from table and print
0000309A  4E75                    2683              RTS
0000309C                          2684              
0000309C                          2685  * OR.W -----------------------
0000309C                          2686  _OrW        
0000309C  1E3C 0002               2687              MOVE.B  #2,D7       * indicate a word instruction
000030A0  264A                    2688              MOVEA.L A2,A3       * copy current address of A2 string to A3
000030A2  14FC 004F               2689              MOVE.B  #'O',(A2)+      * add OR.W to A2 String
000030A6  14FC 0052               2690              MOVE.B  #'R',(A2)+
000030AA  14FC 002E               2691              MOVE.B  #'.',(A2)+
000030AE  14FC 0057               2692              MOVE.B  #'W',(A2)+
000030B2  14FC 0020               2693              MOVE.B  #' ',(A2)+
000030B6  14FC 0020               2694              MOVE.B  #' ',(A2)+
000030BA  14FC 0020               2695              MOVE.B  #' ',(A2)+
000030BE  14FC 0020               2696              MOVE.B  #' ',(A2)+
000030C2  14FC 0020               2697              MOVE.B  #' ',(A2)+
000030C6  14FC 0020               2698              MOVE.B  #' ',(A2)+
000030CA                          2699              * get EA
000030CA  4EB8 163C               2700              JSR     getMode
000030CE  0C06 0001               2701              CMPI.B  #%001,D6    * source cannot be An
000030D2  6700 178E               2702              BEQ     OPERROR
000030D6  E74E                    2703              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000030D8  1A06                    2704              MOVE.B  D6,D5       * hold destination mode bits in d5
000030DA  E78B                    2705              LSL.L   #3,D3       * shift destination mode bits out
000030DC  4EB8 1564               2706              JSR     BitTst3     * test the destination register bits
000030E0  DA46                    2707              ADD.W   D6,D5       * add these to the mode bits
000030E2  0C05 003C               2708              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000030E6  6700 177A               2709              BEQ     OPERROR     * immediate data, there is not allowed, error
000030EA                          2710              * no errors
000030EA  4EB8 163C               2711              JSR     getMode
000030EE  4DF9 000048D2           2712              LEA     eaTable,A6
000030F4  CCFC 0008               2713              MULU    #8,D6
000030F8  4EB6 6000               2714              JSR     (A6,D6)
000030FC                          2715              * check for error in EA
000030FC  0C07 0004               2716              CMPI.B  #4,D7
00003100  6700 1760               2717              BEQ     OPERROR
00003104                          2718              * destination must be data register
00003104  14FC 002C               2719              MOVE.B  #',',(A2)+
00003108  14FC 0044               2720              MOVE.B  #'D',(A2)+
0000310C  2604                    2721              MOVE.L  D4,D3   * reset D3
0000310E  4843                    2722              SWAP    D3
00003110  E98B                    2723              LSL.L   #4,D3   * shift out opcode
00003112  4EB8 1564               2724              JSR     BitTst3 * get data register number
00003116  CCFC 0008               2725              MULU    #8,D6   * multiply for offset
0000311A  4DF9 00004A72           2726              LEA     numTable,A6 * load num table
00003120  4EB6 6000               2727              JSR     (A6,D6)     * get number from table and print
00003124  4E75                    2728              RTS
00003126                          2729              
00003126                          2730  * OR.L -----------------------
00003126                          2731  _OrL        
00003126  1E3C 0003               2732              MOVE.B  #3,D7       * indicate a word instruction
0000312A  264A                    2733              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000312C  14FC 004F               2734              MOVE.B  #'O',(A2)+      * add OR.L to A2 String
00003130  14FC 0052               2735              MOVE.B  #'R',(A2)+
00003134  14FC 002E               2736              MOVE.B  #'.',(A2)+
00003138  14FC 004C               2737              MOVE.B  #'L',(A2)+
0000313C  14FC 0020               2738              MOVE.B  #' ',(A2)+
00003140  14FC 0020               2739              MOVE.B  #' ',(A2)+
00003144  14FC 0020               2740              MOVE.B  #' ',(A2)+
00003148  14FC 0020               2741              MOVE.B  #' ',(A2)+
0000314C  14FC 0020               2742              MOVE.B  #' ',(A2)+
00003150  14FC 0020               2743              MOVE.B  #' ',(A2)+
00003154                          2744              * get EA
00003154  4EB8 163C               2745              JSR     getMode
00003158  0C06 0001               2746              CMPI.B  #%001,D6    * source cannot be An
0000315C  6700 1704               2747              BEQ     OPERROR
00003160  E74E                    2748              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003162  1A06                    2749              MOVE.B  D6,D5       * hold destination mode bits in d5
00003164  E78B                    2750              LSL.L   #3,D3       * shift destination mode bits out
00003166  4EB8 1564               2751              JSR     BitTst3     * test the destination register bits
0000316A  DA46                    2752              ADD.W   D6,D5       * add these to the mode bits
0000316C  0C05 003C               2753              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003170  6700 16F0               2754              BEQ     OPERROR     * immediate data, there is not allowed, error
00003174                          2755              
00003174  4EB8 163C               2756              JSR     getMode
00003178  4DF9 000048D2           2757              LEA     eaTable,A6
0000317E  CCFC 0008               2758              MULU    #8,D6
00003182  4EB6 6000               2759              JSR     (A6,D6)
00003186                          2760              * check for error in EA
00003186  0C07 0004               2761              CMPI.B  #4,D7
0000318A  6700 16D6               2762              BEQ     OPERROR
0000318E                          2763              * destination must be data register
0000318E  14FC 002C               2764              MOVE.B  #',',(A2)+
00003192  14FC 0044               2765              MOVE.B  #'D',(A2)+
00003196  2604                    2766              MOVE.L  D4,D3   * reset D3
00003198  4843                    2767              SWAP    D3
0000319A  E98B                    2768              LSL.L   #4,D3   * shift out opcode
0000319C  4EB8 1564               2769              JSR     BitTst3 * get data register number
000031A0  CCFC 0008               2770              MULU    #8,D6   * multiply for offset
000031A4  4DF9 00004A72           2771              LEA     numTable,A6 * load num table
000031AA  4EB6 6000               2772              JSR     (A6,D6)     * get number from table and print
000031AE  4E75                    2773              RTS
000031B0                          2774       
000031B0                          2775  * Or to effective address ----------------------------------------------------       
000031B0                          2776  _OrEA
000031B0  4843                    2777              SWAP    D3          * swap it forward
000031B2  E18B                    2778              LSL.L   #8,D3       * shift out 8 bits so leading 2 bits are the size
000031B4  4EB8 1586               2779              JSR     BitTst2     * get size bits in D6
000031B8  2604                    2780              MOVE.L  D4,D3       * reset D3
000031BA  4843                    2781              SWAP    D3
000031BC  0C06 0000               2782              CMPI.B  #%00,D6     * check the size bit of D6 from previous test
000031C0  6700 0012               2783              BEQ     _OrB_EA        * OR.B
000031C4  0C06 0001               2784              CMPI.B  #%01,D6
000031C8  6700 0090               2785              BEQ     _OrW_EA      * OR.W
000031CC  0C06 0002               2786              CMPI.B  #%10,D6
000031D0  6700 010E               2787              BEQ     _OrL_EA     * OR.L
000031D4                          2788  
000031D4                          2789  _OrB_EA     
000031D4  1E3C 0001               2790              MOVE.B  #1,D7       * indicate a byte instruction
000031D8  264A                    2791              MOVEA.L A2,A3       * copy current address of A2 string to A3
000031DA  14FC 004F               2792              MOVE.B  #'O',(A2)+      * add OR.B to A2 String
000031DE  14FC 0052               2793              MOVE.B  #'R',(A2)+
000031E2  14FC 002E               2794              MOVE.B  #'.',(A2)+
000031E6  14FC 0042               2795              MOVE.B  #'B',(A2)+
000031EA  14FC 0020               2796              MOVE.B  #' ',(A2)+
000031EE  14FC 0020               2797              MOVE.B  #' ',(A2)+
000031F2  14FC 0020               2798              MOVE.B  #' ',(A2)+
000031F6  14FC 0020               2799              MOVE.B  #' ',(A2)+
000031FA  14FC 0020               2800              MOVE.B  #' ',(A2)+
000031FE  14FC 0020               2801              MOVE.B  #' ',(A2)+
00003202  14FC 0044               2802              MOVE.B  #'D',(A2)+  * starting source must be data register
00003206  E98B                    2803              LSL.L   #4,D3   * shift out opcode
00003208  4EB8 1564               2804              JSR     BitTst3 * get data register number
0000320C  CCFC 0008               2805              MULU    #8,D6   * multiply for offset
00003210  4DF9 00004A72           2806              LEA     numTable,A6 * load num table
00003216  4EB6 6000               2807              JSR     (A6,D6)     * get number from table and print
0000321A  14FC 002C               2808              MOVE.B  #',',(A2)+
0000321E                          2809              
0000321E                          2810              * get EA mode and check for errors
0000321E  4EB8 163C               2811              JSR     getMode
00003222  0C06 0001               2812              CMPI.B  #%001,D6    * cant write to An
00003226  6700 163A               2813              BEQ     OPERROR
0000322A  E74E                    2814              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
0000322C  1A06                    2815              MOVE.B  D6,D5       * hold destination mode bits in d5
0000322E  E78B                    2816              LSL.L   #3,D3       * shift destination mode bits out
00003230  4EB8 1564               2817              JSR     BitTst3     * test the destination register bits
00003234  DA46                    2818              ADD.W   D6,D5       * add these to the mode bits
00003236  0C05 003C               2819              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000323A  6700 1626               2820              BEQ     OPERROR     * immediate data, there is not allowed, error
0000323E                          2821              
0000323E                          2822              * no errors
0000323E  4EB8 163C               2823              JSR     getMode
00003242  4DF9 000048D2           2824              LEA     eaTable,A6
00003248  CCFC 0008               2825              MULU    #8,D6
0000324C  4EB6 6000               2826              JSR     (A6,D6)
00003250                          2827              * check for error in EA
00003250  0C07 0004               2828              CMPI.B  #4,D7
00003254  6700 160C               2829              BEQ     OPERROR
00003258  4E75                    2830              RTS
0000325A                          2831  
0000325A                          2832  _OrW_EA     
0000325A  1E3C 0002               2833              MOVE.B  #2,D7       * indicate a word instruction
0000325E  264A                    2834              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003260  14FC 004F               2835              MOVE.B  #'O',(A2)+      * add OR.W to A2 String
00003264  14FC 0052               2836              MOVE.B  #'R',(A2)+
00003268  14FC 002E               2837              MOVE.B  #'.',(A2)+
0000326C  14FC 0057               2838              MOVE.B  #'W',(A2)+
00003270  14FC 0020               2839              MOVE.B  #' ',(A2)+
00003274  14FC 0020               2840              MOVE.B  #' ',(A2)+
00003278  14FC 0020               2841              MOVE.B  #' ',(A2)+
0000327C  14FC 0020               2842              MOVE.B  #' ',(A2)+
00003280  14FC 0020               2843              MOVE.B  #' ',(A2)+
00003284  14FC 0020               2844              MOVE.B  #' ',(A2)+
00003288  14FC 0044               2845              MOVE.B  #'D',(A2)+  * starting source must be data register
0000328C  E98B                    2846              LSL.L   #4,D3   * shift out opcode
0000328E  4EB8 1564               2847              JSR     BitTst3 * get data register number
00003292  CCFC 0008               2848              MULU    #8,D6   * multiply for offset
00003296  4DF9 00004A72           2849              LEA     numTable,A6 * load num table
0000329C  4EB6 6000               2850              JSR     (A6,D6)     * get number from table and print
000032A0  14FC 002C               2851              MOVE.B  #',',(A2)+
000032A4                          2852              
000032A4                          2853              * get EA mode and check for errors
000032A4  4EB8 163C               2854              JSR     getMode
000032A8  0C06 0001               2855              CMPI.B  #%001,D6    * cant write to An
000032AC  6700 15B4               2856              BEQ     OPERROR
000032B0  E74E                    2857              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000032B2  1A06                    2858              MOVE.B  D6,D5       * hold destination mode bits in d5
000032B4  E78B                    2859              LSL.L   #3,D3       * shift destination mode bits out
000032B6  4EB8 1564               2860              JSR     BitTst3     * test the destination register bits
000032BA  DA46                    2861              ADD.W   D6,D5       * add these to the mode bits
000032BC  0C05 003C               2862              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000032C0  6700 15A0               2863              BEQ     OPERROR     * immediate data, there is not allowed, error
000032C4                          2864              
000032C4                          2865              * no errors
000032C4  4EB8 163C               2866              JSR     getMode
000032C8  4DF9 000048D2           2867              LEA     eaTable,A6
000032CE  CCFC 0008               2868              MULU    #8,D6
000032D2  4EB6 6000               2869              JSR     (A6,D6)
000032D6                          2870              * check for error in EA
000032D6  0C07 0004               2871              CMPI.B  #4,D7
000032DA  6700 1586               2872              BEQ     OPERROR
000032DE  4E75                    2873              RTS
000032E0                          2874  
000032E0                          2875  _OrL_EA
000032E0  1E3C 0003               2876              MOVE.B  #3,D7       * indicate a long instruction
000032E4  264A                    2877              MOVEA.L A2,A3       * copy current address of A2 string to A3
000032E6  14FC 004F               2878              MOVE.B  #'O',(A2)+      * add OR.W to A2 String
000032EA  14FC 0052               2879              MOVE.B  #'R',(A2)+
000032EE  14FC 002E               2880              MOVE.B  #'.',(A2)+
000032F2  14FC 0057               2881              MOVE.B  #'W',(A2)+
000032F6  14FC 0020               2882              MOVE.B  #' ',(A2)+
000032FA  14FC 0020               2883              MOVE.B  #' ',(A2)+
000032FE  14FC 0020               2884              MOVE.B  #' ',(A2)+
00003302  14FC 0020               2885              MOVE.B  #' ',(A2)+
00003306  14FC 0020               2886              MOVE.B  #' ',(A2)+
0000330A  14FC 0020               2887              MOVE.B  #' ',(A2)+
0000330E  14FC 0044               2888              MOVE.B  #'D',(A2)+  * starting source must be data register
00003312  E98B                    2889              LSL.L   #4,D3   * shift out opcode
00003314  4EB8 1564               2890              JSR     BitTst3 * get data register number
00003318  CCFC 0008               2891              MULU    #8,D6   * multiply for offset
0000331C  4DF9 00004A72           2892              LEA     numTable,A6 * load num table
00003322  4EB6 6000               2893              JSR     (A6,D6)     * get number from table and print
00003326  14FC 002C               2894              MOVE.B  #',',(A2)+
0000332A                          2895              
0000332A                          2896              * get EA mode and check for errors
0000332A  4EB8 163C               2897              JSR     getMode
0000332E  0C06 0001               2898              CMPI.B  #%001,D6    * cant write to An
00003332  6700 152E               2899              BEQ     OPERROR
00003336  E74E                    2900              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003338  1A06                    2901              MOVE.B  D6,D5       * hold destination mode bits in d5
0000333A  E78B                    2902              LSL.L   #3,D3       * shift destination mode bits out
0000333C  4EB8 1564               2903              JSR     BitTst3     * test the destination register bits
00003340  DA46                    2904              ADD.W   D6,D5       * add these to the mode bits
00003342  0C05 003C               2905              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003346  6700 151A               2906              BEQ     OPERROR     * immediate data, there is not allowed, error
0000334A                          2907              
0000334A                          2908              * no errors
0000334A  4EB8 163C               2909              JSR     getMode
0000334E  4DF9 000048D2           2910              LEA     eaTable,A6
00003354  CCFC 0008               2911              MULU    #8,D6
00003358  4EB6 6000               2912              JSR     (A6,D6)
0000335C                          2913              * check for error in EA
0000335C  0C07 0004               2914              CMPI.B  #4,D7
00003360  6700 1500               2915              BEQ     OPERROR
00003364                          2916              
00003364  4E75                    2917              RTS
00003366                          2918  
00003366                          2919  * SUB ------------------------------------------------------------------------            
00003366  0803 0008               2920  op1001      BTST.L  #$08,D3
0000336A  6600 01C4               2921              BNE     Sub_EA  * <ea>*Dn -> <ea>
0000336E  4843                    2922              SWAP    D3
00003370  E18B                    2923              LSL.L   #8,D3   * shift leading 8 bits out to check size
00003372  4EB8 1586               2924              JSR     BitTst2
00003376  0C06 0000               2925              CMPI.B  #%00,D6
0000337A  6700 0016               2926              BEQ     _SubB   * SUB.B
0000337E  0C06 0001               2927              CMPI.B  #%01,D6
00003382  6700 0098               2928              BEQ     _SubW   * SUB.W
00003386  0C06 0002               2929              CMPI.B  #%10,D6
0000338A  6700 011A               2930              BEQ     _SubL   * SUB.L
0000338E                          2931              
0000338E  6000 14D2               2932              BRA     OPERROR
00003392                          2933              
00003392                          2934  _SubB       
00003392  1E3C 0001               2935              MOVE.B  #1,D7       * indicate a byte instruction
00003396  264A                    2936              MOVEA.L A2,A3       * copy current address of A2 string to A3            
00003398  14FC 0053               2937              MOVE.B  #'S',(A2)+      * add SUB.B to A2 String
0000339C  14FC 0055               2938              MOVE.B  #'U',(A2)+
000033A0  14FC 0042               2939              MOVE.B  #'B',(A2)+
000033A4  14FC 002E               2940              MOVE.B  #'.',(A2)+
000033A8  14FC 0042               2941              MOVE.B  #'B',(A2)+
000033AC  14FC 0020               2942              MOVE.B  #' ',(A2)+
000033B0  14FC 0020               2943              MOVE.B  #' ',(A2)+
000033B4  14FC 0020               2944              MOVE.B  #' ',(A2)+
000033B8  14FC 0020               2945              MOVE.B  #' ',(A2)+
000033BC  14FC 0020               2946              MOVE.B  #' ',(A2)+
000033C0                          2947              * get EA
000033C0  4EB8 163C               2948              JSR     getMode
000033C4  0C06 0001               2949              CMPI.B  #%001,D6    * source cannot be An
000033C8  6700 1498               2950              BEQ     OPERROR
000033CC  E74E                    2951              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000033CE  1A06                    2952              MOVE.B  D6,D5       * hold destination mode bits in d5
000033D0  E78B                    2953              LSL.L   #3,D3       * shift destination mode bits out
000033D2  4EB8 1564               2954              JSR     BitTst3     * test the destination register bits
000033D6  DA46                    2955              ADD.W   D6,D5       * add these to the mode bits
000033D8  0C05 003C               2956              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000033DC  6700 1484               2957              BEQ     OPERROR     * immediate data, this is not allowed, error
000033E0                          2958              * no errors
000033E0  4EB8 163C               2959              JSR     getMode
000033E4  4DF9 000048D2           2960              LEA     eaTable,A6
000033EA  CCFC 0008               2961              MULU    #8,D6
000033EE  4EB6 6000               2962              JSR     (A6,D6)
000033F2                          2963              * check for error in EA
000033F2  0C07 0004               2964              CMPI.B  #4,D7
000033F6  6700 146A               2965              BEQ     OPERROR
000033FA                          2966              * destination must be data register
000033FA  14FC 002C               2967              MOVE.B  #',',(A2)+
000033FE  14FC 0044               2968              MOVE.B  #'D',(A2)+
00003402  2604                    2969              MOVE.L  D4,D3   * reset D3
00003404  4843                    2970              SWAP    D3
00003406  E98B                    2971              LSL.L   #4,D3   * shift out opcode
00003408  4EB8 1564               2972              JSR     BitTst3 * get data register number
0000340C  CCFC 0008               2973              MULU    #8,D6   * multiply for offset
00003410  4DF9 00004A72           2974              LEA     numTable,A6 * load num table
00003416  4EB6 6000               2975              JSR     (A6,D6)     * get number from table and print
0000341A                          2976  
0000341A  4E75                    2977              RTS  
0000341C                          2978  
0000341C                          2979  _SubW       
0000341C  1E3C 0002               2980              MOVE.B  #2,D7       * indicate a word instruction
00003420  264A                    2981              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003422  14FC 0053               2982              MOVE.B  #'S',(A2)+      * add SUB.W to A2 String
00003426  14FC 0055               2983              MOVE.B  #'U',(A2)+
0000342A  14FC 0042               2984              MOVE.B  #'B',(A2)+
0000342E  14FC 002E               2985              MOVE.B  #'.',(A2)+
00003432  14FC 0057               2986              MOVE.B  #'W',(A2)+
00003436  14FC 0020               2987              MOVE.B  #' ',(A2)+
0000343A  14FC 0020               2988              MOVE.B  #' ',(A2)+
0000343E  14FC 0020               2989              MOVE.B  #' ',(A2)+
00003442  14FC 0020               2990              MOVE.B  #' ',(A2)+
00003446  14FC 0020               2991              MOVE.B  #' ',(A2)+
0000344A                          2992              * get EA
0000344A  4EB8 163C               2993              JSR     getMode
0000344E  0C06 0001               2994              CMPI.B  #%001,D6    * source cannot be An
00003452  6700 140E               2995              BEQ     OPERROR
00003456  E74E                    2996              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003458  1A06                    2997              MOVE.B  D6,D5       * hold destination mode bits in d5
0000345A  E78B                    2998              LSL.L   #3,D3       * shift destination mode bits out
0000345C  4EB8 1564               2999              JSR     BitTst3     * test the destination register bits
00003460  DA46                    3000              ADD.W   D6,D5       * add these to the mode bits
00003462  0C05 003C               3001              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003466  6700 13FA               3002              BEQ     OPERROR     * immediate data, there is not allowed, error
0000346A                          3003              * no errors
0000346A  4EB8 163C               3004              JSR     getMode
0000346E  4DF9 000048D2           3005              LEA     eaTable,A6
00003474  CCFC 0008               3006              MULU    #8,D6
00003478  4EB6 6000               3007              JSR     (A6,D6)
0000347C                          3008              * check for error in EA
0000347C  0C07 0004               3009              CMPI.B  #4,D7
00003480  6700 13E0               3010              BEQ     OPERROR
00003484                          3011              * destination must be data register
00003484  14FC 002C               3012              MOVE.B  #',',(A2)+
00003488  14FC 0044               3013              MOVE.B  #'D',(A2)+
0000348C  2604                    3014              MOVE.L  D4,D3   * reset D3
0000348E  4843                    3015              SWAP    D3
00003490  E98B                    3016              LSL.L   #4,D3   * shift out opcode
00003492  4EB8 1564               3017              JSR     BitTst3 * get data register number
00003496  CCFC 0008               3018              MULU    #8,D6   * multiply for offset
0000349A  4DF9 00004A72           3019              LEA     numTable,A6 * load num table
000034A0  4EB6 6000               3020              JSR     (A6,D6)     * get number from table and print
000034A4                          3021  
000034A4  4E75                    3022              RTS
000034A6                          3023  
000034A6                          3024  _SubL       
000034A6  1E3C 0003               3025              MOVE.B  #3,D7       * indicate a long instruction
000034AA  264A                    3026              MOVEA.L A2,A3       * copy current address of A2 string to A3
000034AC  14FC 0053               3027              MOVE.B  #'S',(A2)+      * add SUB.L to A2 String
000034B0  14FC 0055               3028              MOVE.B  #'U',(A2)+
000034B4  14FC 0042               3029              MOVE.B  #'B',(A2)+
000034B8  14FC 002E               3030              MOVE.B  #'.',(A2)+
000034BC  14FC 004C               3031              MOVE.B  #'L',(A2)+
000034C0  14FC 0020               3032              MOVE.B  #' ',(A2)+
000034C4  14FC 0020               3033              MOVE.B  #' ',(A2)+
000034C8  14FC 0020               3034              MOVE.B  #' ',(A2)+
000034CC  14FC 0020               3035              MOVE.B  #' ',(A2)+
000034D0  14FC 0020               3036              MOVE.B  #' ',(A2)+
000034D4                          3037              * get EA
000034D4  4EB8 163C               3038              JSR     getMode
000034D8  0C06 0001               3039              CMPI.B  #%001,D6    * source cannot be An
000034DC  6700 1384               3040              BEQ     OPERROR
000034E0  E74E                    3041              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000034E2  1A06                    3042              MOVE.B  D6,D5       * hold destination mode bits in d5
000034E4  E78B                    3043              LSL.L   #3,D3       * shift destination mode bits out
000034E6  4EB8 1564               3044              JSR     BitTst3     * test the destination register bits
000034EA  DA46                    3045              ADD.W   D6,D5       * add these to the mode bits
000034EC  0C05 003C               3046              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000034F0  6700 1370               3047              BEQ     OPERROR     * immediate data, there is not allowed, error
000034F4                          3048              * no errors
000034F4  4EB8 163C               3049              JSR     getMode
000034F8  4DF9 000048D2           3050              LEA     eaTable,A6
000034FE  CCFC 0008               3051              MULU    #8,D6
00003502  4EB6 6000               3052              JSR     (A6,D6)
00003506                          3053              * check for error in EA
00003506  0C07 0004               3054              CMPI.B  #4,D7
0000350A  6700 1356               3055              BEQ     OPERROR
0000350E                          3056              * destination must be data register
0000350E  14FC 002C               3057              MOVE.B  #',',(A2)+
00003512  14FC 0044               3058              MOVE.B  #'D',(A2)+
00003516  2604                    3059              MOVE.L  D4,D3   * reset D3
00003518  4843                    3060              SWAP    D3
0000351A  E98B                    3061              LSL.L   #4,D3   * shift out opcode
0000351C  4EB8 1564               3062              JSR     BitTst3 * get data register number
00003520  CCFC 0008               3063              MULU    #8,D6   * multiply for offset
00003524  4DF9 00004A72           3064              LEA     numTable,A6 * load num table
0000352A  4EB6 6000               3065              JSR     (A6,D6)     * get number from table and print
0000352E                          3066  
0000352E  4E75                    3067              RTS
00003530                          3068  
00003530                          3069  Sub_EA      
00003530  4843                    3070              SWAP    D3
00003532  E18B                    3071              LSL.L   #8,D3   * shift leading 8 bits out to check size
00003534  4EB8 1586               3072              JSR     BitTst2
00003538  2604                    3073              MOVE.L  D4,D3   * reset D3
0000353A  4843                    3074              SWAP    D3
0000353C  0C06 0000               3075              CMPI.B  #%00,D6
00003540  6700 0012               3076              BEQ     _SubB_EA   * SUB.B
00003544  0C06 0001               3077              CMPI.B  #%01,D6
00003548  6700 0090               3078              BEQ     _SubW_EA   * SUB.W
0000354C  0C06 0002               3079              CMPI.B  #%10,D6
00003550  6700 010E               3080              BEQ     _SubL_EA   * SUB.L
00003554                          3081              
00003554                          3082  _SubB_EA
00003554  1E3C 0001               3083              MOVE.B  #1,D7       * indicate a byte instruction
00003558  264A                    3084              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000355A  14FC 0053               3085              MOVE.B  #'S',(A2)+      * add OR.W to A2 String
0000355E  14FC 0055               3086              MOVE.B  #'U',(A2)+
00003562  14FC 0042               3087              MOVE.B  #'B',(A2)+
00003566  14FC 002E               3088              MOVE.B  #'.',(A2)+
0000356A  14FC 0042               3089              MOVE.B  #'B',(A2)+
0000356E  14FC 0020               3090              MOVE.B  #' ',(A2)+
00003572  14FC 0020               3091              MOVE.B  #' ',(A2)+
00003576  14FC 0020               3092              MOVE.B  #' ',(A2)+
0000357A  14FC 0020               3093              MOVE.B  #' ',(A2)+
0000357E  14FC 0020               3094              MOVE.B  #' ',(A2)+
00003582  14FC 0044               3095              MOVE.B  #'D',(A2)+  * starting source must be data register
00003586  E98B                    3096              LSL.L   #4,D3   * shift out opcode
00003588  4EB8 1564               3097              JSR     BitTst3 * get data register number
0000358C  CCFC 0008               3098              MULU    #8,D6   * multiply for offset
00003590  4DF9 00004A72           3099              LEA     numTable,A6 * load num table
00003596  4EB6 6000               3100              JSR     (A6,D6)     * get number from table and print
0000359A  14FC 002C               3101              MOVE.B  #',',(A2)+
0000359E                          3102              
0000359E                          3103              * get EA mode and check for errors
0000359E  4EB8 163C               3104              JSR     getMode
000035A2  0C06 0001               3105              CMPI.B  #%001,D6    * cant write to An
000035A6  6700 12BA               3106              BEQ     OPERROR
000035AA  E74E                    3107              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000035AC  1A06                    3108              MOVE.B  D6,D5       * hold destination mode bits in d5
000035AE  E78B                    3109              LSL.L   #3,D3       * shift destination mode bits out
000035B0  4EB8 1564               3110              JSR     BitTst3     * test the destination register bits
000035B4  DA46                    3111              ADD.W   D6,D5       * add these to the mode bits
000035B6  0C05 003C               3112              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000035BA  6700 12A6               3113              BEQ     OPERROR     * immediate data, there is not allowed, error
000035BE                          3114              
000035BE                          3115              * no errors
000035BE  4EB8 163C               3116              JSR     getMode
000035C2  4DF9 000048D2           3117              LEA     eaTable,A6
000035C8  CCFC 0008               3118              MULU    #8,D6
000035CC  4EB6 6000               3119              JSR     (A6,D6)
000035D0                          3120              * check for error in EA
000035D0  0C07 0004               3121              CMPI.B  #4,D7
000035D4  6700 128C               3122              BEQ     OPERROR
000035D8                          3123              
000035D8  4E75                    3124              RTS
000035DA                          3125  
000035DA                          3126  
000035DA                          3127  _SubW_EA    
000035DA  1E3C 0002               3128              MOVE.B  #2,D7       * indicate a word instruction
000035DE  264A                    3129              MOVEA.L A2,A3       * copy current address of A2 string to A3
000035E0  14FC 0053               3130              MOVE.B  #'S',(A2)+      * add OR.W to A2 String
000035E4  14FC 0055               3131              MOVE.B  #'U',(A2)+
000035E8  14FC 0042               3132              MOVE.B  #'B',(A2)+
000035EC  14FC 002E               3133              MOVE.B  #'.',(A2)+
000035F0  14FC 0057               3134              MOVE.B  #'W',(A2)+
000035F4  14FC 0020               3135              MOVE.B  #' ',(A2)+
000035F8  14FC 0020               3136              MOVE.B  #' ',(A2)+
000035FC  14FC 0020               3137              MOVE.B  #' ',(A2)+
00003600  14FC 0020               3138              MOVE.B  #' ',(A2)+
00003604  14FC 0020               3139              MOVE.B  #' ',(A2)+
00003608  14FC 0044               3140              MOVE.B  #'D',(A2)+  * starting source must be data register
0000360C  E98B                    3141              LSL.L   #4,D3   * shift out opcode
0000360E  4EB8 1564               3142              JSR     BitTst3 * get data register number
00003612  CCFC 0008               3143              MULU    #8,D6   * multiply for offset
00003616  4DF9 00004A72           3144              LEA     numTable,A6 * load num table
0000361C  4EB6 6000               3145              JSR     (A6,D6)     * get number from table and print
00003620  14FC 002C               3146              MOVE.B  #',',(A2)+
00003624                          3147              
00003624                          3148              * get EA mode and check for errors
00003624  4EB8 163C               3149              JSR     getMode
00003628  0C06 0001               3150              CMPI.B  #%001,D6    * cant write to An
0000362C  6700 1234               3151              BEQ     OPERROR
00003630  E74E                    3152              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003632  1A06                    3153              MOVE.B  D6,D5       * hold destination mode bits in d5
00003634  E78B                    3154              LSL.L   #3,D3       * shift destination mode bits out
00003636  4EB8 1564               3155              JSR     BitTst3     * test the destination register bits
0000363A  DA46                    3156              ADD.W   D6,D5       * add these to the mode bits
0000363C  0C05 003C               3157              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003640  6700 1220               3158              BEQ     OPERROR     * immediate data, there is not allowed, error
00003644                          3159              
00003644                          3160              * no errors
00003644  4EB8 163C               3161              JSR     getMode
00003648  4DF9 000048D2           3162              LEA     eaTable,A6
0000364E  CCFC 0008               3163              MULU    #8,D6
00003652  4EB6 6000               3164              JSR     (A6,D6)
00003656                          3165              * check for error in EA
00003656  0C07 0004               3166              CMPI.B  #4,D7
0000365A  6700 1206               3167              BEQ     OPERROR
0000365E                          3168              
0000365E  4E75                    3169              RTS
00003660                          3170  
00003660                          3171  
00003660                          3172  _SubL_EA
00003660  1E3C 0003               3173              MOVE.B  #3,D7       * indicate a long instruction
00003664  264A                    3174              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003666  14FC 0053               3175              MOVE.B  #'S',(A2)+      * add OR.W to A2 String
0000366A  14FC 0055               3176              MOVE.B  #'U',(A2)+
0000366E  14FC 0042               3177              MOVE.B  #'B',(A2)+
00003672  14FC 002E               3178              MOVE.B  #'.',(A2)+
00003676  14FC 004C               3179              MOVE.B  #'L',(A2)+
0000367A  14FC 0020               3180              MOVE.B  #' ',(A2)+
0000367E  14FC 0020               3181              MOVE.B  #' ',(A2)+
00003682  14FC 0020               3182              MOVE.B  #' ',(A2)+
00003686  14FC 0020               3183              MOVE.B  #' ',(A2)+
0000368A  14FC 0020               3184              MOVE.B  #' ',(A2)+
0000368E  14FC 0044               3185              MOVE.B  #'D',(A2)+  * starting source must be data register
00003692  E98B                    3186              LSL.L   #4,D3   * shift out opcode
00003694  4EB8 1564               3187              JSR     BitTst3 * get data register number
00003698  CCFC 0008               3188              MULU    #8,D6   * multiply for offset
0000369C  4DF9 00004A72           3189              LEA     numTable,A6 * load num table
000036A2  4EB6 6000               3190              JSR     (A6,D6)     * get number from table and print
000036A6  14FC 002C               3191              MOVE.B  #',',(A2)+
000036AA                          3192              
000036AA                          3193              * get EA mode and check for errors
000036AA  4EB8 163C               3194              JSR     getMode
000036AE  0C06 0001               3195              CMPI.B  #%001,D6    * cant write to An
000036B2  6700 11AE               3196              BEQ     OPERROR
000036B6  E74E                    3197              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000036B8  1A06                    3198              MOVE.B  D6,D5       * hold destination mode bits in d5
000036BA  E78B                    3199              LSL.L   #3,D3       * shift destination mode bits out
000036BC  4EB8 1564               3200              JSR     BitTst3     * test the destination register bits
000036C0  DA46                    3201              ADD.W   D6,D5       * add these to the mode bits
000036C2  0C05 003C               3202              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000036C6  6700 119A               3203              BEQ     OPERROR     * immediate data, there is not allowed, error
000036CA                          3204              
000036CA                          3205              * no errors
000036CA  4EB8 163C               3206              JSR     getMode
000036CE  4DF9 000048D2           3207              LEA     eaTable,A6
000036D4  CCFC 0008               3208              MULU    #8,D6
000036D8  4EB6 6000               3209              JSR     (A6,D6)
000036DC                          3210              * check for error in EA
000036DC  0C07 0004               3211              CMPI.B  #4,D7
000036E0  6700 1180               3212              BEQ     OPERROR
000036E4                          3213              
000036E4  4E75                    3214              RTS
000036E6                          3215  
000036E6                          3216  
000036E6                          3217  * CMP ---------------------------------------------------------------------------------
000036E6                          3218  op1011      
000036E6  0803 0008               3219              BTST.L  #$08,D3      * if 8th bit is 1, it is not CMP/CMPA
000036EA  6600 1176               3220              BNE     OPERROR     * branch to unsupported
000036EE  4843                    3221              SWAP    D3      * move bits forward
000036F0  E98B                    3222              LSL.L   #4,D3   * shift out opcode
000036F2  E98B                    3223              LSL.L   #4,D3   * shift out dest register & 8th bit
000036F4  4EB8 1586               3224              JSR     BitTst2
000036F8  0C06 0000               3225              CMPI.B  #%00,D6 * check size bits
000036FC  6700 0016               3226              BEQ     _CmpB   * CMP.B
00003700  0C06 0001               3227              CMPI.B  #%01,D6
00003704  6700 0098               3228              BEQ     _CmpW   * CMP.W
00003708  0C06 0002               3229              CMPI.B  #%10,D6
0000370C  6700 011A               3230              BEQ     _CmpL   * CMP.L
00003710                          3231              
00003710                          3232              * CMPA/unexpected input, branch to error
00003710  6000 1150               3233              BRA     OPERROR
00003714                          3234              
00003714                          3235  * CMP.B ----------------------            
00003714                          3236  _CmpB       
00003714  1E3C 0001               3237              MOVE.B  #1,D7       * indicate a byte instruction
00003718  264A                    3238              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000371A  14FC 0043               3239              MOVE.B  #'C',(A2)+      * add CMP.B to A2 String
0000371E  14FC 004D               3240              MOVE.B  #'M',(A2)+
00003722  14FC 0050               3241              MOVE.B  #'P',(A2)+
00003726  14FC 002E               3242              MOVE.B  #'.',(A2)+
0000372A  14FC 0042               3243              MOVE.B  #'B',(A2)+
0000372E  14FC 0020               3244              MOVE.B  #' ',(A2)+
00003732  14FC 0020               3245              MOVE.B  #' ',(A2)+
00003736  14FC 0020               3246              MOVE.B  #' ',(A2)+
0000373A  14FC 0020               3247              MOVE.B  #' ',(A2)+
0000373E  14FC 0020               3248              MOVE.B  #' ',(A2)+
00003742                          3249              * get EA to check for errors
00003742  4EB8 163C               3250              JSR     getMode
00003746  0C06 0001               3251              CMPI.B  #%001,D6    * mode cannot be An
0000374A  6700 1116               3252              BEQ     OPERROR
0000374E  E74E                    3253              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003750  1A06                    3254              MOVE.B  D6,D5       * hold destination mode bits in d5
00003752  E78B                    3255              LSL.L   #3,D3       * shift destination mode bits out
00003754  4EB8 1564               3256              JSR     BitTst3     * test the destination register bits
00003758  DA46                    3257              ADD.W   D6,D5       * add these to the mode bits
0000375A  0C05 003C               3258              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000375E  6700 1102               3259              BEQ     OPERROR     * immediate data, there is not allowed, error
00003762                          3260              * no errors
00003762  4EB8 163C               3261              JSR     getMode
00003766  4DF9 000048D2           3262              LEA     eaTable,A6
0000376C  CCFC 0008               3263              MULU    #8,D6
00003770  4EB6 6000               3264              JSR     (A6,D6)
00003774                          3265              * check for error in EA
00003774  0C07 0004               3266              CMPI.B  #4,D7
00003778  6700 10E8               3267              BEQ     OPERROR
0000377C                          3268              
0000377C  14FC 002C               3269              MOVE.B  #',',(A2)+
00003780  14FC 0044               3270              MOVE.B  #'D',(A2)+
00003784  2604                    3271              MOVE.L  D4,D3   * reset D3
00003786  4843                    3272              SWAP    D3
00003788  E98B                    3273              LSL.L   #4,D3   * shift out opcode
0000378A  4EB8 1564               3274              JSR     BitTst3 * get data register number
0000378E  CCFC 0008               3275              MULU    #8,D6   * multiply for offset
00003792  4DF9 00004A72           3276              LEA     numTable,A6 * load num table
00003798  4EB6 6000               3277              JSR     (A6,D6)     * get number from table and print
0000379C                          3278              
0000379C  4E75                    3279              RTS 
0000379E                          3280              
0000379E                          3281  * CMP.W ----------------------
0000379E                          3282  _CmpW       
0000379E  1E3C 0002               3283              MOVE.B  #2,D7       * indicate a long instruction
000037A2  264A                    3284              MOVEA.L A2,A3       * copy current address of A2 string to A3
000037A4  14FC 0043               3285              MOVE.B  #'C',(A2)+      * add CMP.W to A2 String
000037A8  14FC 004D               3286              MOVE.B  #'M',(A2)+
000037AC  14FC 0050               3287              MOVE.B  #'P',(A2)+
000037B0  14FC 002E               3288              MOVE.B  #'.',(A2)+
000037B4  14FC 0057               3289              MOVE.B  #'W',(A2)+
000037B8  14FC 0020               3290              MOVE.B  #' ',(A2)+
000037BC  14FC 0020               3291              MOVE.B  #' ',(A2)+
000037C0  14FC 0020               3292              MOVE.B  #' ',(A2)+
000037C4  14FC 0020               3293              MOVE.B  #' ',(A2)+
000037C8  14FC 0020               3294              MOVE.B  #' ',(A2)+
000037CC                          3295              * get EA to check for errors
000037CC  4EB8 163C               3296              JSR     getMode
000037D0  0C06 0001               3297              CMPI.B  #%001,D6    * mode cannot be An
000037D4  6700 108C               3298              BEQ     OPERROR
000037D8  E74E                    3299              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000037DA  1A06                    3300              MOVE.B  D6,D5       * hold destination mode bits in d5
000037DC  E78B                    3301              LSL.L   #3,D3       * shift destination mode bits out
000037DE  4EB8 1564               3302              JSR     BitTst3     * test the destination register bits
000037E2  DA46                    3303              ADD.W   D6,D5       * add these to the mode bits
000037E4  0C05 003C               3304              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000037E8  6700 1078               3305              BEQ     OPERROR     * immediate data, there is not allowed, error
000037EC                          3306              * no errors
000037EC  4EB8 163C               3307              JSR     getMode
000037F0  4DF9 000048D2           3308              LEA     eaTable,A6
000037F6  CCFC 0008               3309              MULU    #8,D6
000037FA  4EB6 6000               3310              JSR     (A6,D6)
000037FE                          3311              * check for error in EA
000037FE  0C07 0004               3312              CMPI.B  #4,D7
00003802  6700 105E               3313              BEQ     OPERROR
00003806                          3314              
00003806  14FC 002C               3315              MOVE.B  #',',(A2)+
0000380A  14FC 0044               3316              MOVE.B  #'D',(A2)+
0000380E  2604                    3317              MOVE.L  D4,D3   * reset D3
00003810  4843                    3318              SWAP    D3
00003812  E98B                    3319              LSL.L   #4,D3   * shift out opcode
00003814  4EB8 1564               3320              JSR     BitTst3 * get data register number
00003818  CCFC 0008               3321              MULU    #8,D6   * multiply for offset
0000381C  4DF9 00004A72           3322              LEA     numTable,A6 * load num table
00003822  4EB6 6000               3323              JSR     (A6,D6)     * get number from table and print
00003826                          3324  
00003826  4E75                    3325              RTS
00003828                          3326  * CMP.L ----------------------
00003828                          3327  _CmpL       
00003828  1E3C 0003               3328              MOVE.B  #3,D7       * indicate a long instruction
0000382C  264A                    3329              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000382E  14FC 0043               3330              MOVE.B  #'C',(A2)+      * add CMP.L to A2 String
00003832  14FC 004D               3331              MOVE.B  #'M',(A2)+
00003836  14FC 0050               3332              MOVE.B  #'P',(A2)+
0000383A  14FC 002E               3333              MOVE.B  #'.',(A2)+
0000383E  14FC 004C               3334              MOVE.B  #'L',(A2)+
00003842  14FC 0020               3335              MOVE.B  #' ',(A2)+
00003846  14FC 0020               3336              MOVE.B  #' ',(A2)+
0000384A  14FC 0020               3337              MOVE.B  #' ',(A2)+
0000384E  14FC 0020               3338              MOVE.B  #' ',(A2)+
00003852  14FC 0020               3339              MOVE.B  #' ',(A2)+
00003856                          3340              * get EA to check for errors
00003856  4EB8 163C               3341              JSR     getMode
0000385A  0C06 0001               3342              CMPI.B  #%001,D6    * mode cannot be An
0000385E  6700 1002               3343              BEQ     OPERROR
00003862  E74E                    3344              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003864  1A06                    3345              MOVE.B  D6,D5       * hold destination mode bits in d5
00003866  E78B                    3346              LSL.L   #3,D3       * shift destination mode bits out
00003868  4EB8 1564               3347              JSR     BitTst3     * test the destination register bits
0000386C  DA46                    3348              ADD.W   D6,D5       * add these to the mode bits
0000386E  0C05 003C               3349              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003872  6700 0FEE               3350              BEQ     OPERROR     * immediate data, there is not allowed, error
00003876                          3351              * no errors
00003876  4EB8 163C               3352              JSR     getMode
0000387A  4DF9 000048D2           3353              LEA     eaTable,A6
00003880  CCFC 0008               3354              MULU    #8,D6
00003884  4EB6 6000               3355              JSR     (A6,D6)
00003888                          3356              * check for error in EA
00003888  0C07 0004               3357              CMPI.B  #4,D7
0000388C  6700 0FD4               3358              BEQ     OPERROR
00003890                          3359              
00003890  14FC 002C               3360              MOVE.B  #',',(A2)+
00003894  14FC 0044               3361              MOVE.B  #'D',(A2)+
00003898  2604                    3362              MOVE.L  D4,D3   * reset D3
0000389A  4843                    3363              SWAP    D3
0000389C  E98B                    3364              LSL.L   #4,D3   * shift out opcode
0000389E  4EB8 1564               3365              JSR     BitTst3 * get data register number
000038A2  CCFC 0008               3366              MULU    #8,D6   * multiply for offset
000038A6  4DF9 00004A72           3367              LEA     numTable,A6 * load num table
000038AC  4EB6 6000               3368              JSR     (A6,D6)     * get number from table and print
000038B0                          3369  
000038B0  4E75                    3370              RTS
000038B2                          3371              
000038B2                          3372  * MULS, AND --------------------------------------------------------------
000038B2                          3373  op1100      
000038B2  4843                    3374              SWAP    D3
000038B4  E18B                    3375              LSL.L   #8,D3   * shift out op code and next four bits
000038B6  4EB8 1586               3376              JSR     BitTst2 * check next two bits for size/MUL instruction
000038BA  0C06 0003               3377              CMPI.B  #%11,D6 * if bits 6-7 are not 11, it is not a MUL
000038BE  6600 0076               3378              BNE     _And    * branch to AND
000038C2  2604                    3379              MOVE.L  D4,D3   * reset D3
000038C4  0803 0008               3380              BTST.L  #$08,D3 * if bit 8 is 0, it is not MULS, error
000038C8  6700 0F98               3381              BEQ     OPERROR
000038CC                          3382              * otherwise, it is a MULS instruction
000038CC  1E3C 0002               3383              MOVE.B  #2,D7       * indicate a word instruction
000038D0  264A                    3384              MOVEA.L A2,A3       * copy current address of A2 string to A3
000038D2  14FC 004D               3385              MOVE.B  #'M',(A2)+      * add DIVS to A2 String
000038D6  14FC 0055               3386              MOVE.B  #'U',(A2)+
000038DA  14FC 004C               3387              MOVE.B  #'L',(A2)+
000038DE  14FC 0053               3388              MOVE.B  #'S',(A2)+
000038E2  14FC 0020               3389              MOVE.B  #' ',(A2)+
000038E6  14FC 0020               3390              MOVE.B  #' ',(A2)+
000038EA  14FC 0020               3391              MOVE.B  #' ',(A2)+
000038EE  14FC 0020               3392              MOVE.B  #' ',(A2)+
000038F2  14FC 0020               3393              MOVE.B  #' ',(A2)+
000038F6  14FC 0020               3394              MOVE.B  #' ',(A2)+
000038FA                          3395              * get EA
000038FA  4EB8 163C               3396              JSR     getMode     * get mode
000038FE  4DF9 000048D2           3397              LEA     eaTable,A6  * load ea table
00003904  CCFC 0008               3398              MULU    #8,D6       * offset
00003908  4EB6 6000               3399              JSR     (A6,D6)     * get EA and reg number
0000390C                          3400              * check for error in EA
0000390C  0C07 0004               3401              CMPI.B  #4,D7
00003910  6700 0F50               3402              BEQ     OPERROR
00003914                          3403   
00003914  14FC 002C               3404              MOVE.B  #',',(A2)+  * print comma
00003918  14FC 0044               3405              MOVE.B  #'D',(A2)+  * print D
0000391C  2604                    3406              MOVE.L  D4,D3
0000391E  4843                    3407              SWAP    D3
00003920  E98B                    3408              LSL.L   #4,D3       * shift out opcode
00003922  4EB8 1564               3409              JSR     BitTst3     * get next three bits
00003926                          3410              
00003926  CCFC 0008               3411              MULU    #8,D6
0000392A  4DF9 00004A72           3412              LEA     numTable,A6
00003930  4EB6 6000               3413              JSR     (A6,D6)
00003934                          3414              
00003934  4E75                    3415              RTS
00003936                          3416  * AND ---------------------------------------------------------------------
00003936                          3417  _And        
00003936  2604                    3418              MOVE.L  D4,D3   * reset D3
00003938  0803 0008               3419              BTST.L  #$08,D3 * if 8th bit is 1, <ea> * Dn -> <ea>
0000393C  6600 01C4               3420              BNE     _AndEA  * branch to AND to EA
00003940  4843                    3421              SWAP    D3
00003942  E18B                    3422              LSL.L   #8,D3
00003944  4EB8 1586               3423              JSR     BitTst2     * test size bits
00003948                          3424              * must be an AND instruction or error
00003948  0C06 0000               3425              CMPI.B  #%00,D6 * use d6 to check size
0000394C  6700 0016               3426              BEQ     _AndB   * AND.B
00003950  0C06 0001               3427              CMPI.B  #%01,D6
00003954  6700 0098               3428              BEQ     _AndW   * AND.W
00003958  0C06 0002               3429              CMPI.B  #%10,D6
0000395C  6700 011A               3430              BEQ     _AndL   * AND.L
00003960                          3431              
00003960  6000 0F00               3432              BRA     OPERROR
00003964                          3433              
00003964                          3434  * AND.B ----------------------            
00003964                          3435  _AndB       
00003964  1E3C 0001               3436              MOVE.B  #1,D7       * indicate a byte instruction
00003968  264A                    3437              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000396A  14FC 0041               3438              MOVE.B  #'A',(A2)+      * add AND.B to A2 String
0000396E  14FC 004E               3439              MOVE.B  #'N',(A2)+
00003972  14FC 0044               3440              MOVE.B  #'D',(A2)+
00003976  14FC 002E               3441              MOVE.B  #'.',(A2)+
0000397A  14FC 0042               3442              MOVE.B  #'B',(A2)+
0000397E  14FC 0020               3443              MOVE.B  #' ',(A2)+
00003982  14FC 0020               3444              MOVE.B  #' ',(A2)+
00003986  14FC 0020               3445              MOVE.B  #' ',(A2)+
0000398A  14FC 0020               3446              MOVE.B  #' ',(A2)+
0000398E  14FC 0020               3447              MOVE.B  #' ',(A2)+
00003992                          3448              * get EA
00003992  4EB8 163C               3449              JSR     getMode
00003996  0C06 0001               3450              CMPI.B  #%001,D6    * source cannot be An
0000399A  6700 0EC6               3451              BEQ     OPERROR
0000399E  E74E                    3452              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
000039A0  1A06                    3453              MOVE.B  D6,D5       * hold destination mode bits in d5
000039A2  E78B                    3454              LSL.L   #3,D3       * shift destination mode bits out
000039A4  4EB8 1564               3455              JSR     BitTst3     * test the destination register bits
000039A8  DA46                    3456              ADD.W   D6,D5       * add these to the mode bits
000039AA  0C05 003C               3457              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
000039AE  6700 0EB2               3458              BEQ     OPERROR     * immediate data, there is not allowed, error
000039B2                          3459              * no errors
000039B2  4EB8 163C               3460              JSR     getMode
000039B6  4DF9 000048D2           3461              LEA     eaTable,A6
000039BC  CCFC 0008               3462              MULU    #8,D6
000039C0  4EB6 6000               3463              JSR     (A6,D6)
000039C4                          3464              * check for error in EA
000039C4  0C07 0004               3465              CMPI.B  #4,D7
000039C8  6700 0E98               3466              BEQ     OPERROR
000039CC                          3467              * destination must be data register
000039CC  14FC 002C               3468              MOVE.B  #',',(A2)+
000039D0  14FC 0044               3469              MOVE.B  #'D',(A2)+
000039D4  2604                    3470              MOVE.L  D4,D3   * reset D3
000039D6  4843                    3471              SWAP    D3
000039D8  E98B                    3472              LSL.L   #4,D3   * shift out opcode
000039DA  4EB8 1564               3473              JSR     BitTst3 * get data register number
000039DE  CCFC 0008               3474              MULU    #8,D6   * multiply for offset
000039E2  4DF9 00004A72           3475              LEA     numTable,A6 * load num table
000039E8  4EB6 6000               3476              JSR     (A6,D6)     * get number from table and print
000039EC                          3477  
000039EC  4E75                    3478              RTS
000039EE                          3479              
000039EE                          3480  * AND.W ----------------------
000039EE                          3481  _AndW       
000039EE  1E3C 0002               3482              MOVE.B  #2,D7       * indicate a word instruction
000039F2  264A                    3483              MOVEA.L A2,A3       * copy current address of A2 string to A3
000039F4  14FC 0041               3484              MOVE.B  #'A',(A2)+      * add AND.W to A2 String
000039F8  14FC 004E               3485              MOVE.B  #'N',(A2)+
000039FC  14FC 0044               3486              MOVE.B  #'D',(A2)+
00003A00  14FC 002E               3487              MOVE.B  #'.',(A2)+
00003A04  14FC 0057               3488              MOVE.B  #'W',(A2)+
00003A08  14FC 0020               3489              MOVE.B  #' ',(A2)+
00003A0C  14FC 0020               3490              MOVE.B  #' ',(A2)+
00003A10  14FC 0020               3491              MOVE.B  #' ',(A2)+
00003A14  14FC 0020               3492              MOVE.B  #' ',(A2)+
00003A18  14FC 0020               3493              MOVE.B  #' ',(A2)+
00003A1C                          3494              * get EA
00003A1C  4EB8 163C               3495              JSR     getMode
00003A20  0C06 0001               3496              CMPI.B  #%001,D6    * source cannot be An
00003A24  6700 0E3C               3497              BEQ     OPERROR
00003A28  E74E                    3498              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003A2A  1A06                    3499              MOVE.B  D6,D5       * hold destination mode bits in d5
00003A2C  E78B                    3500              LSL.L   #3,D3       * shift destination mode bits out
00003A2E  4EB8 1564               3501              JSR     BitTst3     * test the destination register bits
00003A32  DA46                    3502              ADD.W   D6,D5       * add these to the mode bits
00003A34  0C05 003C               3503              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003A38  6700 0E28               3504              BEQ     OPERROR     * immediate data, there is not allowed, error
00003A3C                          3505              * no errors
00003A3C  4EB8 163C               3506              JSR     getMode
00003A40  4DF9 000048D2           3507              LEA     eaTable,A6
00003A46  CCFC 0008               3508              MULU    #8,D6
00003A4A  4EB6 6000               3509              JSR     (A6,D6)
00003A4E                          3510              * check for error in EA
00003A4E  0C07 0004               3511              CMPI.B  #4,D7
00003A52  6700 0E0E               3512              BEQ     OPERROR
00003A56                          3513              * destination must be data register
00003A56  14FC 002C               3514              MOVE.B  #',',(A2)+
00003A5A  14FC 0044               3515              MOVE.B  #'D',(A2)+
00003A5E  2604                    3516              MOVE.L  D4,D3   * reset D3
00003A60  4843                    3517              SWAP    D3
00003A62  E98B                    3518              LSL.L   #4,D3   * shift out opcode
00003A64  4EB8 1564               3519              JSR     BitTst3 * get data register number
00003A68  CCFC 0008               3520              MULU    #8,D6   * multiply for offset
00003A6C  4DF9 00004A72           3521              LEA     numTable,A6 * load num table
00003A72  4EB6 6000               3522              JSR     (A6,D6)     * get number from table and print
00003A76                          3523  
00003A76  4E75                    3524              RTS
00003A78                          3525              
00003A78                          3526  * AND.L ----------------------
00003A78                          3527  _AndL       
00003A78  1E3C 0003               3528              MOVE.B  #3,D7       * indicate a long instruction
00003A7C  264A                    3529              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003A7E  14FC 0041               3530              MOVE.B  #'A',(A2)+      * add AND.L to A2 String
00003A82  14FC 004E               3531              MOVE.B  #'N',(A2)+
00003A86  14FC 0044               3532              MOVE.B  #'D',(A2)+
00003A8A  14FC 002E               3533              MOVE.B  #'.',(A2)+
00003A8E  14FC 004C               3534              MOVE.B  #'L',(A2)+
00003A92  14FC 0020               3535              MOVE.B  #' ',(A2)+
00003A96  14FC 0020               3536              MOVE.B  #' ',(A2)+
00003A9A  14FC 0020               3537              MOVE.B  #' ',(A2)+
00003A9E  14FC 0020               3538              MOVE.B  #' ',(A2)+
00003AA2  14FC 0020               3539              MOVE.B  #' ',(A2)+
00003AA6                          3540              * get EA
00003AA6  4EB8 163C               3541              JSR     getMode
00003AAA  0C06 0001               3542              CMPI.B  #%001,D6    * source cannot be An
00003AAE  6700 0DB2               3543              BEQ     OPERROR
00003AB2  E74E                    3544              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003AB4  1A06                    3545              MOVE.B  D6,D5       * hold destination mode bits in d5
00003AB6  E78B                    3546              LSL.L   #3,D3       * shift destination mode bits out
00003AB8  4EB8 1564               3547              JSR     BitTst3     * test the destination register bits
00003ABC  DA46                    3548              ADD.W   D6,D5       * add these to the mode bits
00003ABE  0C05 003C               3549              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003AC2  6700 0D9E               3550              BEQ     OPERROR     * immediate data, there is not allowed, error
00003AC6                          3551              * no errors
00003AC6  4EB8 163C               3552              JSR     getMode
00003ACA  4DF9 000048D2           3553              LEA     eaTable,A6
00003AD0  CCFC 0008               3554              MULU    #8,D6
00003AD4  4EB6 6000               3555              JSR     (A6,D6)
00003AD8                          3556              * check for error in EA
00003AD8  0C07 0004               3557              CMPI.B  #4,D7
00003ADC  6700 0D84               3558              BEQ     OPERROR
00003AE0                          3559              * destination must be data register
00003AE0  14FC 002C               3560              MOVE.B  #',',(A2)+
00003AE4  14FC 0044               3561              MOVE.B  #'D',(A2)+
00003AE8  2604                    3562              MOVE.L  D4,D3   * reset D3
00003AEA  4843                    3563              SWAP    D3
00003AEC  E98B                    3564              LSL.L   #4,D3   * shift out opcode
00003AEE  4EB8 1564               3565              JSR     BitTst3 * get data register number
00003AF2  CCFC 0008               3566              MULU    #8,D6   * multiply for offset
00003AF6  4DF9 00004A72           3567              LEA     numTable,A6 * load num table
00003AFC  4EB6 6000               3568              JSR     (A6,D6)     * get number from table and print
00003B00                          3569  
00003B00  4E75                    3570              RTS
00003B02                          3571  
00003B02                          3572  _AndEA  
00003B02  2604                    3573              MOVE.L  D4,D3       * reset D3
00003B04  4843                    3574              SWAP    D3          * swap to front
00003B06  E18B                    3575              LSL.L   #8,D3       * shift out 8 bits so leading 2 bits are the size
00003B08  4EB8 1586               3576              JSR     BitTst2     * get size bits in D6
00003B0C  2604                    3577              MOVE.L  D4,D3       * reset D3
00003B0E  4843                    3578              SWAP    D3    
00003B10                          3579              * check for size
00003B10  0C06 0000               3580              CMPI.B  #%00,D6 
00003B14  6700 0016               3581              BEQ     _AndBea   * AND.B
00003B18  0C06 0001               3582              CMPI.B  #%01,D6
00003B1C  6700 0094               3583              BEQ     _AndWea   * AND.W
00003B20  0C06 0002               3584              CMPI.B  #%10,D6
00003B24  6700 0112               3585              BEQ     _AndLea   * AND.L
00003B28                          3586              
00003B28  6000 0D38               3587              BRA     OPERROR
00003B2C                          3588  
00003B2C                          3589  * AND.B to EA ----------------
00003B2C                          3590  _AndBea     
00003B2C  1E3C 0001               3591              MOVE.B  #1,D7       * indicate a word instruction
00003B30  264A                    3592              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003B32  14FC 0041               3593              MOVE.B  #'A',(A2)+      * add AND.L to A2 String
00003B36  14FC 004E               3594              MOVE.B  #'N',(A2)+
00003B3A  14FC 0044               3595              MOVE.B  #'D',(A2)+
00003B3E  14FC 002E               3596              MOVE.B  #'.',(A2)+
00003B42  14FC 004C               3597              MOVE.B  #'L',(A2)+
00003B46  14FC 0020               3598              MOVE.B  #' ',(A2)+
00003B4A  14FC 0020               3599              MOVE.B  #' ',(A2)+
00003B4E  14FC 0020               3600              MOVE.B  #' ',(A2)+
00003B52  14FC 0020               3601              MOVE.B  #' ',(A2)+
00003B56  14FC 0020               3602              MOVE.B  #' ',(A2)+
00003B5A  14FC 0044               3603              MOVE.B  #'D',(A2)+  * starting source must be data register
00003B5E  E98B                    3604              LSL.L   #4,D3   * shift out opcode
00003B60  4EB8 1564               3605              JSR     BitTst3 * get data register number
00003B64  CCFC 0008               3606              MULU    #8,D6   * multiply for offset
00003B68  4DF9 00004A72           3607              LEA     numTable,A6 * load num table
00003B6E  4EB6 6000               3608              JSR     (A6,D6)     * get number from table and print
00003B72  14FC 002C               3609              MOVE.B  #',',(A2)+
00003B76                          3610              
00003B76                          3611              * get EA mode and check for errors
00003B76  4EB8 163C               3612              JSR     getMode
00003B7A  0C06 0001               3613              CMPI.B  #%001,D6    * cant write to An
00003B7E  6700 0CE2               3614              BEQ     OPERROR
00003B82  E74E                    3615              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003B84  1A06                    3616              MOVE.B  D6,D5       * hold destination mode bits in d5
00003B86  E78B                    3617              LSL.L   #3,D3       * shift destination mode bits out
00003B88  4EB8 1564               3618              JSR     BitTst3     * test the destination register bits
00003B8C  DA46                    3619              ADD.W   D6,D5       * add these to the mode bits
00003B8E  0C05 003C               3620              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003B92  6700 0CCE               3621              BEQ     OPERROR     * immediate data, there is not allowed, error
00003B96                          3622              
00003B96                          3623              * no errors
00003B96  4EB8 163C               3624              JSR     getMode
00003B9A  4DF9 000048D2           3625              LEA     eaTable,A6
00003BA0  CCFC 0008               3626              MULU    #8,D6
00003BA4  4EB6 6000               3627              JSR     (A6,D6)
00003BA8                          3628              * check for error in EA
00003BA8  0C07 0004               3629              CMPI.B  #4,D7
00003BAC  6700 0CB4               3630              BEQ     OPERROR
00003BB0                          3631  
00003BB0  4E75                    3632              RTS
00003BB2                          3633              
00003BB2                          3634  * AND.W to EA ----------------
00003BB2                          3635  _AndWea     
00003BB2  1E3C 0002               3636              MOVE.B  #2,D7       * indicate a word instruction
00003BB6  264A                    3637              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003BB8  14FC 0041               3638              MOVE.B  #'A',(A2)+      * add AND.L to A2 String
00003BBC  14FC 004E               3639              MOVE.B  #'N',(A2)+
00003BC0  14FC 0044               3640              MOVE.B  #'D',(A2)+
00003BC4  14FC 002E               3641              MOVE.B  #'.',(A2)+
00003BC8  14FC 004C               3642              MOVE.B  #'L',(A2)+
00003BCC  14FC 0020               3643              MOVE.B  #' ',(A2)+
00003BD0  14FC 0020               3644              MOVE.B  #' ',(A2)+
00003BD4  14FC 0020               3645              MOVE.B  #' ',(A2)+
00003BD8  14FC 0020               3646              MOVE.B  #' ',(A2)+
00003BDC  14FC 0020               3647              MOVE.B  #' ',(A2)+
00003BE0  14FC 0044               3648              MOVE.B  #'D',(A2)+  * starting source must be data register
00003BE4  E98B                    3649              LSL.L   #4,D3   * shift out opcode
00003BE6  4EB8 1564               3650              JSR     BitTst3 * get data register number
00003BEA  CCFC 0008               3651              MULU    #8,D6   * multiply for offset
00003BEE  4DF9 00004A72           3652              LEA     numTable,A6 * load num table
00003BF4  4EB6 6000               3653              JSR     (A6,D6)     * get number from table and print
00003BF8  14FC 002C               3654              MOVE.B  #',',(A2)+
00003BFC                          3655              
00003BFC                          3656              * get EA mode and check for errors
00003BFC  4EB8 163C               3657              JSR     getMode
00003C00  0C06 0001               3658              CMPI.B  #%001,D6    * cant write to An
00003C04  6700 0C5C               3659              BEQ     OPERROR
00003C08  E74E                    3660              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003C0A  1A06                    3661              MOVE.B  D6,D5       * hold destination mode bits in d5
00003C0C  E78B                    3662              LSL.L   #3,D3       * shift destination mode bits out
00003C0E  4EB8 1564               3663              JSR     BitTst3     * test the destination register bits
00003C12  DA46                    3664              ADD.W   D6,D5       * add these to the mode bits
00003C14  0C05 003C               3665              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003C18  6700 0C48               3666              BEQ     OPERROR     * immediate data, there is not allowed, error
00003C1C                          3667              
00003C1C                          3668              * no errors
00003C1C  4EB8 163C               3669              JSR     getMode
00003C20  4DF9 000048D2           3670              LEA     eaTable,A6
00003C26  CCFC 0008               3671              MULU    #8,D6
00003C2A  4EB6 6000               3672              JSR     (A6,D6)
00003C2E                          3673              * check for error in EA
00003C2E  0C07 0004               3674              CMPI.B  #4,D7
00003C32  6700 0C2E               3675              BEQ     OPERROR
00003C36  4E75                    3676              RTS
00003C38                          3677              
00003C38                          3678  * AND.L to EA ----------------
00003C38                          3679  _AndLea     
00003C38  1E3C 0003               3680              MOVE.B  #3,D7       * indicate a long instruction
00003C3C  264A                    3681              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003C3E  14FC 0041               3682              MOVE.B  #'A',(A2)+      * add AND.L to A2 String
00003C42  14FC 004E               3683              MOVE.B  #'N',(A2)+
00003C46  14FC 0044               3684              MOVE.B  #'D',(A2)+
00003C4A  14FC 002E               3685              MOVE.B  #'.',(A2)+
00003C4E  14FC 004C               3686              MOVE.B  #'L',(A2)+
00003C52  14FC 0020               3687              MOVE.B  #' ',(A2)+
00003C56  14FC 0020               3688              MOVE.B  #' ',(A2)+
00003C5A  14FC 0020               3689              MOVE.B  #' ',(A2)+
00003C5E  14FC 0020               3690              MOVE.B  #' ',(A2)+
00003C62  14FC 0020               3691              MOVE.B  #' ',(A2)+
00003C66  14FC 0044               3692              MOVE.B  #'D',(A2)+  * starting source must be data register
00003C6A  E98B                    3693              LSL.L   #4,D3   * shift out opcode
00003C6C  4EB8 1564               3694              JSR     BitTst3 * get data register number
00003C70  CCFC 0008               3695              MULU    #8,D6   * multiply for offset
00003C74  4DF9 00004A72           3696              LEA     numTable,A6 * load num table
00003C7A  4EB6 6000               3697              JSR     (A6,D6)     * get number from table and print
00003C7E  14FC 002C               3698              MOVE.B  #',',(A2)+
00003C82                          3699              
00003C82                          3700              * get EA mode and check for errors
00003C82  4EB8 163C               3701              JSR     getMode
00003C86  0C06 0001               3702              CMPI.B  #%001,D6    * cant write to An
00003C8A  6700 0BD6               3703              BEQ     OPERROR
00003C8E  E74E                    3704              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003C90  1A06                    3705              MOVE.B  D6,D5       * hold destination mode bits in d5
00003C92  E78B                    3706              LSL.L   #3,D3       * shift destination mode bits out
00003C94  4EB8 1564               3707              JSR     BitTst3     * test the destination register bits
00003C98  DA46                    3708              ADD.W   D6,D5       * add these to the mode bits
00003C9A  0C05 003C               3709              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003C9E  6700 0BC2               3710              BEQ     OPERROR     * immediate data, there is not allowed, error
00003CA2                          3711              
00003CA2                          3712              * no errors
00003CA2  4EB8 163C               3713              JSR     getMode
00003CA6  4DF9 000048D2           3714              LEA     eaTable,A6
00003CAC  CCFC 0008               3715              MULU    #8,D6
00003CB0  4EB6 6000               3716              JSR     (A6,D6)
00003CB4                          3717              * check for error in EA
00003CB4  0C07 0004               3718              CMPI.B  #4,D7
00003CB8  6700 0BA8               3719              BEQ     OPERROR
00003CBC  4E75                    3720              RTS               
00003CBE                          3721  
00003CBE                          3722  * ADD, ADDA -------------------------------------------------------------------------
00003CBE                          3723  op1101      
00003CBE  4843                    3724              SWAP    D3
00003CC0  E18B                    3725              LSL.L   #8,D3   * shift out op code and next four bits
00003CC2  4EB8 1586               3726              JSR     BitTst2 * check next two bits for size/MUL instruction
00003CC6  2604                    3727              MOVE.L  D4,D3   * reset D3
00003CC8  0C06 0003               3728              CMPI.B  #%11,D6 * if bits 6-7 are 11, it is ADDA
00003CCC  6700 0380               3729              BEQ     _AddA
00003CD0                          3730              
00003CD0                          3731              * figure out direction of ADD
00003CD0  0803 0008               3732              BTST.L  #$08,D3 * if 8th bit is 1, <ea> * dn -> <ea>
00003CD4  6600 01BC               3733              BNE     _AddEA  * branch to add to EA
00003CD8                          3734              * it is basic ADD
00003CD8  0C06 0000               3735              CMPI.B  #%00,D6
00003CDC  6700 0016               3736              BEQ     _AddB
00003CE0  0C06 0001               3737              CMPI.B  #%01,D6
00003CE4  6700 0098               3738              BEQ     _AddW
00003CE8  0C06 0002               3739              CMPI.B  #%10,D6
00003CEC  6700 011A               3740              BEQ     _AddL
00003CF0                          3741              
00003CF0  6000 0B70               3742              BRA     OPERROR
00003CF4                          3743              
00003CF4                          3744  * ADD.B ----------------------
00003CF4                          3745  _AddB       
00003CF4  1E3C 0001               3746              MOVE.B  #1,D7       * indicate a byte instruction
00003CF8  264A                    3747              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003CFA  14FC 0041               3748              MOVE.B  #'A',(A2)+      * add ADD.B to A2 String
00003CFE  14FC 0044               3749              MOVE.B  #'D',(A2)+
00003D02  14FC 0044               3750              MOVE.B  #'D',(A2)+
00003D06  14FC 002E               3751              MOVE.B  #'.',(A2)+
00003D0A  14FC 0042               3752              MOVE.B  #'B',(A2)+
00003D0E  14FC 0020               3753              MOVE.B  #' ',(A2)+
00003D12  14FC 0020               3754              MOVE.B  #' ',(A2)+
00003D16  14FC 0020               3755              MOVE.B  #' ',(A2)+
00003D1A  14FC 0020               3756              MOVE.B  #' ',(A2)+
00003D1E  14FC 0020               3757              MOVE.B  #' ',(A2)+
00003D22                          3758              * get EA
00003D22  4EB8 163C               3759              JSR     getMode
00003D26  0C06 0001               3760              CMPI.B  #%001,D6    * source cannot be An
00003D2A  6700 0B36               3761              BEQ     OPERROR
00003D2E  E74E                    3762              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003D30  1A06                    3763              MOVE.B  D6,D5       * hold destination mode bits in d5
00003D32  E78B                    3764              LSL.L   #3,D3       * shift destination mode bits out
00003D34  4EB8 1564               3765              JSR     BitTst3     * test the destination register bits
00003D38  DA46                    3766              ADD.W   D6,D5       * add these to the mode bits
00003D3A  0C05 003C               3767              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003D3E  6700 0B22               3768              BEQ     OPERROR     * immediate data, there is not allowed, error
00003D42                          3769              * no errors
00003D42  4EB8 163C               3770              JSR     getMode
00003D46  4DF9 000048D2           3771              LEA     eaTable,A6
00003D4C  CCFC 0008               3772              MULU    #8,D6
00003D50  4EB6 6000               3773              JSR     (A6,D6)
00003D54                          3774              * check for error in EA
00003D54  0C07 0004               3775              CMPI.B  #4,D7
00003D58  6700 0B08               3776              BEQ     OPERROR
00003D5C                          3777              * destination must be data register
00003D5C  14FC 002C               3778              MOVE.B  #',',(A2)+
00003D60  14FC 0044               3779              MOVE.B  #'D',(A2)+
00003D64  2604                    3780              MOVE.L  D4,D3   * reset D3
00003D66  4843                    3781              SWAP    D3
00003D68  E98B                    3782              LSL.L   #4,D3   * shift out opcode
00003D6A  4EB8 1564               3783              JSR     BitTst3 * get data register number
00003D6E  CCFC 0008               3784              MULU    #8,D6   * multiply for offset
00003D72  4DF9 00004A72           3785              LEA     numTable,A6 * load num table
00003D78  4EB6 6000               3786              JSR     (A6,D6)     * get number from table and print
00003D7C  4E75                    3787              RTS 
00003D7E                          3788              
00003D7E                          3789  * ADD.W ----------------------
00003D7E                          3790  _AddW       
00003D7E  1E3C 0002               3791              MOVE.B  #2,D7       * indicate a word instruction
00003D82  264A                    3792              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003D84  14FC 0041               3793              MOVE.B  #'A',(A2)+      * add ADD.W to A2 String
00003D88  14FC 0044               3794              MOVE.B  #'D',(A2)+
00003D8C  14FC 0044               3795              MOVE.B  #'D',(A2)+
00003D90  14FC 002E               3796              MOVE.B  #'.',(A2)+
00003D94  14FC 0057               3797              MOVE.B  #'W',(A2)+
00003D98  14FC 0020               3798              MOVE.B  #' ',(A2)+
00003D9C  14FC 0020               3799              MOVE.B  #' ',(A2)+
00003DA0  14FC 0020               3800              MOVE.B  #' ',(A2)+
00003DA4  14FC 0020               3801              MOVE.B  #' ',(A2)+
00003DA8  14FC 0020               3802              MOVE.B  #' ',(A2)+
00003DAC                          3803              * get EA
00003DAC  4EB8 163C               3804              JSR     getMode
00003DB0  0C06 0001               3805              CMPI.B  #%001,D6    * source cannot be An
00003DB4  6700 0AAC               3806              BEQ     OPERROR
00003DB8  E74E                    3807              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003DBA  1A06                    3808              MOVE.B  D6,D5       * hold destination mode bits in d5
00003DBC  E78B                    3809              LSL.L   #3,D3       * shift destination mode bits out
00003DBE  4EB8 1564               3810              JSR     BitTst3     * test the destination register bits
00003DC2  DA46                    3811              ADD.W   D6,D5       * add these to the mode bits
00003DC4  0C05 003C               3812              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003DC8  6700 0A98               3813              BEQ     OPERROR     * immediate data, there is not allowed, error
00003DCC                          3814              * no errors
00003DCC  4EB8 163C               3815              JSR     getMode
00003DD0  4DF9 000048D2           3816              LEA     eaTable,A6
00003DD6  CCFC 0008               3817              MULU    #8,D6
00003DDA  4EB6 6000               3818              JSR     (A6,D6)
00003DDE                          3819              * check for error in EA
00003DDE  0C07 0004               3820              CMPI.B  #4,D7
00003DE2  6700 0A7E               3821              BEQ     OPERROR
00003DE6                          3822              * destination must be data register
00003DE6  14FC 002C               3823              MOVE.B  #',',(A2)+
00003DEA  14FC 0044               3824              MOVE.B  #'D',(A2)+
00003DEE  2604                    3825              MOVE.L  D4,D3   * reset D3
00003DF0  4843                    3826              SWAP    D3
00003DF2  E98B                    3827              LSL.L   #4,D3   * shift out opcode
00003DF4  4EB8 1564               3828              JSR     BitTst3 * get data register number
00003DF8  CCFC 0008               3829              MULU    #8,D6   * multiply for offset
00003DFC  4DF9 00004A72           3830              LEA     numTable,A6 * load num table
00003E02  4EB6 6000               3831              JSR     (A6,D6)     * get number from table and print
00003E06  4E75                    3832              RTS 
00003E08                          3833  
00003E08                          3834  * ADD.L ----------------------
00003E08                          3835  _AddL       
00003E08  1E3C 0003               3836              MOVE.B  #3,D7       * indicate a long instruction
00003E0C  264A                    3837              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003E0E  14FC 0041               3838              MOVE.B  #'A',(A2)+      * add ADD.L to A2 String
00003E12  14FC 0044               3839              MOVE.B  #'D',(A2)+
00003E16  14FC 0044               3840              MOVE.B  #'D',(A2)+
00003E1A  14FC 002E               3841              MOVE.B  #'.',(A2)+
00003E1E  14FC 004C               3842              MOVE.B  #'L',(A2)+
00003E22  14FC 0020               3843              MOVE.B  #' ',(A2)+
00003E26  14FC 0020               3844              MOVE.B  #' ',(A2)+
00003E2A  14FC 0020               3845              MOVE.B  #' ',(A2)+
00003E2E  14FC 0020               3846              MOVE.B  #' ',(A2)+
00003E32  14FC 0020               3847              MOVE.B  #' ',(A2)+
00003E36                          3848              * get EA
00003E36  4EB8 163C               3849              JSR     getMode
00003E3A  0C06 0001               3850              CMPI.B  #%001,D6    * source cannot be An
00003E3E  6700 0A22               3851              BEQ     OPERROR
00003E42  E74E                    3852              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003E44  1A06                    3853              MOVE.B  D6,D5       * hold destination mode bits in d5
00003E46  E78B                    3854              LSL.L   #3,D3       * shift destination mode bits out
00003E48  4EB8 1564               3855              JSR     BitTst3     * test the destination register bits
00003E4C  DA46                    3856              ADD.W   D6,D5       * add these to the mode bits
00003E4E  0C05 003C               3857              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003E52  6700 0A0E               3858              BEQ     OPERROR     * immediate data, there is not allowed, error
00003E56                          3859              * no errors
00003E56  4EB8 163C               3860              JSR     getMode
00003E5A  4DF9 000048D2           3861              LEA     eaTable,A6
00003E60  CCFC 0008               3862              MULU    #8,D6
00003E64  4EB6 6000               3863              JSR     (A6,D6)
00003E68                          3864              * check for error in EA
00003E68  0C07 0004               3865              CMPI.B  #4,D7
00003E6C  6700 09F4               3866              BEQ     OPERROR
00003E70                          3867              * destination must be data register
00003E70  14FC 002C               3868              MOVE.B  #',',(A2)+
00003E74  14FC 0044               3869              MOVE.B  #'D',(A2)+
00003E78  2604                    3870              MOVE.L  D4,D3   * reset D3
00003E7A  4843                    3871              SWAP    D3
00003E7C  E98B                    3872              LSL.L   #4,D3   * shift out opcode
00003E7E  4EB8 1564               3873              JSR     BitTst3 * get data register number
00003E82  CCFC 0008               3874              MULU    #8,D6   * multiply for offset
00003E86  4DF9 00004A72           3875              LEA     numTable,A6 * load num table
00003E8C  4EB6 6000               3876              JSR     (A6,D6)     * get number from table and print
00003E90  4E75                    3877              RTS 
00003E92                          3878        
00003E92                          3879  
00003E92                          3880  _AddEA      
00003E92  2604                    3881              MOVE.L  D4,D3       * reset D3
00003E94  4843                    3882              SWAP    D3          * swap to front
00003E96  E18B                    3883              LSL.L   #8,D3       * shift out 8 bits so leading 2 bits are the size
00003E98  4EB8 1586               3884              JSR     BitTst2     * get size bits in D6
00003E9C  2604                    3885              MOVE.L  D4,D3       * reset D3
00003E9E  4843                    3886              SWAP    D3  
00003EA0  0C06 0000               3887              CMPI.B  #%00,D6
00003EA4  6700 0016               3888              BEQ     _AddBea
00003EA8  0C06 0001               3889              CMPI.B  #%01,D6
00003EAC  6700 0094               3890              BEQ     _AddWea
00003EB0  0C06 0002               3891              CMPI.B  #%10,D6
00003EB4  6700 0112               3892              BEQ     _AddLea
00003EB8                          3893              
00003EB8  6000 09A8               3894              BRA     OPERROR
00003EBC                          3895              
00003EBC                          3896  * ADD.B to EA ----------------            
00003EBC                          3897  _AddBea     
00003EBC  1E3C 0001               3898              MOVE.B  #1,D7       * indicate a byte instruction
00003EC0  264A                    3899              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003EC2  14FC 0041               3900              MOVE.B  #'A',(A2)+      * add ADD.B to A2 String
00003EC6  14FC 0044               3901              MOVE.B  #'D',(A2)+
00003ECA  14FC 0044               3902              MOVE.B  #'D',(A2)+
00003ECE  14FC 002E               3903              MOVE.B  #'.',(A2)+
00003ED2  14FC 0042               3904              MOVE.B  #'B',(A2)+
00003ED6  14FC 0020               3905              MOVE.B  #' ',(A2)+
00003EDA  14FC 0020               3906              MOVE.B  #' ',(A2)+
00003EDE  14FC 0020               3907              MOVE.B  #' ',(A2)+
00003EE2  14FC 0020               3908              MOVE.B  #' ',(A2)+
00003EE6  14FC 0020               3909              MOVE.B  #' ',(A2)+
00003EEA  14FC 0044               3910              MOVE.B  #'D',(A2)+  * starting source must be data register
00003EEE  E98B                    3911              LSL.L   #4,D3   * shift out opcode
00003EF0  4EB8 1564               3912              JSR     BitTst3 * get data register number
00003EF4  CCFC 0008               3913              MULU    #8,D6   * multiply for offset
00003EF8  4DF9 00004A72           3914              LEA     numTable,A6 * load num table
00003EFE  4EB6 6000               3915              JSR     (A6,D6)     * get number from table and print
00003F02  14FC 002C               3916              MOVE.B  #',',(A2)+
00003F06                          3917              
00003F06                          3918              * get EA mode and check for errors
00003F06  4EB8 163C               3919              JSR     getMode
00003F0A  0C06 0001               3920              CMPI.B  #%001,D6    * cant write to An
00003F0E  6700 0952               3921              BEQ     OPERROR
00003F12  E74E                    3922              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003F14  1A06                    3923              MOVE.B  D6,D5       * hold destination mode bits in d5
00003F16  E78B                    3924              LSL.L   #3,D3       * shift destination mode bits out
00003F18  4EB8 1564               3925              JSR     BitTst3     * test the destination register bits
00003F1C  DA46                    3926              ADD.W   D6,D5       * add these to the mode bits
00003F1E  0C05 003C               3927              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003F22  6700 093E               3928              BEQ     OPERROR     * immediate data, there is not allowed, error
00003F26                          3929              
00003F26                          3930              * no errors
00003F26  4EB8 163C               3931              JSR     getMode
00003F2A  4DF9 000048D2           3932              LEA     eaTable,A6
00003F30  CCFC 0008               3933              MULU    #8,D6
00003F34  4EB6 6000               3934              JSR     (A6,D6)
00003F38                          3935              * check for error in EA
00003F38  0C07 0004               3936              CMPI.B  #4,D7
00003F3C  6700 0924               3937              BEQ     OPERROR
00003F40  4E75                    3938              RTS
00003F42                          3939              
00003F42                          3940  * ADD.W to EA ----------------
00003F42                          3941  _AddWea     
00003F42  1E3C 0002               3942              MOVE.B  #2,D7       * indicate a long instruction
00003F46  264A                    3943              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003F48  14FC 0041               3944              MOVE.B  #'A',(A2)+      * add ADD.W to A2 String
00003F4C  14FC 0044               3945              MOVE.B  #'D',(A2)+
00003F50  14FC 0044               3946              MOVE.B  #'D',(A2)+
00003F54  14FC 002E               3947              MOVE.B  #'.',(A2)+
00003F58  14FC 0057               3948              MOVE.B  #'W',(A2)+
00003F5C  14FC 0020               3949              MOVE.B  #' ',(A2)+
00003F60  14FC 0020               3950              MOVE.B  #' ',(A2)+
00003F64  14FC 0020               3951              MOVE.B  #' ',(A2)+
00003F68  14FC 0020               3952              MOVE.B  #' ',(A2)+
00003F6C  14FC 0020               3953              MOVE.B  #' ',(A2)+
00003F70  14FC 0044               3954              MOVE.B  #'D',(A2)+  * starting source must be data register
00003F74  E98B                    3955              LSL.L   #4,D3   * shift out opcode
00003F76  4EB8 1564               3956              JSR     BitTst3 * get data register number
00003F7A  CCFC 0008               3957              MULU    #8,D6   * multiply for offset
00003F7E  4DF9 00004A72           3958              LEA     numTable,A6 * load num table
00003F84  4EB6 6000               3959              JSR     (A6,D6)     * get number from table and print
00003F88  14FC 002C               3960              MOVE.B  #',',(A2)+
00003F8C                          3961              
00003F8C                          3962              * get EA mode and check for errors
00003F8C  4EB8 163C               3963              JSR     getMode
00003F90  0C06 0001               3964              CMPI.B  #%001,D6    * cant write to An
00003F94  6700 08CC               3965              BEQ     OPERROR
00003F98  E74E                    3966              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00003F9A  1A06                    3967              MOVE.B  D6,D5       * hold destination mode bits in d5
00003F9C  E78B                    3968              LSL.L   #3,D3       * shift destination mode bits out
00003F9E  4EB8 1564               3969              JSR     BitTst3     * test the destination register bits
00003FA2  DA46                    3970              ADD.W   D6,D5       * add these to the mode bits
00003FA4  0C05 003C               3971              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
00003FA8  6700 08B8               3972              BEQ     OPERROR     * immediate data, there is not allowed, error
00003FAC                          3973              
00003FAC                          3974              * no errors
00003FAC  4EB8 163C               3975              JSR     getMode
00003FB0  4DF9 000048D2           3976              LEA     eaTable,A6
00003FB6  CCFC 0008               3977              MULU    #8,D6
00003FBA  4EB6 6000               3978              JSR     (A6,D6)
00003FBE                          3979              * check for error in EA
00003FBE  0C07 0004               3980              CMPI.B  #4,D7
00003FC2  6700 089E               3981              BEQ     OPERROR
00003FC6  4E75                    3982              RTS
00003FC8                          3983              
00003FC8                          3984  * ADD.L to EA ----------------
00003FC8                          3985  _AddLea     
00003FC8  1E3C 0003               3986              MOVE.B  #3,D7       * indicate a long instruction
00003FCC  264A                    3987              MOVEA.L A2,A3       * copy current address of A2 string to A3
00003FCE  14FC 0041               3988              MOVE.B  #'A',(A2)+      * add ADD.L to A2 String
00003FD2  14FC 0044               3989              MOVE.B  #'D',(A2)+
00003FD6  14FC 0044               3990              MOVE.B  #'D',(A2)+
00003FDA  14FC 002E               3991              MOVE.B  #'.',(A2)+
00003FDE  14FC 004C               3992              MOVE.B  #'L',(A2)+
00003FE2  14FC 0020               3993              MOVE.B  #' ',(A2)+
00003FE6  14FC 0020               3994              MOVE.B  #' ',(A2)+
00003FEA  14FC 0020               3995              MOVE.B  #' ',(A2)+
00003FEE  14FC 0020               3996              MOVE.B  #' ',(A2)+
00003FF2  14FC 0020               3997              MOVE.B  #' ',(A2)+
00003FF6  14FC 0044               3998              MOVE.B  #'D',(A2)+  * starting source must be data register
00003FFA  E98B                    3999              LSL.L   #4,D3   * shift out opcode
00003FFC  4EB8 1564               4000              JSR     BitTst3 * get data register number
00004000  CCFC 0008               4001              MULU    #8,D6   * multiply for offset
00004004  4DF9 00004A72           4002              LEA     numTable,A6 * load num table
0000400A  4EB6 6000               4003              JSR     (A6,D6)     * get number from table and print
0000400E  14FC 002C               4004              MOVE.B  #',',(A2)+
00004012                          4005              
00004012                          4006              * get EA mode and check for errors
00004012  4EB8 163C               4007              JSR     getMode
00004016  0C06 0001               4008              CMPI.B  #%001,D6    * cant write to An
0000401A  6700 0846               4009              BEQ     OPERROR
0000401E  E74E                    4010              LSL.W   #3,D6       * shift bits in D6 to make room for destination register
00004020  1A06                    4011              MOVE.B  D6,D5       * hold destination mode bits in d5
00004022  E78B                    4012              LSL.L   #3,D3       * shift destination mode bits out
00004024  4EB8 1564               4013              JSR     BitTst3     * test the destination register bits
00004028  DA46                    4014              ADD.W   D6,D5       * add these to the mode bits
0000402A  0C05 003C               4015              CMPI.B  #%111100,D5 * if we encounter an immediate/absolute mode with
0000402E  6700 0832               4016              BEQ     OPERROR     * immediate data, there is not allowed, error
00004032                          4017              
00004032                          4018              * no errors
00004032  4EB8 163C               4019              JSR     getMode
00004036  4DF9 000048D2           4020              LEA     eaTable,A6
0000403C  CCFC 0008               4021              MULU    #8,D6
00004040  4EB6 6000               4022              JSR     (A6,D6)
00004044                          4023              * check for error in EA
00004044  0C07 0004               4024              CMPI.B  #4,D7
00004048  6700 0818               4025              BEQ     OPERROR
0000404C  4E75                    4026              RTS
0000404E                          4027              
0000404E                          4028  * ADDA -------------------------------------------------------------------            
0000404E  0803 0008               4029  _AddA       BTST.L  #$08,D3     * check the size bit of ADDA
00004052  6700 006C               4030              BEQ     _AddAw      * if 0, go to ADDA.W
00004056                          4031              
00004056                          4032              * proceed as if ADDA.L
00004056                          4033  * ADDA.L ---------------------
00004056  1E3C 0003               4034              MOVE.B  #3,D7       * indicate a long instruction
0000405A  264A                    4035              MOVEA.L A2,A3       * copy current address of A2 string to A3
0000405C  14FC 0041               4036              MOVE.B  #'A',(A2)+      * add ADDA.L to A2 String
00004060  14FC 0044               4037              MOVE.B  #'D',(A2)+
00004064  14FC 0044               4038              MOVE.B  #'D',(A2)+
00004068  14FC 0041               4039              MOVE.B  #'A',(A2)+
0000406C  14FC 002E               4040              MOVE.B  #'.',(A2)+
00004070  14FC 004C               4041              MOVE.B  #'L',(A2)+
00004074  14FC 0020               4042              MOVE.B  #' ',(A2)+
00004078  14FC 0020               4043              MOVE.B  #' ',(A2)+
0000407C  14FC 0020               4044              MOVE.B  #' ',(A2)+
00004080  14FC 0020               4045              MOVE.B  #' ',(A2)+
00004084                          4046              *get EA
00004084  4EB8 163C               4047              JSR     getMode
00004088  4DF9 000048D2           4048              LEA     eaTable,A6
0000408E  CCFC 0008               4049              MULU    #8,D6
00004092  4EB6 6000               4050              JSR     (A6,D6)
00004096                          4051              * check for error in EA
00004096  0C07 0004               4052              CMPI.B  #4,D7
0000409A  6700 07C6               4053              BEQ     OPERROR
0000409E                          4054              * destination must be address register
0000409E  14FC 002C               4055              MOVE.B  #',',(A2)+
000040A2  14FC 0041               4056              MOVE.B  #'A',(A2)+
000040A6  2604                    4057              MOVE.L  D4,D3   * reset D3
000040A8  4843                    4058              SWAP    D3
000040AA  E98B                    4059              LSL.L   #4,D3   * shift out opcode
000040AC  4EB8 1564               4060              JSR     BitTst3 * get data register number
000040B0  CCFC 0008               4061              MULU    #8,D6   * multiply for offset
000040B4  4DF9 00004A72           4062              LEA     numTable,A6 * load num table
000040BA  4EB6 6000               4063              JSR     (A6,D6)     * get number from table and print
000040BE  4E75                    4064              RTS
000040C0                          4065              
000040C0                          4066  * ADDA.W ---------------------    
000040C0                          4067  _AddAw      
000040C0  1E3C 0002               4068              MOVE.B  #2,D7       * indicate a word instruction
000040C4  264A                    4069              MOVEA.L A2,A3       * copy current address of A2 string to A3
000040C6  14FC 0041               4070              MOVE.B  #'A',(A2)+      * add ADDA.W to A2 String
000040CA  14FC 0044               4071              MOVE.B  #'D',(A2)+
000040CE  14FC 0044               4072              MOVE.B  #'D',(A2)+
000040D2  14FC 0041               4073              MOVE.B  #'A',(A2)+
000040D6  14FC 002E               4074              MOVE.B  #'.',(A2)+
000040DA  14FC 0057               4075              MOVE.B  #'W',(A2)+
000040DE  14FC 0020               4076              MOVE.B  #' ',(A2)+
000040E2  14FC 0020               4077              MOVE.B  #' ',(A2)+
000040E6  14FC 0020               4078              MOVE.B  #' ',(A2)+
000040EA  14FC 0020               4079              MOVE.B  #' ',(A2)+
000040EE                          4080              *get EA
000040EE  4EB8 163C               4081              JSR     getMode
000040F2  4DF9 000048D2           4082              LEA     eaTable,A6
000040F8  CCFC 0008               4083              MULU    #8,D6
000040FC  4EB6 6000               4084              JSR     (A6,D6)
00004100                          4085              * check for error in EA
00004100  0C07 0004               4086              CMPI.B  #4,D7
00004104  6700 075C               4087              BEQ     OPERROR
00004108                          4088              * destination must be address register
00004108  14FC 002C               4089              MOVE.B  #',',(A2)+
0000410C  14FC 0041               4090              MOVE.B  #'A',(A2)+
00004110  2604                    4091              MOVE.L  D4,D3   * reset D3
00004112  4843                    4092              SWAP    D3
00004114  E98B                    4093              LSL.L   #4,D3   * shift out opcode
00004116  4EB8 1564               4094              JSR     BitTst3 * get data register number
0000411A  CCFC 0008               4095              MULU    #8,D6   * multiply for offset
0000411E  4DF9 00004A72           4096              LEA     numTable,A6 * load num table
00004124  4EB6 6000               4097              JSR     (A6,D6)     * get number from table and print
00004128  4E75                    4098              RTS
0000412A                          4099              
0000412A                          4100  * LSL, LSR, ASL, ASR, ROL, ROR, ROXL, ROXR ---------------------------------------            
0000412A                          4101  op1110
0000412A  4EB8 159E               4102              JSR     getSize     * get size bits
0000412E  0C06 0003               4103              CMPI.B  #%11,D6
00004132  6600 01CC               4104              BNE     _ShiftReg   * if the size isnt 11, it is a reg shift
00004136                          4105              * it is a mem shift
00004136                          4106              * determine type of shift
00004136  EB8B                    4107              LSL.L   #5,D3
00004138  4EB8 1586               4108              JSR     BitTst2
0000413C  0C06 0000               4109              CMPI.B  #%00,D6
00004140  6700 0072               4110              BEQ     _As     * arithmetic shift
00004144  0C06 0001               4111              CMPI.B  #%01,D6
00004148  6700 00CA               4112              BEQ     _Ls     * logical shift
0000414C  0C06 0002               4113              CMPI.B  #%10,D6
00004150  6700 0122               4114              BEQ     _Rox    * roll extend
00004154                          4115              * proceed as if it is a roll
00004154  0803 001D               4116              BTST.L  #$1D,D3 * test the 8th bit of the instruction
00004158  6700 002E               4117              BEQ     _Ror    * if 0, it is a roll right
0000415C                          4118              
0000415C                          4119  * ROL ------------------------
0000415C                          4120              * it is a ROL instruction
0000415C  14FC 0052               4121              MOVE.B  #'R',(A2)+ * add "ROL" to A2 string
00004160  14FC 004F               4122              MOVE.B  #'O',(A2)+
00004164  14FC 004C               4123              MOVE.B  #'L',(A2)+
00004168  14FC 0020               4124              MOVE.B  #' ',(A2)+
0000416C  14FC 0020               4125              MOVE.B  #' ',(A2)+
00004170  14FC 0020               4126              MOVE.B  #' ',(A2)+
00004174  14FC 0020               4127              MOVE.B  #' ',(A2)+
00004178  14FC 0020               4128              MOVE.B  #' ',(A2)+
0000417C  14FC 0020               4129              MOVE.B  #' ',(A2)+
00004180  14FC 0020               4130              MOVE.B  #' ',(A2)+
00004184  6000 0156               4131              BRA     _shftMemEA  * finish by branching to shift to mem EA
00004188                          4132              
00004188                          4133  * ROR ------------------------                       
00004188                          4134  _Ror        
00004188  14FC 0052               4135              MOVE.B  #'R',(A2)+ * add "ROR" to A2 string
0000418C  14FC 004F               4136              MOVE.B  #'O',(A2)+
00004190  14FC 0052               4137              MOVE.B  #'R',(A2)+
00004194  14FC 0020               4138              MOVE.B  #' ',(A2)+
00004198  14FC 0020               4139              MOVE.B  #' ',(A2)+
0000419C  14FC 0020               4140              MOVE.B  #' ',(A2)+
000041A0  14FC 0020               4141              MOVE.B  #' ',(A2)+
000041A4  14FC 0020               4142              MOVE.B  #' ',(A2)+
000041A8  14FC 0020               4143              MOVE.B  #' ',(A2)+
000041AC  14FC 0020               4144              MOVE.B  #' ',(A2)+
000041B0  6000 012A               4145              BRA     _shftMemEA * finish by branching to shift to mem EA
000041B4                          4146              
000041B4  0803 001D               4147  _As         BTST.L  #$1D,D3 * test the 8th bit of the instruction
000041B8  6700 002E               4148              BEQ     _Asr    * if 1, it is right
000041BC                          4149              * not so it is left
000041BC                          4150  * ASL ------------------------
000041BC  14FC 0041               4151              MOVE.B  #'A',(A2)+ * add "ASL" to A2 string
000041C0  14FC 0053               4152              MOVE.B  #'S',(A2)+
000041C4  14FC 004C               4153              MOVE.B  #'L',(A2)+
000041C8  14FC 0020               4154              MOVE.B  #' ',(A2)+
000041CC  14FC 0020               4155              MOVE.B  #' ',(A2)+
000041D0  14FC 0020               4156              MOVE.B  #' ',(A2)+
000041D4  14FC 0020               4157              MOVE.B  #' ',(A2)+
000041D8  14FC 0020               4158              MOVE.B  #' ',(A2)+
000041DC  14FC 0020               4159              MOVE.B  #' ',(A2)+
000041E0  14FC 0020               4160              MOVE.B  #' ',(A2)+
000041E4  6000 00F6               4161              BRA     _shftMemEA * finish by branching to shift to mem EA
000041E8                          4162              
000041E8                          4163  * ASR ------------------------            
000041E8  14FC 0041               4164  _Asr        MOVE.B  #'A',(A2)+ * add "ASR" to A2 string
000041EC  14FC 0053               4165              MOVE.B  #'S',(A2)+
000041F0  14FC 0052               4166              MOVE.B  #'R',(A2)+
000041F4  14FC 0020               4167              MOVE.B  #' ',(A2)+
000041F8  14FC 0020               4168              MOVE.B  #' ',(A2)+
000041FC  14FC 0020               4169              MOVE.B  #' ',(A2)+
00004200  14FC 0020               4170              MOVE.B  #' ',(A2)+
00004204  14FC 0020               4171              MOVE.B  #' ',(A2)+
00004208  14FC 0020               4172              MOVE.B  #' ',(A2)+
0000420C  14FC 0020               4173              MOVE.B  #' ',(A2)+
00004210  6000 00CA               4174              BRA     _shftMemEA * finish by branching to shift to mem EA
00004214                          4175              
00004214                          4176              
00004214  0803 001D               4177  _Ls         BTST.L  #$1D,D3 * test the 8th bit of the instruction
00004218  6700 002E               4178              BEQ     _Lsr    * if 1, it is right
0000421C                          4179              * not so it is left
0000421C                          4180  * LSL ------------------------
0000421C  14FC 004C               4181              MOVE.B  #'L',(A2)+ * add "LSL" to A2 string
00004220  14FC 0053               4182              MOVE.B  #'S',(A2)+
00004224  14FC 004C               4183              MOVE.B  #'L',(A2)+
00004228  14FC 0020               4184              MOVE.B  #' ',(A2)+
0000422C  14FC 0020               4185              MOVE.B  #' ',(A2)+
00004230  14FC 0020               4186              MOVE.B  #' ',(A2)+
00004234  14FC 0020               4187              MOVE.B  #' ',(A2)+
00004238  14FC 0020               4188              MOVE.B  #' ',(A2)+
0000423C  14FC 0020               4189              MOVE.B  #' ',(A2)+
00004240  14FC 0020               4190              MOVE.B  #' ',(A2)+
00004244  6000 0096               4191              BRA     _shftMemEA * finish by branching to shift to mem EA
00004248                          4192              
00004248                          4193  * LSR ------------------------            
00004248  14FC 004C               4194  _Lsr        MOVE.B  #'L',(A2)+ * add "LSR" to A2 string
0000424C  14FC 0053               4195              MOVE.B  #'S',(A2)+
00004250  14FC 0052               4196              MOVE.B  #'R',(A2)+
00004254  14FC 0020               4197              MOVE.B  #' ',(A2)+
00004258  14FC 0020               4198              MOVE.B  #' ',(A2)+
0000425C  14FC 0020               4199              MOVE.B  #' ',(A2)+
00004260  14FC 0020               4200              MOVE.B  #' ',(A2)+
00004264  14FC 0020               4201              MOVE.B  #' ',(A2)+
00004268  14FC 0020               4202              MOVE.B  #' ',(A2)+
0000426C  14FC 0020               4203              MOVE.B  #' ',(A2)+
00004270  6000 006A               4204              BRA     _shftMemEA * finish by branching to shift to mem EA
00004274                          4205              
00004274                          4206  * ROXL -----------------------            
00004274  0803 001D               4207  _Rox        BTST.L  #$1D,D3 * test the 8th bit of the instruction
00004278  6700 0032               4208              BEQ     _Roxr   * if 1, it is right
0000427C                          4209              * not, so it is left
0000427C  14FC 0052               4210              MOVE.B  #'R',(A2)+ * add "ROXL" to A2 string
00004280  14FC 004F               4211              MOVE.B  #'O',(A2)+
00004284  14FC 0058               4212              MOVE.B  #'X',(A2)+
00004288  14FC 004C               4213              MOVE.B  #'L',(A2)+
0000428C  14FC 0020               4214              MOVE.B  #' ',(A2)+
00004290  14FC 0020               4215              MOVE.B  #' ',(A2)+
00004294  14FC 0020               4216              MOVE.B  #' ',(A2)+
00004298  14FC 0020               4217              MOVE.B  #' ',(A2)+
0000429C  14FC 0020               4218              MOVE.B  #' ',(A2)+
000042A0  14FC 0020               4219              MOVE.B  #' ',(A2)+
000042A4  14FC 0020               4220              MOVE.B  #' ',(A2)+
000042A8  6000 0032               4221              BRA     _shftMemEA * finish by branching to shift to mem EA
000042AC                          4222              
000042AC                          4223  * ROXR -----------------------           
000042AC  14FC 0052               4224  _Roxr       MOVE.B  #'R',(A2)+ * add "ROXR" to A2 string
000042B0  14FC 004F               4225              MOVE.B  #'O',(A2)+
000042B4  14FC 0058               4226              MOVE.B  #'X',(A2)+
000042B8  14FC 0052               4227              MOVE.B  #'R',(A2)+
000042BC  14FC 0020               4228              MOVE.B  #' ',(A2)+
000042C0  14FC 0020               4229              MOVE.B  #' ',(A2)+
000042C4  14FC 0020               4230              MOVE.B  #' ',(A2)+
000042C8  14FC 0020               4231              MOVE.B  #' ',(A2)+
000042CC  14FC 0020               4232              MOVE.B  #' ',(A2)+
000042D0  14FC 0020               4233              MOVE.B  #' ',(A2)+
000042D4  14FC 0020               4234              MOVE.B  #' ',(A2)+
000042D8  6000 0002               4235              BRA     _shftMemEA * finish by branching to shift to mem EA
000042DC                          4236              
000042DC                          4237  _shftMemEA  
000042DC  4EB8 163C               4238              JSR     getMode     * get the mode
000042E0  0C06 0001               4239              CMPI.B  #%001,D6    * cant be Dn, or An
000042E4  6F00 057C               4240              BLE     OPERROR     * branch to error
000042E8  4DF9 000048D2           4241              LEA     eaTable,A6   * load ea table
000042EE  CCFC 0008               4242              MULU    #8,D6       * multiply by 8 for table jump
000042F2  4EB6 6000               4243              JSR     (A6,D6)     * jump to ea
000042F6                          4244              * check for error in EA
000042F6  0C07 0004               4245              CMPI.B  #4,D7
000042FA  6700 0566               4246              BEQ     OPERROR
000042FE  4E75                    4247              RTS                 * return
00004300                          4248              
00004300                          4249  _ShiftReg   
00004300                          4250              * determine size of shift
00004300  0C06 0000               4251              CMPI.B  #%00,D6
00004304  6700 0012               4252              BEQ     _byteShift
00004308  0C06 0001               4253              CMPI.B  #%01,D6
0000430C  6700 01AC               4254              BEQ     _wordShift
00004310  0C06 0002               4255              CMPI.B  #%10,D6
00004314  6700 0346               4256              BEQ     _longShift
00004318                          4257              
00004318                          4258  _byteShift  
00004318                          4259              * determine type of shift
00004318  E18B                    4260              LSL.L   #8,D3       * shift out 
0000431A  E78B                    4261              LSL.L   #3,D3
0000431C  4EB8 1586               4262              JSR     BitTst2
00004320  2604                    4263              MOVE.L  D4,D3       * reset D3
00004322  0C06 0000               4264              CMPI.B  #%00,D6
00004326  6700 0072               4265              BEQ     _AsB        * arithmetic shift
0000432A  0C06 0001               4266              CMPI.B  #%01,D6
0000432E  6700 00CA               4267              BEQ     _LsB        * logical shift
00004332  0C06 0002               4268              CMPI.B  #%10,D6
00004336  6700 0122               4269              BEQ     _RoxB       * roll extend
0000433A                          4270              * roll 
0000433A                          4271              
0000433A  0803 0008               4272              BTST.L  #$08,D3 * test 8th bit for direction
0000433E  6700 002E               4273              BEQ     _RorB   * if bit is 0, it is right
00004342                          4274              * it is left
00004342                          4275  * ROL.B ----------------------
00004342  14FC 0052               4276              MOVE.B  #'R',(A2)+ * add "ROL.B" to A2 string
00004346  14FC 004F               4277              MOVE.B  #'O',(A2)+
0000434A  14FC 004C               4278              MOVE.B  #'L',(A2)+
0000434E  14FC 002E               4279              MOVE.B  #'.',(A2)+
00004352  14FC 0042               4280              MOVE.B  #'B',(A2)+
00004356  14FC 0020               4281              MOVE.B  #' ',(A2)+
0000435A  14FC 0020               4282              MOVE.B  #' ',(A2)+
0000435E  14FC 0020               4283              MOVE.B  #' ',(A2)+
00004362  14FC 0020               4284              MOVE.B  #' ',(A2)+
00004366  14FC 0020               4285              MOVE.B  #' ',(A2)+
0000436A  6000 0492               4286              BRA     _ShiftEA    * branch to shift EA to finish
0000436E                          4287              
0000436E                          4288  * ROR.B ----------------------            
0000436E  14FC 0052               4289  _RorB       MOVE.B  #'R',(A2)+ * add "ROR.B" to A2 string
00004372  14FC 004F               4290              MOVE.B  #'O',(A2)+
00004376  14FC 0052               4291              MOVE.B  #'R',(A2)+
0000437A  14FC 002E               4292              MOVE.B  #'.',(A2)+
0000437E  14FC 0042               4293              MOVE.B  #'B',(A2)+
00004382  14FC 0020               4294              MOVE.B  #' ',(A2)+
00004386  14FC 0020               4295              MOVE.B  #' ',(A2)+
0000438A  14FC 0020               4296              MOVE.B  #' ',(A2)+
0000438E  14FC 0020               4297              MOVE.B  #' ',(A2)+
00004392  14FC 0020               4298              MOVE.B  #' ',(A2)+
00004396  6000 0466               4299              BRA     _ShiftEA    * branch to shift EA to finish
0000439A                          4300  
0000439A  0803 0008               4301  _AsB        BTST.L  #$08,D3 * test 8th bit for direction
0000439E  6700 002E               4302              BEQ     _AsrB   * if bit is 0, it is right
000043A2                          4303              * it is left
000043A2                          4304  * ASL.B ----------------------
000043A2  14FC 0041               4305              MOVE.B  #'A',(A2)+ * add "ASL.B" to A2 string
000043A6  14FC 0053               4306              MOVE.B  #'S',(A2)+
000043AA  14FC 004C               4307              MOVE.B  #'L',(A2)+
000043AE  14FC 002E               4308              MOVE.B  #'.',(A2)+
000043B2  14FC 0042               4309              MOVE.B  #'B',(A2)+
000043B6  14FC 0020               4310              MOVE.B  #' ',(A2)+
000043BA  14FC 0020               4311              MOVE.B  #' ',(A2)+
000043BE  14FC 0020               4312              MOVE.B  #' ',(A2)+
000043C2  14FC 0020               4313              MOVE.B  #' ',(A2)+
000043C6  14FC 0020               4314              MOVE.B  #' ',(A2)+
000043CA  6000 0432               4315              BRA     _ShiftEA    * branch to shift EA to finish
000043CE                          4316  
000043CE                          4317  * ASR.B ----------------------
000043CE  14FC 0041               4318  _AsrB       MOVE.B  #'A',(A2)+ * add "ASR.B" to A2 string
000043D2  14FC 0053               4319              MOVE.B  #'S',(A2)+
000043D6  14FC 0052               4320              MOVE.B  #'R',(A2)+
000043DA  14FC 002E               4321              MOVE.B  #'.',(A2)+
000043DE  14FC 0042               4322              MOVE.B  #'B',(A2)+
000043E2  14FC 0020               4323              MOVE.B  #' ',(A2)+
000043E6  14FC 0020               4324              MOVE.B  #' ',(A2)+
000043EA  14FC 0020               4325              MOVE.B  #' ',(A2)+
000043EE  14FC 0020               4326              MOVE.B  #' ',(A2)+
000043F2  14FC 0020               4327              MOVE.B  #' ',(A2)+
000043F6  6000 0406               4328              BRA     _ShiftEA    * branch to shift EA to finish
000043FA                          4329  
000043FA                          4330              
000043FA  0803 0008               4331  _LsB        BTST.L  #$08,D3 * test 8th bit for direction
000043FE  6700 002E               4332              BEQ     _LsrB   * if bit is 0, it is right
00004402                          4333              * it is left
00004402                          4334  * LSL.B ----------------------
00004402  14FC 004C               4335              MOVE.B  #'L',(A2)+ * add "LSL.B" to A2 string
00004406  14FC 0053               4336              MOVE.B  #'S',(A2)+
0000440A  14FC 004C               4337              MOVE.B  #'L',(A2)+
0000440E  14FC 002E               4338              MOVE.B  #'.',(A2)+
00004412  14FC 0042               4339              MOVE.B  #'B',(A2)+
00004416  14FC 0020               4340              MOVE.B  #' ',(A2)+
0000441A  14FC 0020               4341              MOVE.B  #' ',(A2)+
0000441E  14FC 0020               4342              MOVE.B  #' ',(A2)+
00004422  14FC 0020               4343              MOVE.B  #' ',(A2)+
00004426  14FC 0020               4344              MOVE.B  #' ',(A2)+
0000442A  6000 03D2               4345              BRA     _ShiftEA    * branch to shift EA to finish
0000442E                          4346              
0000442E                          4347  * LSR.B ----------------------            
0000442E  14FC 004C               4348  _LsrB       MOVE.B  #'L',(A2)+ * add "LSR.B" to A2 string
00004432  14FC 0053               4349              MOVE.B  #'S',(A2)+
00004436  14FC 0052               4350              MOVE.B  #'R',(A2)+
0000443A  14FC 002E               4351              MOVE.B  #'.',(A2)+
0000443E  14FC 0042               4352              MOVE.B  #'B',(A2)+
00004442  14FC 0020               4353              MOVE.B  #' ',(A2)+
00004446  14FC 0020               4354              MOVE.B  #' ',(A2)+
0000444A  14FC 0020               4355              MOVE.B  #' ',(A2)+
0000444E  14FC 0020               4356              MOVE.B  #' ',(A2)+
00004452  14FC 0020               4357              MOVE.B  #' ',(A2)+
00004456  6000 03A6               4358              BRA     _ShiftEA    * branch to shift EA to finish
0000445A                          4359  
0000445A  0803 0008               4360  _RoxB       BTST.L  #$08,D3 * test 8th bit for direction
0000445E  6700 002E               4361              BEQ     _RoxrB  * if bit is 0, it is right
00004462                          4362              * it is left
00004462                          4363  * ROXL.B ----------------------
00004462  14FC 0052               4364              MOVE.B  #'R',(A2)+ * add "ROXL.B" to A2 string
00004466  14FC 004F               4365              MOVE.B  #'O',(A2)+
0000446A  14FC 0058               4366              MOVE.B  #'X',(A2)+
0000446E  14FC 004C               4367              MOVE.B  #'L',(A2)+
00004472  14FC 002E               4368              MOVE.B  #'.',(A2)+
00004476  14FC 0042               4369              MOVE.B  #'B',(A2)+
0000447A  14FC 0020               4370              MOVE.B  #' ',(A2)+
0000447E  14FC 0020               4371              MOVE.B  #' ',(A2)+
00004482  14FC 0020               4372              MOVE.B  #' ',(A2)+
00004486  14FC 0020               4373              MOVE.B  #' ',(A2)+
0000448A  6000 0372               4374              BRA     _ShiftEA    * branch to shift EA to finish
0000448E                          4375              
0000448E                          4376  * ROXR.B ---------------------            
0000448E  14FC 0052               4377  _RoxrB      MOVE.B  #'R',(A2)+ * add "ROXR.B" to A2 string
00004492  14FC 004F               4378              MOVE.B  #'O',(A2)+
00004496  14FC 0058               4379              MOVE.B  #'X',(A2)+
0000449A  14FC 0052               4380              MOVE.B  #'R',(A2)+
0000449E  14FC 002E               4381              MOVE.B  #'.',(A2)+
000044A2  14FC 0042               4382              MOVE.B  #'B',(A2)+
000044A6  14FC 0020               4383              MOVE.B  #' ',(A2)+
000044AA  14FC 0020               4384              MOVE.B  #' ',(A2)+
000044AE  14FC 0020               4385              MOVE.B  #' ',(A2)+
000044B2  14FC 0020               4386              MOVE.B  #' ',(A2)+
000044B6  6000 0346               4387              BRA     _ShiftEA    * branch to shift EA to finish
000044BA                          4388              
000044BA                          4389  
000044BA                          4390  _wordShift
000044BA                          4391              * determine type of shift
000044BA  E18B                    4392              LSL.L   #8,D3
000044BC  E78B                    4393              LSL.L   #3,D3
000044BE  4EB8 1586               4394              JSR     BitTst2
000044C2  2604                    4395              MOVE.L  D4,D3   * reset D3
000044C4  0C06 0000               4396              CMPI.B  #%00,D6
000044C8  6700 0072               4397              BEQ     _AsW    * arithmetic shift
000044CC  0C06 0001               4398              CMPI.B  #%01,D6
000044D0  6700 00CA               4399              BEQ     _LsW    * logical shift
000044D4  0C06 0002               4400              CMPI.B  #%10,D6
000044D8  6700 0122               4401              BEQ     _RoxW   * roll extend
000044DC                          4402              * roll
000044DC  0803 0008               4403              BTST.L  #$08,D3 * test 8th bit for direction
000044E0  6700 002E               4404              BEQ     _RorW   * if bit is 0, it is right
000044E4                          4405              * it is left
000044E4                          4406  * ROL.W ----------------------
000044E4  14FC 0052               4407              MOVE.B  #'R',(A2)+ * add "ROL.W" to A2 string
000044E8  14FC 004F               4408              MOVE.B  #'O',(A2)+
000044EC  14FC 004C               4409              MOVE.B  #'L',(A2)+
000044F0  14FC 002E               4410              MOVE.B  #'.',(A2)+
000044F4  14FC 0057               4411              MOVE.B  #'W',(A2)+
000044F8  14FC 0020               4412              MOVE.B  #' ',(A2)+
000044FC  14FC 0020               4413              MOVE.B  #' ',(A2)+
00004500  14FC 0020               4414              MOVE.B  #' ',(A2)+
00004504  14FC 0020               4415              MOVE.B  #' ',(A2)+
00004508  14FC 0020               4416              MOVE.B  #' ',(A2)+
0000450C  6000 02F0               4417              BRA     _ShiftEA    * branch to shift EA to finish
00004510                          4418              
00004510                          4419  * ROR.W ----------------------            
00004510  14FC 0052               4420  _RorW       MOVE.B  #'R',(A2)+ * add "ROR.W" to A2 string
00004514  14FC 004F               4421              MOVE.B  #'O',(A2)+
00004518  14FC 0052               4422              MOVE.B  #'R',(A2)+
0000451C  14FC 002E               4423              MOVE.B  #'.',(A2)+
00004520  14FC 0057               4424              MOVE.B  #'W',(A2)+
00004524  14FC 0020               4425              MOVE.B  #' ',(A2)+
00004528  14FC 0020               4426              MOVE.B  #' ',(A2)+
0000452C  14FC 0020               4427              MOVE.B  #' ',(A2)+
00004530  14FC 0020               4428              MOVE.B  #' ',(A2)+
00004534  14FC 0020               4429              MOVE.B  #' ',(A2)+
00004538  6000 02C4               4430              BRA     _ShiftEA    * branch to shift EA to finish
0000453C                          4431              
0000453C  0803 0008               4432  _AsW        BTST.L  #$08,D3 * test 8th bit for direction
00004540  6700 002E               4433              BEQ     _AsrW   * if bit is 0, it is right
00004544                          4434              * it is left
00004544                          4435  * ASL.W ----------------------
00004544  14FC 0041               4436              MOVE.B  #'A',(A2)+ * add "ASL.W" to A2 string
00004548  14FC 0053               4437              MOVE.B  #'S',(A2)+
0000454C  14FC 004C               4438              MOVE.B  #'L',(A2)+
00004550  14FC 002E               4439              MOVE.B  #'.',(A2)+
00004554  14FC 0057               4440              MOVE.B  #'W',(A2)+
00004558  14FC 0020               4441              MOVE.B  #' ',(A2)+
0000455C  14FC 0020               4442              MOVE.B  #' ',(A2)+
00004560  14FC 0020               4443              MOVE.B  #' ',(A2)+
00004564  14FC 0020               4444              MOVE.B  #' ',(A2)+
00004568  14FC 0020               4445              MOVE.B  #' ',(A2)+
0000456C  6000 0290               4446              BRA     _ShiftEA    * branch to shift EA to finish
00004570                          4447              
00004570                          4448  * ASR.W ----------------------            
00004570  14FC 0041               4449  _AsrW       MOVE.B  #'A',(A2)+ * add "ASR.W" to A2 string
00004574  14FC 0053               4450              MOVE.B  #'S',(A2)+
00004578  14FC 0052               4451              MOVE.B  #'R',(A2)+
0000457C  14FC 002E               4452              MOVE.B  #'.',(A2)+
00004580  14FC 0057               4453              MOVE.B  #'W',(A2)+
00004584  14FC 0020               4454              MOVE.B  #' ',(A2)+
00004588  14FC 0020               4455              MOVE.B  #' ',(A2)+
0000458C  14FC 0020               4456              MOVE.B  #' ',(A2)+
00004590  14FC 0020               4457              MOVE.B  #' ',(A2)+
00004594  14FC 0020               4458              MOVE.B  #' ',(A2)+
00004598  6000 0264               4459              BRA     _ShiftEA    * branch to shift EA to finish
0000459C                          4460  
0000459C  0803 0008               4461  _LsW        BTST.L  #$08,D3 * test 8th bit for direction
000045A0  6700 002E               4462              BEQ     _LsrW   * if bit is 0, it is right
000045A4                          4463              * it is left
000045A4                          4464  * LSL.W ----------------------
000045A4  14FC 004C               4465              MOVE.B  #'L',(A2)+ * add "LSL.W" to A2 string
000045A8  14FC 0053               4466              MOVE.B  #'S',(A2)+
000045AC  14FC 004C               4467              MOVE.B  #'L',(A2)+
000045B0  14FC 002E               4468              MOVE.B  #'.',(A2)+
000045B4  14FC 0057               4469              MOVE.B  #'W',(A2)+
000045B8  14FC 0020               4470              MOVE.B  #' ',(A2)+
000045BC  14FC 0020               4471              MOVE.B  #' ',(A2)+
000045C0  14FC 0020               4472              MOVE.B  #' ',(A2)+
000045C4  14FC 0020               4473              MOVE.B  #' ',(A2)+
000045C8  14FC 0020               4474              MOVE.B  #' ',(A2)+
000045CC  6000 0230               4475              BRA     _ShiftEA    * branch to shift EA to finish
000045D0                          4476              
000045D0                          4477  * LSR.W ----------------------            
000045D0  14FC 004C               4478  _LsrW       MOVE.B  #'L',(A2)+ * add "LSR.W" to A2 string
000045D4  14FC 0053               4479              MOVE.B  #'S',(A2)+
000045D8  14FC 0052               4480              MOVE.B  #'R',(A2)+
000045DC  14FC 002E               4481              MOVE.B  #'.',(A2)+
000045E0  14FC 0057               4482              MOVE.B  #'W',(A2)+
000045E4  14FC 0020               4483              MOVE.B  #' ',(A2)+
000045E8  14FC 0020               4484              MOVE.B  #' ',(A2)+
000045EC  14FC 0020               4485              MOVE.B  #' ',(A2)+
000045F0  14FC 0020               4486              MOVE.B  #' ',(A2)+
000045F4  14FC 0020               4487              MOVE.B  #' ',(A2)+
000045F8  6000 0204               4488              BRA     _ShiftEA    * branch to shift EA to finish
000045FC                          4489  
000045FC  0803 0008               4490  _RoxW       BTST.L  #$08,D3 * test 8th bit for direction
00004600  6700 002E               4491              BEQ     _RoxrW  * if bit is 0, it is right
00004604                          4492              * it is left
00004604                          4493  * ROXL.W ---------------------
00004604  14FC 0052               4494              MOVE.B  #'R',(A2)+ * add "ROXL.W" to A2 string
00004608  14FC 004F               4495              MOVE.B  #'O',(A2)+
0000460C  14FC 0058               4496              MOVE.B  #'X',(A2)+
00004610  14FC 004C               4497              MOVE.B  #'L',(A2)+
00004614  14FC 002E               4498              MOVE.B  #'.',(A2)+
00004618  14FC 0057               4499              MOVE.B  #'W',(A2)+
0000461C  14FC 0020               4500              MOVE.B  #' ',(A2)+
00004620  14FC 0020               4501              MOVE.B  #' ',(A2)+
00004624  14FC 0020               4502              MOVE.B  #' ',(A2)+
00004628  14FC 0020               4503              MOVE.B  #' ',(A2)+
0000462C  6000 01D0               4504              BRA     _ShiftEA    * branch to shift EA to finish
00004630                          4505              
00004630                          4506  * ROXR.W ---------------------            
00004630  14FC 0052               4507  _RoxrW      MOVE.B  #'R',(A2)+ * add "ROXR.W" to A2 string
00004634  14FC 004F               4508              MOVE.B  #'O',(A2)+
00004638  14FC 0058               4509              MOVE.B  #'X',(A2)+
0000463C  14FC 0052               4510              MOVE.B  #'R',(A2)+
00004640  14FC 002E               4511              MOVE.B  #'.',(A2)+
00004644  14FC 0057               4512              MOVE.B  #'W',(A2)+
00004648  14FC 0020               4513              MOVE.B  #' ',(A2)+
0000464C  14FC 0020               4514              MOVE.B  #' ',(A2)+
00004650  14FC 0020               4515              MOVE.B  #' ',(A2)+
00004654  14FC 0020               4516              MOVE.B  #' ',(A2)+
00004658  6000 01A4               4517              BRA     _ShiftEA    * branch to shift EA to finish
0000465C                          4518  
0000465C                          4519  _longShift
0000465C                          4520              * determine type of shift
0000465C  E18B                    4521              LSL.L   #8,D3
0000465E  E78B                    4522              LSL.L   #3,D3
00004660  4EB8 1586               4523              JSR     BitTst2
00004664  2604                    4524              MOVE.L  D4,D3       * reset D3
00004666  0C06 0000               4525              CMPI.B  #%00,D6
0000466A  6700 0072               4526              BEQ     _AsLong
0000466E  0C06 0001               4527              CMPI.B  #%01,D6
00004672  6700 00CA               4528              BEQ     _LsLong
00004676  0C06 0002               4529              CMPI.B  #%10,D6
0000467A  6700 0122               4530              BEQ     _RoxLong
0000467E                          4531              * roll
0000467E  0803 0008               4532              BTST.L  #$08,D3 * test 8th bit for direction
00004682  6700 002E               4533              BEQ     _RorLong   * if bit is 0, it is right
00004686                          4534              * it is left
00004686                          4535  * ROL.L ----------------------
00004686  14FC 0052               4536              MOVE.B  #'R',(A2)+ * add "ROL.L" to A2 string
0000468A  14FC 004F               4537              MOVE.B  #'O',(A2)+
0000468E  14FC 004C               4538              MOVE.B  #'L',(A2)+
00004692  14FC 002E               4539              MOVE.B  #'.',(A2)+
00004696  14FC 004C               4540              MOVE.B  #'L',(A2)+
0000469A  14FC 0020               4541              MOVE.B  #' ',(A2)+
0000469E  14FC 0020               4542              MOVE.B  #' ',(A2)+
000046A2  14FC 0020               4543              MOVE.B  #' ',(A2)+
000046A6  14FC 0020               4544              MOVE.B  #' ',(A2)+
000046AA  14FC 0020               4545              MOVE.B  #' ',(A2)+
000046AE  6000 014E               4546              BRA     _ShiftEA    * branch to shift EA to finish
000046B2                          4547              
000046B2                          4548  * ROR.L ----------------------            
000046B2  14FC 0052               4549  _RorLong    MOVE.B  #'R',(A2)+ * add "ROR.L" to A2 string
000046B6  14FC 004F               4550              MOVE.B  #'O',(A2)+
000046BA  14FC 0052               4551              MOVE.B  #'R',(A2)+
000046BE  14FC 002E               4552              MOVE.B  #'.',(A2)+
000046C2  14FC 004C               4553              MOVE.B  #'L',(A2)+
000046C6  14FC 0020               4554              MOVE.B  #' ',(A2)+
000046CA  14FC 0020               4555              MOVE.B  #' ',(A2)+
000046CE  14FC 0020               4556              MOVE.B  #' ',(A2)+
000046D2  14FC 0020               4557              MOVE.B  #' ',(A2)+
000046D6  14FC 0020               4558              MOVE.B  #' ',(A2)+
000046DA  6000 0122               4559              BRA     _ShiftEA    * branch to shift EA to finis
000046DE                          4560              
000046DE  0803 0008               4561  _AsLong     BTST.L  #$08,D3 * test 8th bit for direction
000046E2  6700 002E               4562              BEQ     _AsrLong   * if bit is 0, it is right
000046E6                          4563              * it is left
000046E6                          4564  * ASL.L ----------------------
000046E6  14FC 0041               4565              MOVE.B  #'A',(A2)+ * add "ASL.L" to A2 string
000046EA  14FC 0053               4566              MOVE.B  #'S',(A2)+
000046EE  14FC 004C               4567              MOVE.B  #'L',(A2)+
000046F2  14FC 002E               4568              MOVE.B  #'.',(A2)+
000046F6  14FC 004C               4569              MOVE.B  #'L',(A2)+
000046FA  14FC 0020               4570              MOVE.B  #' ',(A2)+
000046FE  14FC 0020               4571              MOVE.B  #' ',(A2)+
00004702  14FC 0020               4572              MOVE.B  #' ',(A2)+
00004706  14FC 0020               4573              MOVE.B  #' ',(A2)+
0000470A  14FC 0020               4574              MOVE.B  #' ',(A2)+
0000470E  6000 00EE               4575              BRA     _ShiftEA    * branch to shift EA to finish
00004712                          4576              
00004712                          4577  * ASR.L ----------------------           
00004712  14FC 0041               4578  _AsrLong    MOVE.B  #'A',(A2)+ * add "ASR.L" to A2 string
00004716  14FC 0053               4579              MOVE.B  #'S',(A2)+
0000471A  14FC 0052               4580              MOVE.B  #'R',(A2)+
0000471E  14FC 002E               4581              MOVE.B  #'.',(A2)+
00004722  14FC 004C               4582              MOVE.B  #'L',(A2)+
00004726  14FC 0020               4583              MOVE.B  #' ',(A2)+
0000472A  14FC 0020               4584              MOVE.B  #' ',(A2)+
0000472E  14FC 0020               4585              MOVE.B  #' ',(A2)+
00004732  14FC 0020               4586              MOVE.B  #' ',(A2)+
00004736  14FC 0020               4587              MOVE.B  #' ',(A2)+
0000473A  6000 00C2               4588              BRA     _ShiftEA    * branch to shift EA to finish
0000473E                          4589  
0000473E  0803 0008               4590  _LsLong     BTST.L  #$08,D3 * test 8th bit for direction
00004742  6700 002E               4591              BEQ     _LsrLong   * if bit is 0, it is right
00004746                          4592              * it is left
00004746                          4593  * LSL.L ----------------------
00004746  14FC 004C               4594              MOVE.B  #'L',(A2)+ * add "LSL.L" to A2 string
0000474A  14FC 0053               4595              MOVE.B  #'S',(A2)+
0000474E  14FC 004C               4596              MOVE.B  #'L',(A2)+
00004752  14FC 002E               4597              MOVE.B  #'.',(A2)+
00004756  14FC 004C               4598              MOVE.B  #'L',(A2)+
0000475A  14FC 0020               4599              MOVE.B  #' ',(A2)+
0000475E  14FC 0020               4600              MOVE.B  #' ',(A2)+
00004762  14FC 0020               4601              MOVE.B  #' ',(A2)+
00004766  14FC 0020               4602              MOVE.B  #' ',(A2)+
0000476A  14FC 0020               4603              MOVE.B  #' ',(A2)+
0000476E  6000 008E               4604              BRA     _ShiftEA    * branch to shift EA to finish
00004772                          4605              
00004772                          4606  * LSR.L ----------------------            
00004772  14FC 004C               4607  _LsrLong    MOVE.B  #'L',(A2)+ * add "LSR.L" to A2 string
00004776  14FC 0053               4608              MOVE.B  #'S',(A2)+
0000477A  14FC 0052               4609              MOVE.B  #'R',(A2)+
0000477E  14FC 002E               4610              MOVE.B  #'.',(A2)+
00004782  14FC 004C               4611              MOVE.B  #'L',(A2)+
00004786  14FC 0020               4612              MOVE.B  #' ',(A2)+
0000478A  14FC 0020               4613              MOVE.B  #' ',(A2)+
0000478E  14FC 0020               4614              MOVE.B  #' ',(A2)+
00004792  14FC 0020               4615              MOVE.B  #' ',(A2)+
00004796  14FC 0020               4616              MOVE.B  #' ',(A2)+
0000479A  6000 0062               4617              BRA     _ShiftEA    * branch to shift EA to finish
0000479E                          4618              
0000479E                          4619  
0000479E  0803 0008               4620  _RoxLong    BTST.L  #$08,D3 * test 8th bit for direction
000047A2  6700 002E               4621              BEQ     _RoxrLong  * if bit is 0, it is right
000047A6                          4622              * it is left
000047A6                          4623  * ROXL.L ---------------------
000047A6  14FC 0052               4624              MOVE.B  #'R',(A2)+ * add "ROXL.L" to A2 string
000047AA  14FC 004F               4625              MOVE.B  #'O',(A2)+
000047AE  14FC 0058               4626              MOVE.B  #'X',(A2)+
000047B2  14FC 004C               4627              MOVE.B  #'L',(A2)+
000047B6  14FC 002E               4628              MOVE.B  #'.',(A2)+
000047BA  14FC 004C               4629              MOVE.B  #'L',(A2)+
000047BE  14FC 0020               4630              MOVE.B  #' ',(A2)+
000047C2  14FC 0020               4631              MOVE.B  #' ',(A2)+
000047C6  14FC 0020               4632              MOVE.B  #' ',(A2)+
000047CA  14FC 0020               4633              MOVE.B  #' ',(A2)+
000047CE  6000 002E               4634              BRA     _ShiftEA    * branch to shift EA to finish
000047D2                          4635              
000047D2                          4636  * ROXR.L ---------------------            
000047D2  14FC 0052               4637  _RoxrLong   MOVE.B  #'R',(A2)+ * add "ROXR.L" to A2 string
000047D6  14FC 004F               4638              MOVE.B  #'O',(A2)+
000047DA  14FC 0058               4639              MOVE.B  #'X',(A2)+
000047DE  14FC 0052               4640              MOVE.B  #'R',(A2)+
000047E2  14FC 002E               4641              MOVE.B  #'.',(A2)+
000047E6  14FC 004C               4642              MOVE.B  #'L',(A2)+
000047EA  14FC 0020               4643              MOVE.B  #' ',(A2)+
000047EE  14FC 0020               4644              MOVE.B  #' ',(A2)+
000047F2  14FC 0020               4645              MOVE.B  #' ',(A2)+
000047F6  14FC 0020               4646              MOVE.B  #' ',(A2)+
000047FA  6000 0002               4647              BRA     _ShiftEA    * branch to shift EA to finish
000047FE                          4648              
000047FE                          4649  _ShiftEA    
000047FE  0803 0005               4650              BTST.L  #$05,D3     * determine if it is a shift using a register
00004802  6700 0036               4651              BEQ     _shiftImm
00004806  14FC 0044               4652              MOVE.B  #'D',(A2)+
0000480A  4843                    4653              SWAP    D3
0000480C  E98B                    4654              LSL.L   #4,D3       * shift out opcode
0000480E  4EB8 1564               4655              JSR     BitTst3     * get next three bits for source reg number
00004812  4DF9 00004A72           4656              LEA     numTable,A6 * load num table
00004818  CCFC 0008               4657              MULU    #8,D6       * multiply for offset
0000481C  4EB6 6000               4658              JSR     (A6,D6)     * jump to get number
00004820                          4659              
00004820  14FC 002C               4660  _shiftDest  MOVE.B  #',',(A2)+
00004824  14FC 0044               4661              MOVE.B  #'D',(A2)+
00004828  E18B                    4662              LSL.L   #8,D3       * shift out all bits but 0->2
0000482A  E38B                    4663              LSL.L   #1,D3
0000482C  4EB8 1564               4664              JSR     BitTst3     * test for data register
00004830  CCFC 0008               4665              MULU    #8,D6       * multiply for offset
00004834  4EB6 6000               4666              JSR     (A6,D6)     * jump to get number
00004838  4E75                    4667              RTS
0000483A                          4668  _shiftImm
0000483A  14FC 0023               4669              MOVE.B  #'#',(A2)+
0000483E  4843                    4670              SWAP    D3
00004840  E98B                    4671              LSL.L   #4,D3       * shift out opcode
00004842  4EB8 1564               4672              JSR     BitTst3     * get next three bits for data value being shifted
00004846  0C06 0000               4673              CMPI.B  #%000,D6    * if it is 000, add 8 to D6
0000484A  6600 0006               4674              BNE     _shftIM     * if not, continue to next part
0000484E  4EB8 2C10               4675              JSR     Add8        * jump to subroutine to add 8 to D6
00004852  4DF9 00004A72           4676  _shftIM     LEA     numTable,A6 * load num table
00004858  CCFC 0008               4677              MULU    #8,D6       * multiply for offset
0000485C  4EB6 6000               4678              JSR     (A6,D6)     * jump to get number
00004860  60BE                    4679              BRA     _shiftDest  * get destination register
00004862                          4680                             
00004862                          4681  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
00004862                          4682  *                          END OF OP CODES                                    *
00004862                          4683  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
00004862                          4684              
00004862                          4685  *******************************************************************************
00004862                          4686  * OPERROR - Used when data or an illegal instruction is encountered.
00004862                          4687  * Resets A2 to the end of the PC to overwrite the new string.
00004862                          4688  * Also could reset the current address, A4, if an EA has been read incorrectly.
00004862                          4689  *******************************************************************************
00004862                          4690  OPERROR     
00004862  0C38 0001 0015          4691              CMPI.B  #1,EA_FLAG  * see if the ea flag has been set
00004868  6600 0004               4692              BNE     Next
0000486C  2845                    4693              MOVEA.L D5,A4       * reset A4
0000486E  244B                    4694  Next        MOVEA.L A3,A2       * reset A2 to overwrite current string
00004870  14FC 0044               4695              MOVE.B  #'D',(A2)+  * add DATA to A2 String
00004874  14FC 0041               4696              MOVE.B  #'A',(A2)+
00004878  14FC 0054               4697              MOVE.B  #'T',(A2)+
0000487C  14FC 0041               4698              MOVE.B  #'A',(A2)+
00004880  14FC 0020               4699              MOVE.B  #' ',(A2)+
00004884  14FC 0020               4700              MOVE.B  #' ',(A2)+
00004888  14FC 0020               4701              MOVE.B  #' ',(A2)+
0000488C  14FC 0020               4702              MOVE.B  #' ',(A2)+
00004890  14FC 0020               4703              MOVE.B  #' ',(A2)+
00004894  14FC 0020               4704              MOVE.B  #' ',(A2)+
00004898  14FC 0024               4705              MOVE.B  #'$',(A2)+
0000489C  4EB9 000048AA           4706              JSR     printErrorData
000048A2  11FC 0000 0015          4707              MOVE.B  #0,EA_FLAG  * reset ea flag for next instruction
000048A8  4E75                    4708              RTS
000048AA                          4709  
000048AA                          4710  printErrorData
000048AA                          4711              
000048AA  4242                    4712              CLR     D2      * clear d2 for counter
000048AC  4DF9 00004A72           4713              LEA     numTable,A6
000048B2  2604                    4714              MOVE.L  D4,D3
000048B4  4843                    4715              SWAP    D3
000048B6                          4716              
000048B6                          4717  printELoop  
000048B6  0C02 0004               4718              CMPI.B  #4,D2       * loop through 4 times,
000048BA  6700 0014               4719              BEQ     loopDone    * print done
000048BE  4EB8 1538               4720              JSR     BITTEST     * get leading 4 bits
000048C2  CCFC 0008               4721              MULU    #8,D6       * multiply by 8 for jump offset
000048C6  4EB6 6000               4722              JSR     (A6,D6)     * get number from table and add to A2 string
000048CA  E98B                    4723              LSL.L   #4,D3       * shift out 4 biths were done with
000048CC  5242                    4724              ADDQ    #1,D2       * increment loop counter
000048CE  60E6                    4725              BRA     printELoop  * branch back to loop
000048D0                          4726  
000048D0                          4727  loopDone    
000048D0  4E75                    4728              RTS
000048D2                          4729     
000048D2                          4730  
000048D2                          4731  * EA Jump Table ------------------------------------------------------
000048D2  4EB9 00004912           4732  eaTable     JSR     ea000    * data register
000048D8  4E75                    4733              RTS             
000048DA  4EB9 00004932           4734              JSR     ea001    * address register
000048E0  4E75                    4735              RTS             
000048E2  4EB9 00004960           4736              JSR     ea010    * indirect address register
000048E8  4E75                    4737              RTS             
000048EA  4EB9 00004988           4738              JSR     ea011    * post increment address
000048F0  4E75                    4739              RTS             
000048F2  4EB9 000049B4           4740              JSR     ea100    * address pre decrement
000048F8  4E75                    4741              RTS             
000048FA  4EB9 000049E0           4742              JSR     ea101    * unsupported
00004900  4E75                    4743              RTS             
00004902  4EB9 000049E6           4744              JSR     ea110    * unsupported
00004908  4E75                    4745              RTS             
0000490A  4EB9 000049EC           4746              JSR     ea111     * immediate/absolute address
00004910  4E75                    4747              RTS             
00004912                          4748              
00004912                          4749              
00004912                          4750  * Dn -----------------------------------------------------------------
00004912                          4751  ea000
00004912  14FC 0044               4752              MOVE.B  #'D',(A2)+  * add D to A2 string
00004916                          4753                  
00004916  2604                    4754              MOVE.L  D4,D3       * copy data to D3
00004918  4843                    4755              SWAP    D3
0000491A  EB8B                    4756              LSL.L   #5,D3       * clear bits until register number
0000491C  E18B                    4757              LSL.L   #8,D3       
0000491E                          4758              
0000491E  4EB8 1564               4759              JSR     BitTst3
00004922                          4760              
00004922  4DF9 00004A72           4761              LEA     numTable,A6 ;load table
00004928  CCFC 0008               4762              MULU    #8,D6       ;get jump table to work
0000492C  4EB6 6000               4763              JSR     (A6,D6)    ;print number
00004930                          4764              
00004930                          4765              
00004930  4E75                    4766              RTS
00004932                          4767  
00004932                          4768              
00004932                          4769  * An -----------------------------------------------------------------
00004932                          4770  ea001
00004932  BE3C 0001               4771              CMP.B   #1,D7       * cannot move Address with byte data
00004936  6700 0022               4772              BEQ     isByte     * error
0000493A                          4773               
0000493A                          4774              
0000493A  14FC 0041               4775              MOVE.B  #'A',(A2)+  * print A
0000493E  2604                    4776              MOVE.L  D4,D3       * reset D3
00004940  4843                    4777              SWAP    D3          * move bits to front
00004942  E18B                    4778              LSL.L   #8,D3       * shift all bits out but 0-2
00004944  EB8B                    4779              LSL.L   #5,D3
00004946  4EB8 1564               4780              JSR     BitTst3     * test these three bits
0000494A                          4781              
0000494A  4DF9 00004A72           4782              LEA     numTable,A6 * load table
00004950  CCFC 0008               4783              MULU    #8,D6       * offset
00004954  4EB6 6000               4784              JSR     (A6,D6)     * print
00004958                          4785              
00004958  4E75                    4786              RTS
0000495A                          4787              
0000495A  1E3C 0004               4788  isByte      MOVE.B  #4,D7   * set error
0000495E  4E75                    4789              RTS
00004960                          4790  
00004960                          4791             
00004960                          4792  * (An) ---------------------------------------------------------------
00004960                          4793  ea010
00004960                          4794  
00004960  14FC 0028               4795              MOVE.B  #'(',(A2)+  * print (
00004964  14FC 0041               4796              MOVE.B  #'A',(A2)+  * print A
00004968                          4797              
00004968  2604                    4798              MOVE.L  D4,D3       * reset D3
0000496A  4843                    4799              SWAP    D3          * move bits to front
0000496C  E18B                    4800              LSL.L   #8,D3       * shift all bits out but 0-2
0000496E  EB8B                    4801              LSL.L   #5,D3
00004970  4EB8 1564               4802              JSR     BitTst3     * test these three bits
00004974  4DF9 00004A72           4803              LEA     numTable,A6 * load table
0000497A  CCFC 0008               4804              MULU    #8,D6       * offset
0000497E  4EB6 6000               4805              JSR     (A6,D6)     * print number
00004982                          4806              
00004982  14FC 0029               4807              MOVE.B  #')',(A2)+  * print )
00004986                          4808              
00004986                          4809  
00004986  4E75                    4810              RTS
00004988                          4811  
00004988                          4812              
00004988                          4813  * (An)+ --------------------------------------------------------------
00004988                          4814  ea011
00004988                          4815  
00004988  14FC 0028               4816              MOVE.B  #'(',(A2)+  * print (
0000498C  14FC 0041               4817              MOVE.B  #'A',(A2)+  * print A
00004990                          4818              
00004990  2604                    4819              MOVE.L  D4,D3       * reset D3
00004992  4843                    4820              SWAP    D3          * move bits to front
00004994  E18B                    4821              LSL.L   #8,D3       * shift all bits out but 0-2
00004996  EB8B                    4822              LSL.L   #5,D3
00004998  4EB8 1564               4823              JSR     BitTst3     * test these three bits
0000499C                          4824              
0000499C  4DF9 00004A72           4825              LEA     numTable,A6 * load table
000049A2  CCFC 0008               4826              MULU    #8,D6       * offset
000049A6  4EB6 6000               4827              JSR     (A6,D6)    * print number
000049AA                          4828              
000049AA  14FC 0029               4829              MOVE.B  #')',(A2)+  * print )
000049AE  14FC 002B               4830              MOVE.B  #'+',(A2)+  * print +
000049B2                          4831              
000049B2                          4832  
000049B2  4E75                    4833              RTS
000049B4                          4834  
000049B4                          4835              
000049B4                          4836  * -(An) --------------------------------------------------------------
000049B4                          4837  ea100
000049B4                          4838  
000049B4  14FC 002D               4839              MOVE.B  #'-',(A2)+  * print -
000049B8  14FC 0028               4840              MOVE.B  #'(',(A2)+  * print (
000049BC  14FC 0041               4841              MOVE.B  #'A',(A2)+  * print A
000049C0  2604                    4842              MOVE.L  D4,D3       * reset D3
000049C2  4843                    4843              SWAP    D3          * move bits to front
000049C4  E18B                    4844              LSL.L   #8,D3       * shift all bits out but 0-2
000049C6  EB8B                    4845              LSL.L   #5,D3
000049C8  4EB8 1564               4846              JSR     BitTst3     * test these three bits
000049CC                          4847              
000049CC  4DF9 00004A72           4848              LEA     numTable,A6 ;load table
000049D2  CCFC 0008               4849              MULU    #8,D6       ;get jump table to work
000049D6  4EB6 6000               4850              JSR     (A6,D6)    ;print number
000049DA                          4851              
000049DA  14FC 0029               4852              MOVE.B  #')',(A2)+  ;print )
000049DE                          4853              
000049DE                          4854  
000049DE  4E75                    4855              RTS
000049E0                          4856  
000049E0                          4857              
000049E0                          4858  * Subroutine not supported ---------------------------------------------
000049E0                          4859  ea101
000049E0                          4860  
000049E0  1E3C 0004               4861              MOVE.B  #4,D7
000049E4  4E75                    4862              RTS
000049E6                          4863              
000049E6                          4864  
000049E6                          4865              
000049E6                          4866  * Subroutine not supported --------------------------------------------
000049E6                          4867  ea110
000049E6                          4868  
000049E6  1E3C 0004               4869              MOVE.B  #4,D7 * set error flag
000049EA  4E75                    4870              RTS      
000049EC                          4871              
000049EC                          4872  
000049EC                          4873             
000049EC                          4874  * Immediate and Absolute -----------------------------------------------
000049EC                          4875  ea111
000049EC  2604                    4876              MOVE.L  D4,D3       * reset D3
000049EE  4843                    4877              SWAP    D3          * move bits to front
000049F0  E18B                    4878              LSL.L   #8,D3       * shift all bits out but 0-2
000049F2  EB8B                    4879              LSL.L   #5,D3
000049F4  4EB8 1564               4880              JSR     BitTst3     * test these three bits
000049F8  0C06 0000               4881              CMPI.B  #%000,D6    * compare to absolute short
000049FC  6700 0060               4882              BEQ     shortAbs
00004A00  0C06 0001               4883              CMPI.B  #%001,D6    * compare to absolute long
00004A04  6700 0062               4884              BEQ     longAbs
00004A08  0C06 0004               4885              CMPI.B  #%100,D6    * compare to immediate
00004A0C  6700 0008               4886              BEQ     immediate
00004A10                          4887  
00004A10  1E3C 0004               4888              MOVE.B  #4,D7   * set error
00004A14  4E75                    4889              RTS          
00004A16                          4890              
00004A16                          4891  immediate
00004A16  BE3C 0001               4892              CMP.B   #1,D7       * compare to byte
00004A1A  6700 0018               4893              BEQ     _ByteData      
00004A1E  BE3C 0002               4894              CMP.B   #2,D7       * compare to word
00004A22  6700 001E               4895              BEQ     _WordData
00004A26  BE3C 0003               4896              CMP.B   #3,D7       * compare to long
00004A2A  6700 0024               4897              BEQ     _LongData
00004A2E                          4898  
00004A2E  1E3C 0004               4899              MOVE.B  #4,D7       * set error flag
00004A32  4E75                    4900              RTS
00004A34                          4901                               
00004A34                          4902              
00004A34                          4903  _ByteData
00004A34  14FC 0023               4904              MOVE.B  #'#',(A2)+  * print #
00004A38  14FC 0024               4905              MOVE.B  #'$',(A2)+  * print $
00004A3C  4EB8 15AE               4906              JSR     printByte
00004A40  4E75                    4907              RTS                 
00004A42                          4908              
00004A42                          4909  _WordData
00004A42  14FC 0023               4910              MOVE.B  #'#',(A2)+  * print #
00004A46  14FC 0024               4911              MOVE.B  #'$',(A2)+  * print $
00004A4A  4EB8 15DE               4912              JSR     printWord
00004A4E  4E75                    4913              RTS                 
00004A50                          4914              
00004A50                          4915  _LongData
00004A50  14FC 0023               4916              MOVE.B  #'#',(A2)+  * print #
00004A54  14FC 0024               4917              MOVE.B  #'$',(A2)+  * print $
00004A58  4EB8 160C               4918              JSR     printLong
00004A5C  4E75                    4919              RTS                 
00004A5E                          4920  
00004A5E                          4921  shortAbs
00004A5E  14FC 0024               4922              MOVE.B  #'$',(A2)+  * print $
00004A62  4EB8 15DE               4923              JSR     printWord   
00004A66  4E75                    4924              RTS                 
00004A68                          4925              
00004A68                          4926  longAbs
00004A68  14FC 0024               4927              MOVE.B  #'$',(A2)+  * print $
00004A6C  4EB8 160C               4928              JSR     printLong
00004A70  4E75                    4929              RTS                 
00004A72                          4930              
00004A72                          4931  
00004A72                          4932  * Number Jump Table ----------------------------------------
00004A72  4EB9 00004AF2           4933  numTable    JSR     n0   * 0
00004A78  4E75                    4934              RTS             
00004A7A  4EB9 00004AF8           4935              JSR     n1   * 1
00004A80  4E75                    4936              RTS             
00004A82  4EB9 00004AFE           4937              JSR     n2   * 2
00004A88  4E75                    4938              RTS             
00004A8A  4EB9 00004B04           4939              JSR     n3   * 3
00004A90  4E75                    4940              RTS             
00004A92  4EB9 00004B0A           4941              JSR     n4   * 4
00004A98  4E75                    4942              RTS             
00004A9A  4EB9 00004B10           4943              JSR     n5   * 5
00004AA0  4E75                    4944              RTS             
00004AA2  4EB9 00004B16           4945              JSR     n6   * 6
00004AA8  4E75                    4946              RTS             
00004AAA  4EB9 00004B1C           4947              JSR     n7   * 7
00004AB0  4E75                    4948              RTS             
00004AB2  4EB9 00004B22           4949              JSR     n8   * 8
00004AB8  4E75                    4950              RTS             
00004ABA  4EB9 00004B28           4951              JSR     n9   * 9
00004AC0  4E75                    4952              RTS             
00004AC2  4EB9 00004B2E           4953              JSR     nA   * A
00004AC8  4E75                    4954              RTS             
00004ACA  4EB9 00004B34           4955              JSR     nB   * B
00004AD0  4E75                    4956              RTS             
00004AD2  4EB9 00004B3A           4957              JSR     nC   * C
00004AD8  4E75                    4958              RTS             
00004ADA  4EB9 00004B40           4959              JSR     nD   * D
00004AE0  4E75                    4960              RTS             
00004AE2  4EB9 00004B46           4961              JSR     nE   * E
00004AE8  4E75                    4962              RTS             
00004AEA  4EB9 00004B4C           4963              JSR     nF   * F
00004AF0  4E75                    4964              RTS             
00004AF2                          4965  
00004AF2                          4966              
00004AF2                          4967  * Print 0 ------------------------------------------
00004AF2                          4968  n0
00004AF2  14FC 0030               4969              MOVE.B  #'0',(A2)+      * add 0 to string
00004AF6  4E75                    4970              RTS
00004AF8                          4971  
00004AF8                          4972            
00004AF8                          4973  * Print 1 ------------------------------------------
00004AF8                          4974  n1
00004AF8  14FC 0031               4975              MOVE.B  #'1',(A2)+      * add 1 to string
00004AFC  4E75                    4976              RTS
00004AFE                          4977  
00004AFE                          4978             
00004AFE                          4979  * Print 2 ------------------------------------------
00004AFE                          4980  n2
00004AFE  14FC 0032               4981              MOVE.B  #'2',(A2)+      * add 2 to string
00004B02  4E75                    4982              RTS
00004B04                          4983   
00004B04                          4984              
00004B04                          4985  * Print 3 ------------------------------------------
00004B04                          4986  n3
00004B04  14FC 0033               4987              MOVE.B  #'3',(A2)+      * add 3 to string
00004B08  4E75                    4988              RTS
00004B0A                          4989  
00004B0A                          4990              
00004B0A                          4991  * Print 4 ------------------------------------------
00004B0A                          4992  n4
00004B0A  14FC 0034               4993              MOVE.B  #'4',(A2)+      * add 4 to string
00004B0E  4E75                    4994              RTS
00004B10                          4995  
00004B10                          4996              
00004B10                          4997  * Print 5 ------------------------------------------
00004B10                          4998  n5
00004B10  14FC 0035               4999              MOVE.B  #'5',(A2)+      * add 5 to string
00004B14  4E75                    5000              RTS
00004B16                          5001  
00004B16                          5002              
00004B16                          5003  * Print 6 ------------------------------------------
00004B16                          5004  n6
00004B16  14FC 0036               5005              MOVE.B  #'6',(A2)+      * add 6 to string
00004B1A  4E75                    5006              RTS
00004B1C                          5007              
00004B1C                          5008              
00004B1C                          5009  * Print 7 ------------------------------------------
00004B1C                          5010  n7
00004B1C  14FC 0037               5011              MOVE.B  #'7',(A2)+      * add 7 to string
00004B20  4E75                    5012              RTS
00004B22                          5013  
00004B22                          5014   
00004B22                          5015  * Print 8 ------------------------------------------
00004B22                          5016  n8       
00004B22  14FC 0038               5017              MOVE.B  #'8',(A2)+      * add 8 to string
00004B26  4E75                    5018              RTS
00004B28                          5019  
00004B28                          5020              
00004B28                          5021  * Print 9 ------------------------------------------
00004B28                          5022  n9   
00004B28  14FC 0039               5023              MOVE.B  #'9',(A2)+      * add 9 to string
00004B2C  4E75                    5024              RTS
00004B2E                          5025  
00004B2E                          5026              
00004B2E                          5027  * Print A ------------------------------------------
00004B2E                          5028  nA   
00004B2E  14FC 0041               5029              MOVE.B  #'A',(A2)+      * add A to string
00004B32  4E75                    5030              RTS
00004B34                          5031  
00004B34                          5032              
00004B34                          5033  * Print B ------------------------------------------
00004B34                          5034  nB   
00004B34  14FC 0042               5035              MOVE.B  #'B',(A2)+      * add B to string
00004B38  4E75                    5036              RTS
00004B3A                          5037  
00004B3A                          5038              
00004B3A                          5039  * Print C ------------------------------------------
00004B3A                          5040  nC   
00004B3A  14FC 0043               5041              MOVE.B  #'C',(A2)+      * add C to string
00004B3E  4E75                    5042              RTS
00004B40                          5043  
00004B40                          5044             
00004B40                          5045  * Print D ------------------------------------------
00004B40                          5046  nD   
00004B40  14FC 0044               5047              MOVE.B  #'D',(A2)+      * add D to string
00004B44  4E75                    5048              RTS
00004B46                          5049  
00004B46                          5050             
00004B46                          5051  * Print E ------------------------------------------
00004B46                          5052  nE  
00004B46  14FC 0045               5053              MOVE.B  #'E',(A2)+      * add E to string
00004B4A  4E75                    5054              RTS
00004B4C                          5055  
00004B4C                          5056              
00004B4C                          5057  * Print F ------------------------------------------
00004B4C                          5058  nF   
00004B4C  14FC 0046               5059              MOVE.B  #'F',(A2)+      * add F to string
00004B50  4E75                    5060              RTS
00004B52                          5061  
00004B52                          5062  restart
00004B52                          5063  
00004B52  11FC 0000 0065          5064              MOVE.B  #$0,lines_flag  * initialize lines to 0
00004B58  11FC 0000 0014          5065              MOVE.B  #$0,start_flag  *initialize start flag to 0
00004B5E  11FC 0000 0015          5066              MOVE.B  #$0,EA_FLAG     * initialize ea flag to 0 
00004B64  287C 00000000           5067              MOVEA.L #0,A4           * clear current address
00004B6A  2A7C 00000000           5068              MOVEA.L #0,A5           * clear ending address
00004B70                          5069              
00004B70  6000 C4B0               5070              BRA     GET_LOWER
00004B74                          5071              
00004B74                          5072  
00004B74                          5073  DONE
00004B74                          5074  
00004B74  4240                    5075          CLR     D0
00004B76  43F8 1457               5076          LEA     repeat,A1       * load message to ask if user wants to repeat
00004B7A  103C 000E               5077          MOVE.B  #14,D0
00004B7E  4E4F                    5078          TRAP    #15
00004B80                          5079          
00004B80  43F8 00AB               5080          LEA     restart_in,A1   * capture the user input
00004B84  7002                    5081          MOVE.L  #2,D0
00004B86  4E4F                    5082          TRAP    #15
00004B88                          5083          
00004B88  1211                    5084          MOVE.B  (A1),D1         * place answer in D1
00004B8A  0C01 0059               5085          CMPI.B  #$59,D1         * compare with upper case Y
00004B8E  67C2                    5086          BEQ     restart
00004B90  0C01 0079               5087          CMPI.B  #$79,D1         * compare with lower case y
00004B94  67BC                    5088          BEQ     restart
00004B96                          5089          
00004B96  43F8 1487               5090          LEA     ending,A1       * chose not to restart, ending message
00004B9A  103C 000E               5091          MOVE.B  #14,D0
00004B9E  4E4F                    5092          TRAP    #15
00004BA0                          5093  
00004BA0                          5094      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD0001             1560
ADD001              1582
ADD0010             155C
ADD01               159A
ADD010              157E
ADD0100             1558
ADD10               1596
ADD100              157A
ADD1000             1554
ADD8                2C10
ADDQB               28EE
ADDQL               2A02
ADDQW               2978
ADDRBOUNDERR        12D5
BADCHAR             1293
BIT0                1572
BIT1                156C
BITTEST             1538
BITTST2             1586
BITTST3             1564
BOUNDSERR           10F2
BT1                 158E
BYTEDISPLP          2E98
CHARERROR           110C
CHECK_INPUT         106A
CHK_BOUNDS          1126
CR                  D
CTST                154C
DISPDONE            2EB2
DONE                4B74
DTST                1546
EA000               4912
EA001               4932
EA010               4960
EA011               4988
EA100               49B4
EA101               49E0
EA110               49E6
EA111               49EC
EATABLE             48D2
EA_FLAG             15
ENDADDR             1223
ENDERR              1365
ENDERROR            11DC
ENDING              1487
END_INPUT           6F
ETST                1540
GETINSTR            1658
GETMODE             163C
GETPC               1500
GETPCDN             1536
GETPCLP             151A
GETSIZE             159E
GET_LOWER           1022
GET_UPPER           1044
HALT                143F
HALTDISPLAY         14EE
HIERR               13F6
HIERROR             11C2
IMMEDIATE           4A16
ISBYTE              495A
JUMPSR              20A0
LF                  A
LINES_FLAG          65
LOERR               13B0
LOHEX               10C4
LONGABS             4A68
LOOPDONE            48D0
LOWERBOUND          1146
LOWERROR            1198
MAIN                14B0
MAINLOOP            14B4
MAXEND              FFFFE0
MINSTART            0
MOVEABS             202E
MOVEADDR            1F96
MOVEDN              1F78
MOVEIND             1FB4
MOVEPOST            1FDA
MOVEPRE             2004
N0                  4AF2
N1                  4AF8
N2                  4AFE
N3                  4B04
N4                  4B0A
N5                  4B10
N6                  4B16
N7                  4B1C
N8                  4B22
N9                  4B28
NA                  4B2E
NB                  4B34
NC                  4B3A
ND                  4B40
NE                  4B46
NEXT                486E
NF                  4B4C
NOINPUT             10D8
NOOP                2118
NO_INPUT            1268
NUMTABLE            4A72
ODDERR              1324
ODDERROR            117E
OP0000              16EC
OP0001              1D30
OP0010              1DB4
OP0011              1E96
OP0100              2052
OP0101              2878
OP0110              2C14
OP0111              2EB4
OP1000              2F0A
OP1001              3366
OP1011              36E6
OP1100              38B2
OP1101              3CBE
OP1110              412A
OPERROR             4862
PD_A1               2548
PD_A2               2550
PD_A3               2558
PD_A4               2560
PD_A5               2568
PD_A6               2570
PD_A7               2578
PD_D0               2580
PD_D1               2588
PD_D2               2590
PD_D3               2598
PD_D4               25A0
PD_D5               25A8
PD_D6               25B0
PD_D7               25B8
PI_A0               23A8
PI_A1               23B0
PI_A2               23B8
PI_A3               23C0
PI_A4               23C8
PI_A5               23D0
PI_A6               23D8
PI_A7               23E0
PI_D1               2370
PI_D2               2378
PI_D3               2380
PI_D4               2388
PI_D5               2390
PI_D6               2398
PI_D7               23A0
POSTINC             2366
PREDEC              253E
PRINTBLOOP          15C4
PRINTBYTE           15AE
PRINTCODE           83
PRINTDN             163A
PRINTELOOP          48B6
PRINTERRORDATA      48AA
PRINTLINE           164A
PRINTLLOOP          1620
PRINTLONG           160C
PRINTSLASH          270C
PRINTWLOOP          15F2
PRINTWORD           15DE
PRTSLASHDN          2718
READDONE            10D6
READNEXT            107E
REPEAT              1457
RESTART             4B52
RESTART_IN          AB
RETURNSR            210A
SHORTABS            4A5E
START               1000
STARTADDR           11EA
START_FLAG          14
START_INPUT         0
SUBQB               2AB6
SUBQL               2BCA
SUBQW               2B40
SUB_EA              3530
UPHEX               10AA
UPPERBOUND          1162
_A0                 2494
_A1                 24AA
_A2                 24C0
_A3                 24D6
_A4                 24EC
_A5                 2502
_A6                 2518
_A7                 252E
_ADDA               404E
_ADDAW              40C0
_ADDB               3CF4
_ADDBEA             3EBC
_ADDEA              3E92
_ADDI               1AC0
_ADDIB              1AE4
_ADDIL              1B9C
_ADDIW              1B40
_ADDL               3E08
_ADDLEA             3FC8
_ADDQB              28AA
_ADDQL              29BE
_ADDQW              2934
_ADDW               3D7E
_ADDWEA             3F42
_AND                3936
_ANDB               3964
_ANDBEA             3B2C
_ANDEA              3B02
_ANDI               1858
_ANDIB              187C
_ANDIL              192C
_ANDIW              18D0
_ANDL               3A78
_ANDLEA             3C38
_ANDW               39EE
_ANDWEA             3BB2
_AS                 41B4
_ASB                439A
_ASLONG             46DE
_ASR                41E8
_ASRB               43CE
_ASRLONG            4712
_ASRW               4570
_ASW                453C
_BCC                2CA4
_BCS                2CE8
_BGE                2D70
_BGT                2DF8
_BLE                2E3C
_BLT                2DB4
_BNE                2D2C
_BRA                2C60
_BYTEDATA           4A34
_BYTEDISP           2E8C
_BYTESHIFT          4318
_CLR                271A
_CLRB               273A
_CLRL               280E
_CLRW               27A4
_CMPB               3714
_CMPI               1BF8
_CMPIB              1C1C
_CMPIL              1CD4
_CMPIW              1C78
_CMPL               3828
_CMPW               379E
_CONT               14C6
_D0                 23EA
_D1                 23FA
_D2                 2410
_D3                 2426
_D4                 243C
_D5                 2452
_D6                 2468
_D7                 247E
_DIVS               2F90
_DIVU               2F26
_LEA                2126
_LONGDATA           4A50
_LONGDISP           2E86
_LONGSHIFT          465C
_LS                 4214
_LSB                43FA
_LSLONG             473E
_LSR                4248
_LSRB               442E
_LSRLONG            4772
_LSRW               45D0
_LSW                459C
_MOVEAL             1E48
_MOVEAW             1F2A
_MOVEM              21C8
_MOVEMAN            22A2
_MOVEMANL           2308
_MOVEMDN            21DE
_MOVEMDNL           2244
_OR                 2FE4
_ORB                3012
_ORB_EA             31D4
_OREA               31B0
_ORI                1720
_ORIB               1744
_ORIL               17FC
_ORIW               17A0
_ORL                3126
_ORL_EA             32E0
_ORW                309C
_ORW_EA             325A
_PDA0               265E
_PDA1               2674
_PDA2               268A
_PDA3               26A0
_PDA4               26B6
_PDA5               26CC
_PDA6               26E2
_PDA7               26F8
_PDD0               25C2
_PDD1               25D0
_PDD2               25E4
_PDD3               25F8
_PDD4               260C
_PDD5               2620
_PDD6               2636
_PDD7               264C
_ROR                4188
_RORB               436E
_RORLONG            46B2
_RORW               4510
_ROX                4274
_ROXB               445A
_ROXLONG            479E
_ROXR               42AC
_ROXRB              448E
_ROXRLONG           47D2
_ROXRW              4630
_ROXW               45FC
_SHFTIM             4852
_SHFTMEMEA          42DC
_SHIFTDEST          4820
_SHIFTEA            47FE
_SHIFTIMM           483A
_SHIFTREG           4300
_SUBB               3392
_SUBB_EA            3554
_SUBI               1988
_SUBIB              19AC
_SUBIL              1A64
_SUBIW              1A08
_SUBL               34A6
_SUBL_EA            3660
_SUBQ               2A48
_SUBQB              2A72
_SUBQL              2B86
_SUBQW              2AFC
_SUBW               341C
_SUBW_EA            35DA
_WORDDATA           4A42
_WORDDISP           2E80
_WORDSHIFT          44BA
